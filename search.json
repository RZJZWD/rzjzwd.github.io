[{"title":"嵌入式驱动开发 记录驱动ST7735过程","url":"/2025/05/09/development%20of%20the%20st7735%20driver/","content":"前言寒假回家没事做，特意带了一块1.8寸的TFT屏来练习驱动开发，驱动为ST7735，主控为是RCT6。用了三天加上查阅网上资料，算是磕磕绊绊的把驱动写完了。把开发过程中的过程和问题记录一下，做个备忘。\nST7735介绍ST7735的介绍网上非常多，我就不再重复了。对于ST7735，屏幕的显示原理不是我们应该深究的地方。只谈应用，我个人觉得其内部的RAM（姑且这么称呼）很有意思，还有写入指令一定要仔细，以及ST7735的是在上升沿读入指令数据，这点非常重要，后文会提到。\n硬件spi驱动驱动ST7735的过程也是学习配置spi的过程，所以我选择使用硬件spi。驱动屏幕不需要读数据，用不到MISO线。\n引脚定义\n\n\nGPIO\nST7735\n说明\n\n\n\nPA7\nSDA\n数据写入\n\n\nPA5\nSCL\n时钟\n\n\nPA4\nCS\n片选， 0选中 1忽略\n\n\nPC4\nRESET\n硬件复位\n\n\nPC5\nDC\n数据命令选择，0写命令 1写数据\n\n\nBLK引脚接高即可\n初始化spiSPI_InitStr.SPI_BaudRatePrescaler   = SPI_BaudRatePrescaler_2;// 使分频值达到最大SPI_InitStr.SPI_CPHA\t\t\t    = SPI_CPHA_2Edge;\t\t  // 上升沿有效SPI_InitStr.SPI_CPOL\t\t\t\t= SPI_CPOL_High;\t\t  // 低电平有效,空闲时为高SPI_InitStr.SPI_CRCPolynomial\t    = 7;\t\t\t\t\t  // 无 CRC 校验SPI_InitStr.SPI_DataSize\t\t\t= SPI_DataSize_8b;\t\t  // 发送字长为 8 位SPI_InitStr.SPI_Direction\t\t    = SPI_Direction_1Line_Tx; // 方向为发送SPI_InitStr.SPI_FirstBit\t\t\t= SPI_FirstBit_MSB;\t\t  // 高位先行SPI_InitStr.SPI_Mode\t\t\t\t= SPI_Mode_Master;\t\t  // 主机模式SPI_InitStr.SPI_NSS\t\t\t\t    = SPI_NSS_Soft;\t\t\t  // 软件控制\nCPHA控制在那个（第一or第二）边沿发送CPOL控制spi空闲时的状态（高or低）模式0 ：CPOL设置空闲时为低，当要传数据时MOSI拉高再拉低完成一位数据传输，上升沿为第一个边沿，也就是CPHA设置为1edge。模式3 : CPOL设置空闲时为高，当要传数据时MOSI拉低再拉高完成一位数据传输，上升沿为第二个边沿，也就是CPHA设置为2edge。\n\nST7735要求上升沿接收，也就是将SPI配置为模式0和模式3，如下图。\n\n（ST7735数据手册104页）\n在编写发送函数时要注意：对st7735读写都需要在片选信号拉低的情况下进行，不然st7735会忽略时钟SCL信号也就是说，不论读写都需要先将CS置0，然后再根据读写情况对DC置复位，读写结束后将CS拉高，详情可参考下面的发送函数\nspi写数据函数：\nenum TFT_DATA_CMD&#123;\tTFT_DC_CMD=0,\tTFT_DC_DATA=1&#125;;void SPI1_WriteData(uint8_t data)&#123;\tuint16_t timeout=0;\twhile(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET)&#123;\t//发送缓冲区为空时（TXE=1）才可以写入\t\tif(++timeout &gt; 200)\t\t\t\t\t\t\t\t\t\t//超时200直接退出\t\t\treturn;\t&#125;\tSPI_I2S_SendData(SPI1,data);&#125;void TFT_ST7735_Write(int c_d,uint8_t data)&#123;\tTFT_DC = c_d;\tSPI_CS = 0;\tSPI1_WriteData(data);\tSPI_CS = 1;&#125;\n\n\nST7735初始化网上初始化命令的教程有很多，直接照抄即可，下为我的配置：\nvoid TFT_ST7735_Config(void)&#123;\tTFT_ST7735_Reset();\tTFT_ST7735_Write(TFT_DC_CMD,TFT_SLPOUT);\tdelay_ms(120);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR2);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR3);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\t//===============inversion of control=============\tTFT_ST7735_Write(TFT_DC_CMD, TFT_INVCRT);\tTFT_ST7735_Write(TFT_DC_DATA, 0x03);\t//===============power set========================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x28);\tTFT_ST7735_Write(TFT_DC_DATA, 0x08);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\t\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR2);\tTFT_ST7735_Write(TFT_DC_DATA, 0xC0);\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR3);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR4);\tTFT_ST7735_Write(TFT_DC_DATA, 0x8D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2A);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR5);\tTFT_ST7735_Write(TFT_DC_DATA, 0x8D);\tTFT_ST7735_Write(TFT_DC_DATA, 0xEE);\t//===============vcom set=========================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_VMCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x1A);\t\t//===============scanning direction set===========\t\tif(TFT_DIRECTION==0)\t\tTFT_ST7735_SetScanDirection(0x00);//显示方向选择\telse if(TFT_DIRECTION==1)\tTFT_ST7735_SetScanDirection(0xC0);\telse if(TFT_DIRECTION==2)\tTFT_ST7735_SetScanDirection(0xA0);\telse\t\t\t\t\t\tTFT_ST7735_SetScanDirection(0x70);\t\t//===============gamma sequence set===============\tTFT_ST7735_Write(TFT_DC_CMD, TFT_GMCTRP1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x22);\tTFT_ST7735_Write(TFT_DC_DATA, 0x07);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2E);\tTFT_ST7735_Write(TFT_DC_DATA, 0x30);\tTFT_ST7735_Write(TFT_DC_DATA, 0x25);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x28);\tTFT_ST7735_Write(TFT_DC_DATA, 0x26);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2E);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\tTFT_ST7735_Write(TFT_DC_DATA, 0x01);\tTFT_ST7735_Write(TFT_DC_DATA, 0x03);\tTFT_ST7735_Write(TFT_DC_DATA, 0x13);\tTFT_ST7735_Write(TFT_DC_CMD, TFT_GMCTRN1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x16);\tTFT_ST7735_Write(TFT_DC_DATA, 0x06);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x26);\tTFT_ST7735_Write(TFT_DC_DATA, 0x23);\tTFT_ST7735_Write(TFT_DC_DATA, 0x27);\tTFT_ST7735_Write(TFT_DC_DATA, 0x27);\tTFT_ST7735_Write(TFT_DC_DATA, 0x25);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3B);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\tTFT_ST7735_Write(TFT_DC_DATA, 0x01);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x13);\t//===============color format set=================\tTFT_ST7735_SetColorFormat(0x05);\t//===============display on=======================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_DISPON);&#125;\n踩坑记录网上初始化命令的教程有很多，我主要说一下我在初始化中有过疑惑的几个点\n\n0x36hMADCTL命令（ST7735数据手册142页）spi数据高位先行，RGB位设置为0选择以 “RGB” 的顺序读入颜色数据\n\n初始化成功后花屏ST7735的frame memory（显存）上电后为随机值，故初始化后花屏，全屏填充白色就可以了ST7735数据手册89页）\n\n\n","categories":["STM32"],"tags":["STM32","笔记","ST7735驱动"]},{"title":"FreeRTOS备忘","url":"/2025/05/26/FreeRTOS%E5%A4%87%E5%BF%98/","content":"前言本文章用于记录学习FreeRTOS中使用过的函数，功能等内容，目的是为了方便自己快速查函数用法，归档和踩坑记录。\n\n文章主要分为以下几个板块：任务管理，队列机制，中断管理（待补充…）每个板块的大致组织结构为:1.函数名称2.函数参数3.函数作用4.函数注意及踩坑\n\n\n任务管理这里主要介绍FreeRTOS的任务管理机制，主要是任务相关函数的使用\n任务创建动态任务创建\n函数名称：xTaskCreate\nxTaskCreate(TaskFunction_t pxTaskCode,                  //任务函数指针            const char * const pcName,                  //任务名称            const configSTACK_DEPTH_TYPE usStackDepth,  //栈大小            void * const pvParameters,                  //任务参数            UBaseType_t uxPriority,                     //任务优先级            TaskHandle_t * const pxCreatedTask )        //任务句柄\n函数参数：  前几个参数都是用户自定义的，在传入参数的时候需要注意数据类型  \n\n函数作用： 如函数名称所示，是动态创建任务函数，与之相对还有一个静态创建任务函数\n\n注意： 如参数部分所示\n\n\n示例：\n//任务优先级#define START_TASK_PRIO\t\t\t1//任务堆栈，实际为*4，是因为数据类型为uint32_t#define START_STACK_SIZE\t\t128//任务句柄，是任务堆栈栈顶TaskHandle_t StartTask_Handler;//任务函数声明void StartTask(void *pvParameters);\n（待补充。。。）\n任务删除动态任务删除\n函数名称：vTaskDelete\nvTaskDelete( TaskHandle_t xTaskToDelete )\n函数参数：  传入想要删除的任务的句柄，在传入参数的时候需要注意数据类型  \n\n函数作用： 如函数名称所示，是动态删除任务函数，与之相对还有一个静态删除任务函数\n\n注意： 如果是只执行一次的函数，在执行结束后一定要删除自己，释放内存\n\n\n示例：\nvTaskDelete(StartTask_Handler);\n\n（待补充。。。）\n任务挂起与恢复任务挂起\n函数名称：vTaskSuspendvoid vTaskSuspend( TaskHandle_t xTaskToSuspend)\n函数参数： 传入任务句柄，注意数据类型\n注意： 参数为NULL则是挂起自身，任务句柄可以通过xTaskGetHandle()根据任务名来获取\n\n任务恢复\n函数名称：vTaskResume()void vTaskResume( TaskHandle_t xTaskToResume)\n函数参数： 传入任务句柄，注意数据类型\n\n任务恢复FromISR\n函数名称：vTaskResumeFromISR()BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume)\n函数参数： 传入任务句柄，注意数据类型\n注意： 在中断服务函数中使用\n返回值pdTURE 要恢复的任务优先级高于或等于当前运行中的任务优先级（被打断的任务），也就是说出中断后要进行一次上下文切换pdFALSE 与上面的相反，不用上下文切换\n\n临界区保护临界区是介于各个任务之间公共区域，每个任务都可以访问其内部资源，这势必会导致资源竞争，所以在进入临界区时要进行临界区保护，关闭中断，保护内部完整性执行\n进入&#x2F;退出临界区\n函数名称：taskENTER_CRITICALtaskEXIT_CRITICAL\n\n函数参数：  NULL\n\n函数作用： 如函数名称所示执行taskENTER_CRITICAL，进入临界区，关中断，调度器依赖的systick定时器也被关闭，所以不会有任何其他高优先级任务打断。执行taskENTER_CRITICAL，退出临界区，开中断，调度恢复\n\n注意： 临界区因为不能调度任务，所以临界区内代码尽量简洁，执行越快越好，不影响系统的实时性\n\n\n示例： \ntaskENTER_CRITICAL();//读写变量，调用公共函数taskEXIT_CRITICAL();\n进入&#x2F;退出临界区FromISR\n函数名称：taskENTER_CRITICAL_FROM_ISR()taskEXIT_CRITICAL_FROM_ISR(x)本质是宏定义，在portmacro.h中定义\n\n函数参数：  NULL，x\n\n函数作用： 如函数名称所示在中断内执行taskENTER_CRITICAL_FROM_ISR()，进入临界区，关中断，保存当前BASEPRI寄存器值，写入configMAX_SYSCALL_INTERRUPT_PRIORITY，返回之前的BASEPRI寄存器值(手动保存中断屏蔽寄存器上下文)，退出临界区时要用到在中断内执行taskEXIT_CRITICAL_FROM_ISR()，退出临界区，读进入临界区返回的值，恢复之前的中断\n\n注意： 临界区因为不能调度任务，所以临界区内代码尽量简洁，执行越快越好，不影响系统的实时性\n\n\n示例： \nBASEPRI_value = taskENTER_CRITICAL_FROM_ISR();//读写变量，调用公共函数taskEXIT_CRITICAL(BASEPRI_value);\n\n延时相对延时vTaskDelay()参数 xTicksToDelay要延迟的时间说明 以调用此函数的时间为起点进行延时，每次延时的时间受逻辑运行影响，不稳定适用于简单的非周期任务，或者等待外部事件的固定时长\n绝对延时xTaskDelayUntil()参数pxPreviousWakeTime  第一次使用绝对延迟函数要将此参数在while循环外初始化\n\nTickType_t xLastWakeTime &#x3D; xTaskGetTickCount(); &#x2F;&#x2F; 正确不是 TickType_t xLastWakeTime;（未初始化） \n\nxTimeIncrement 任务延迟的时间节拍数，相对于pxPreviousWakeTime而言  \n说明绝对的周期执行，同时会阻塞任务，因为要保证绝对的周期。但是遇到高优先级和中断还是不能执行，不够函数会自动补偿时间情况一：如果100ms的延时，但是执行task1执行了20ms，那就将task1阻塞80ms来保证绝对延时情况二：如果100ms的延时，但是执行task1被抢占耗时10ms，那就将task1阻塞90ms来保证绝对延时  \n注意  \n\n绝对延时函数参数初始化在循环外\n不能在临界区调用，会导致任务无法切换\n任务处理时间不能超过延时时间，否则会跳过阻塞一直执行\n\n任务信息列表、队列中断中断管理开关中断\n函数名称 portENABLE_INTERRUPTS () portDISABLE_INTERRUPTS() 本质上是宏定义，在portmacro.h中定义\n注意 开中断就是向BASEPRI寄存器写入0，BASEPRI寄存器是一个可编程的中断屏蔽寄存器，写入0就是停止屏蔽也就是开，关中断就是写入configMAX_SYSCALL_INTERRUPT_PRIORITY,比如写入0x60来屏蔽优先级低于0x60的中断\n\n","categories":["FreeRTOS"],"tags":["STM32","笔记","FreeRTOS"]},{"title":"lua学习笔记","url":"/2025/06/22/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前言本文主要记录学习lua中一些易错，易混淆的点\n\n逻辑运算符and当两个值（无论是数值还是字符串）vala,valb进行and运算时运算式：vala and valb\n\nvala valb都为真（也就是不为nil或false）返回valb\nvala valb有一个为nil或false，返回vala示例当有三个变量local a = falselocal b = 0local c = 1\n分别进行and运算\n\n\n函数\n输出\n\n\n\nprint(b and c)\n1\n\n\nprint(a and b)\nfalse\n\n\nprint(b&gt;-1)\ntrue\n\n\nprint(b &gt; -1 and ‘yes’)\nyes\n\n\n\n\nor当两个值（无论是数值还是字符串）vala,valb进行or运算时运算式：vala or valb\n\nvala valb任意一个为nil或false，返回不为nil或false的真值\nvala valb都为真返回vala\nvala valb都为假返回valb示例当有四个变量local a = falselocal b = nillocal c = 0local d = 1\n分别进行or运算\n\n\n函数\n输出\n\n\n\nprint(a or c) print(b or c)\n0\n\n\nprint(d or a) print(d or b)\n1\n\n\nprint(c or d)\n0\n\n\nprint(b or c)\n1\n\n\nprint(a or b)\nnil\n\n\nprint(b or a)\nfalse\n\n\n\n\n短路求值形如print(b &gt; 10 and &quot;yes&quot; or &quot;no&quot;)假设b&gt;10是false，先和&quot;yes&quot;进行与运算，得false;再或运算，得&quot;no&quot;假设b&gt;10是true， 先和&quot;yes&quot;进行与运算，得&quot;yes&quot;;再或运算，得&quot;yes&quot;示例\nlocal b = 0print(b &gt; 10 and &quot;yes&quot; or &quot;no&quot;)print(b &gt; -1 and &#x27;yes&#x27; or &#x27;no&#x27;)输出noyes","categories":["lua"],"tags":["lua"]},{"title":"大学生想兼职赚钱就别指望还能学技术","url":"/2025/05/25/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%83%B3%E5%85%BC%E8%81%8C%E8%B5%9A%E9%92%B1%E5%B0%B1%E5%88%AB%E6%8C%87%E6%9C%9B%E8%BF%98%E8%83%BD%E5%AD%A6%E6%8A%80%E6%9C%AF/","content":"前言在5月21日，我正式结束了我在少儿编程培训班（以下简称机构）的兼职合计三次交作品——350+650+150&#x3D;1150，一共七个，历时三个月，记一下这次的经历。先说结论：大学生如果是为了赚钱就直接去赚钱最多的兼职，比如家教之类的，别想着去干自己专业相关的兼职还能赚钱，你的时间很宝贵，而且实际情况大概率不是你想的那样。\n\n\n第一次接触2月21日从群里看到有个机构需要人，负责制作嵌入式小作品和可能的授课，看到这个消息的我很开心，因为这个兼职和我的专业很契合，于是兴冲冲的联系学长。交了一个小简历，25号给了我机构负责人老师的微信（以下简称h老师）  \n2月25日加上微信，确认了面试时间在2月28日\n2月28日我去的前一天（2.27）没有再和h老师确认，于是被放鸽子了不过h老师说机构有别的老师在，让我上去还是去搞了一次不伦不类的“面试”。最后只确认了上班的时间和我主要的工作，给小学生做科创比赛作品。但其实后面就是有时间要做东西才去。\n\n一开始去早了，还和楼下保安聊了一会，最后会提到\n\n3月3日晚上和h老师在微信上确认了要干啥，用Arduino，这个h老师非常在意 “开源”，他给我一些关于比赛的资料和做的项目都是他说的 “开源”。后面会回收伏笔还有做项目需要的硬件我先自己买，后面他在补给我\n\ns所谓开源，点进去一看，有想法，代码——只有截图，图纸——只要图片，什么源文件都没有，然后 “开源”\n\n正式开工正式开工前正式和h老师见了一面，人很不错，说话也客气，没有因为我是学生就怎么样，这也是我虽然吐槽但是还是认真干我该干的活的原因之一确认下来一个项目起价150，根据难度上调价格。  \n3月11日开始做，去了机构，说是给我分配电脑（这个我一开始就问过他了，他给我说东西都有），其实就是机构授课的老师的笔记本，谁不在就把谁的给我，而且问的时候哪里的老师也不清楚具体情况。总的来说，我就是独立出来干活，和他们没有交集非常古老的联想商务本，没有电池，卡的批爆。根本没法用，磨蹭了一下午我就走了，后面就是带自己的电脑\n3月19日做完了两个，h老师来看完要给我结钱，因为是第一次搞，怎么要价我也不好开口，最后是两个一共350。七点钟从机构离开，我非常兴奋，因为是第一次赚到钱，脚步都是轻的。这段时间我每天下午三点到，六点多快七点走。\n\n在这里做项目，题目都是自己想，除了写程序，调硬件 还要负责制作外观，撰写文档 不过是给小学生做的，都比较简单，可是架不住它事多。我也是第一次学建模和3d打印\n\n中间还有段小插曲，h老师问我怎么使用3d打印机，其实我也是第一次接触啊，这种东西看看官方的使用文档不就知道了吗。于是晚上给我打视频让我教怎么用😶\n3月23日前面歇了几天之前提过，这里做东西题目要自己想，于是我到处查创客网站和科创比赛获奖名单想了三个毙了两个，因为是很常见的东西。h老师让我先做，于是我买了东西准备快递到了就去做，在等待的时候h老师告诉我：搜一下让生活更美好主题，找两个项目我:😓，我靠，这种宽泛的主题说了和没说有啥两样不过最后还是凑了俩上去，中间他和我说，做东西要往大做\n4月15日这三个做的差不多了，他告诉我再做一个停车场的，这次外观不是3d打印了，而是玻纤板切割组装，为了这个我又去学习开源的CAD软件libreCAD\n4月25日中间时间要组装前三个，还要调试第四个的硬软件，这天我才把图纸画出来，又正逢五一假期，等到切割的样板到，已经是5.5了\n5月5日我到机构一看样板（木板切割的）发现h老师把我的图层都合并在一起了，导致大部分地方都切错了，我也没说，大概组装了一下发现没大问题，再把小问题修改了一下。后面我问他使用玻纤板切割的话公差要留多少合适，答案是没有\n\n四月中旬的时候我说我暑假要去实习，h老师说本来是想让我暑假把我做的项目教给小朋友，然后再开一个使用3d打印机的课程。我表示暑假应该不留，他说到时候再说吧\n\n5月7日h老师问我五月是不是再做一些，我答应了，后面看来其实非常不应该，做完手头的就应该直接告辞，后面就是折磨。然后我又想了一个，还是买东西等快递\n\n这中间发生了很搞笑的事，我说了一个双人对战口算机的想法，他先是说这个年年有人做，当我说这个我搜了没见过和类似的东西后，他又改口：确实不常见，然后问我是不是 “开源” 的。我是这个是我自己想的，而且之前做的也都是只有想法，没有源码和外壳文件只能自己做。他回我——“👍，人才”\n\n5月13日玻纤板终于回来了，我装了两个下午，主要是我没加公差，比如一个插件那种就要留一点余量。然后和他说了后面的安排，明确了我五月干完就要走。然后给我结了钱，前三个各150，第四个200。结完钱和我说下次来做个小车，具体当面和我说\n5月19日和h老师见了一面，我表示如果小车太难搞我可能没时间做了，他表示理解然后晚上给我发了一个链接我当时看完都傻眼了，告诉他我做不了\n5月20日最后一个也做完了。把源码，外壳模型文件，手册啥的都整理好了。验收了一下，给我结完最后一个150，我就走了。走的时候还和楼下保安聊了几句，总结就是这里挣不到什么钱还浪费时间\n回顾与总结历时差不多三个月，我去每次去机构都是公交通勤，路上要倒车，来回一次4块。两点多从学校走，三点到机构，一般都是做到六点多才走，等回学校时都七八点了，有几次搞忘时间，等回学校已经九点了。在那里不能说啥也没学到，为了做东西还是自学了一点技能，不过和我浪费掉的时间比真不算什么。为了做机构的项目，有时候闲着还想想题目，还是有点折磨的。五月中我还准备暑假实习，其实已经有点晚了，而且我也没有自己的项目，简历上空空荡荡的哈哈哈，如果你要准备实习的话还是不要浪费时间，做一些能展现水平的东西，给小学生做的小东西没啥用。\n最后，钱也没挣到，时间浪费许多，虽然有一点收获，但总体是亏的\n文章标题其实是暴论，事实也可能没那么糟。\n","categories":["日常生活"],"tags":["日常生活","兼职","大学生","随想"]},{"title":"ARMGCC工具链下DMA接收不到数据的原因与解决方法","url":"/2025/08/03/ARMGCC%E5%B7%A5%E5%85%B7%E9%93%BE%E4%B8%8BDMA%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"&#x524D;&#x8A00;&#x5E73;&#x53F0;&#xFF1A;STM32H750vbt6&#x5C06;&#x539F;&#x6765;&#x5728;keil&#x4E0B;&#x914D;&#x7F6E;&#x7684;DCMI&#x6444;&#x50CF;&#x5934;&#x4F8B;&#x7A0B;&#xFF08;DMA1&#x642C;&#x6570;&#x636E;&#xFF0C;SPI&#x9A71;&#x52A8;&#x5C4F;&#x5E55;&#x5237;&#x65B0;&#xFF09;&#x8FC1;&#x79FB;&#x5230;arm-gnu-toolchain&#x540E;&#xFF0C;&#x51FA;&#x73B0;&#x4E86;DCMI&#x65E0;&#x6CD5;&#x4F20;&#x8F93;&#x6570;&#x636E;&#x7684;&#x95EE;&#x9898;&#x3002;&#x4E00;&#x5F00;&#x59CB;&#x4EE5;&#x4E3A;&#x662F;&#x5DE5;&#x5177;&#x94FE;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x4E00;&#x756A;&#x6392;&#x67E5;&#x540E;&#x53D1;&#x73B0;&#x662F;DCMI&#x914D;&#x7F6E;&#x7684;DMA&#x4F20;&#x8F93;&#x5931;&#x8D25;&#x3002;&#x7F51;&#x4E0A;&#x641C;&#x7D22;&#x540E;&#x53D1;&#x73B0;&#x6709;&#x7C7B;&#x4F3C;&#x95EE;&#x9898;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x56E0;&#x4E3A;DMA&#x65E0;&#x6CD5;&#x8BBF;&#x95EE;DTCM&#x533A;&#xFF0C;&#x800C;ST&#x7684;cubemx&#x81EA;&#x52A8;&#x751F;&#x6210;&#x7684;makefile&#x5DE5;&#x7A0B;&#x91CC;&#x81EA;&#x5E26;&#x7684; .ld &#x94FE;&#x63A5;&#x6587;&#x4EF6;&#x9ED8;&#x8BA4;&#x5C06;&#x7533;&#x8BF7;&#x7684;&#x9759;&#x6001;&#x6570;&#x7EC4;&#x90FD;&#x653E;&#x5728;DTCM&#x533A;&#x3002;\n/* Initialized data sections goes into RAM, load LMA copy after code */.data : {  . = ALIGN(4);  _sdata = .;        /* create a global symbol at data start */  *(.data)           /* .data sections */  *(.data*)          /* .data* sections */  . = ALIGN(4);  _edata = .;        /* define a global symbol at data end */} &gt;DTCMRAM AT&gt; FLASH/* Uninitialized data section */. = ALIGN(4);.bss :{  /* This is used by the startup in order to initialize the .bss secion */  _sbss = .;         /* define a global symbol at bss start */  __bss_start__ = _sbss;  *(.bss)  *(.bss*)  *(COMMON)  . = ALIGN(4);  _ebss = .;         /* define a global symbol at bss end */  __bss_end__ = _ebss;} &gt;DTCMRAM/* User_heap_stack section, used to check that there is enough RAM left */._user_heap_stack :{  . = ALIGN(8);  PROVIDE ( end = . );  PROVIDE ( _end = . );  . = . + _Min_Heap_Size;  . = . + _Min_Stack_Size;  . = ALIGN(8);} &gt;DTCMRAM\n\n&#x89E3;&#x51B3;&#x529E;&#x6CD5;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F00;cache&#xFF0C;&#x5C31;&#x76F4;&#x63A5;&#x4FEE;&#x6539; .ld &#x6587;&#x4EF6;&#xFF0C;&#x52A0;&#x5165;&#x81EA;&#x5B9A;&#x4E49;&#x6BB5;.AXI_RAM_D1 &#x6BB5;&#x540D;&#xFF0C; RAM_D1 &#x5728; .ld &#x6587;&#x4EF6;&#x5F00;&#x5934;\n/* &#x6307;&#x5411;RAM&#xFF0C;RAM_D1 (xrw)      : ORIGIN = 0x24000000, LENGTH = 512K *//* &#x9002;&#x7528;&#x4E8E;dma&#x8BBF;&#x95EE;&#x6570;&#x636E;&#xFF0C;dma1 2&#x90FD;&#x53EA;&#x80FD;&#x8BBF;&#x95EE;AXI SRAM&#xFF0C;&#x6240;&#x4EE5;&#x5B9A;&#x4E49;&#x7684;&#x6570;&#x7EC4;&#x4E4B;&#x7C7B;&#x7684;&#x6587;&#x4EF6;&#x5FC5;&#x987B;&#x6307;&#x5B9A;&#x5230;&#x6B64;&#x533A;&#x57DF; *//* (NOLOAD)&#x6307;&#x5B9A;&#x6B64;&#x6BB5;&#x4E0D;&#x9700;&#x8981;&#x521D;&#x59CB;&#x5316; */.AXI_RAM_D1(NOLOAD) :{  /* &#x56DB;&#x5B57;&#x8282;&#x5BF9;&#x9F50; */  /*. = ALIGN(4);  . = ALIGN(4);*/  *(.AXI_RAM_D1)} &gt;RAM_D1\n\n&#x5728;&#x4E00;&#x4E2A;&#x5408;&#x9002;&#x7684;&#x4F4D;&#x7F6E;&#x7F16;&#x5199;&#x4E00;&#x4E0B;&#x7684;&#x5185;&#x5BB9;&#x4F7F;&#x7528;&#x65B9;&#x5F0F;&#x5982;&#x4E0B;&#xFF0C;&#x8FD9;&#x91CC;&#x7684; .AXI_RAM_D1 &#x4E0E;&#x4E0A;&#x9762;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x6BB5;&#x5FC5;&#x987B;&#x8981;&#x4E00;&#x6837;&#xFF0C; __attribute__ &#x548C;&#x4E4B;&#x540E;&#x7684;&#x4E1C;&#x897F;&#x53EA;&#x8981;&#x653E;&#x5728; &#x4EE3;&#x7801;&#x7ED3;&#x675F;&#x7B26;&#x53F7;**; ** &#x4E4B;&#x524D;&#x5C31;&#x884C; __attribute__((section(&quot;.AXI_RAM_D1&quot;))) uint16_t pic0[160 * 120];\n&#x4E3A;&#x4EC0;&#x4E48;keil&#x4E0B;&#x5C31;&#x4E0D;&#x4F1A;&#x6709;&#x8FD9;&#x95EE;&#x9898;&#x5982;&#x56FE;&#x6240;&#x793A; IRAM1 &#x7684;&#x5730;&#x65B9;&#x6253;&#x52FE;&#x4E86;&#xFF0C;&#x5982;&#x679C;&#x53D6;&#x6D88;&#x52FE;&#x9009;&#xFF0C;&#x90A3;&#x4E48;keil&#x4E0B;&#x4E5F;&#x4E00;&#x6837;&#x65E0;&#x6CD5;&#x5411;&#x5206;&#x914D;&#x7684;&#x5728;DTCM&#x533A;&#x7684;&#x6570;&#x7EC4;&#x5199;&#x6570;&#x636E;\n\n&#x63A8;&#x8350;&#x4E00;&#x4E2A;&#x5B9E;&#x7528;&#x6587;&#x6863;LAT0816_STM32CubeIDE&#x5B9E;&#x7528;&#x6280;&#x5DE7;&#x4E4B;ld&#x94FE;&#x63A5;&#x6587;&#x4EF6;_v1.0\n","categories":["STM32"],"tags":["STM32","ARMGCC"]},{"title":"ESP32学习记录","url":"/2025/08/13/esp32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"&#x524D;&#x8A00;&#x4E3B;&#x8981;&#x8BB0;&#x5F55;&#x5728;&#x5B66;&#x4E60;esp32&#x4E2D;&#x9047;&#x5230;&#x7684;&#x95EE;&#x9898;&#x548C;&#x5916;&#x8BBE;&#x6A21;&#x5757;&#x9A71;&#x52A8;&#x5982;&#x4F55;&#x7F16;&#x5199;&#x5F3A;&#x70C8;&#x5EFA;&#x8BAE;&#x5728;&#x9605;&#x8BFB;&#x672C;&#x6587;&#x6863;&#x524D;&#x5148;&#x6253;&#x5F00;&#x5B98;&#x65B9;&#x624B;&#x518C;&#x5F88;&#x591A;&#x4EE3;&#x7801;&#x548C;&#x914D;&#x7F6E;&#x90FD;&#x662F;&#x53C2;&#x8003;&#x4E86;DuRuofu&#x5927;&#x4F6C;&#x7684;ESP32-Guide&#xFF0C;&#x53EF;&#x4EE5;&#x4F5C;&#x4E3A;&#x8865;&#x5145;&#x9605;&#x8BFB;\nnote:&#x7B14;&#x8005;&#x5BF9;esp32&#x7684;&#x529F;&#x80FD;&#x4E5F;&#x4EC5;&#x4EC5;&#x662F;&#x5904;&#x5728;&#x4F1A;&#x8C03;&#x7528;api&#x800C;&#x5DF2;&#xFF0C;&#x5B9E;&#x529B;&#x6709;&#x9650;&#x3002;&#x5BF9;&#x4E8E;&#x672C;&#x6587;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x9519;&#x8BEF;&#x8FD8;&#x8BF7;&#x89C1;&#x8C05;&#xFF0C;&#x5982;&#x679C;&#x60F3;&#x4EA4;&#x6D41;&#x53EF;&#x4EE5;&#x53D1;&#x90AE;&#x4EF6;(rzjzwd@outlook.com)&#x6216;&#x8005;&#x8BC4;&#x8BBA;&#x533A;&#x7559;&#x8A00;&#xFF08;&#x53EF;&#x80FD;&#x6CA1;&#x6709;&#x8BC4;&#x8BBA;&#x533A;&#xFF09;\n\n&#x5916;&#x8BBE;LEDPWM&#x8FD9;&#x4E2A;&#x5916;&#x8BBE;&#x53EF;&#x4EE5;&#x7528;&#x4E8E;&#x63A7;&#x5236;LED&#x547C;&#x5438;&#x706F;&#xFF0C;&#x4F46;&#x662F;&#x672C;&#x6587;&#x6863;&#x4E2D;&#x4E3B;&#x8981;&#x7528;&#x6765;&#x5BF9;&#x8235;&#x673A;&#x8FDB;&#x884C;&#x7B80;&#x5355;&#x7684;&#x63A7;&#x5236;&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;&#x5728;&quot;driver/ledc.h&quot;&#x4E2D;\n&#x53C2;&#x6570;&#x914D;&#x7F6E;\n&#x521D;&#x59CB;&#x5316;&#x5B9A;&#x65F6;&#x5668;ledc_timer_config_t timerCig = {    .speed_mode = LEDC_LOW_SPEED_MODE,      //&#x8BBE;&#x7F6E;&#x901F;&#x5EA6;    .duty_resolution = LEDC_TIMER_13_BIT,   //&#x7CBE;&#x5EA6;    .timer_num = LEDC_TIMER_0,              //&#x5B9A;&#x65F6;&#x5668;0    .freq_hz = 50,                          //&#x9891;&#x7387;50hz    .clk_cfg = LEDC_AUTO_CLK                //&#x65F6;&#x949F;&#x6E90;&#x8BBE;&#x7F6E;};ledc_timer_config(&amp;timerCig);          //&#x8BBE;&#x7F6E;\n&#x914D;&#x7F6E;&#x901A;&#x9053;ledc_channel_config_t channelCfg = {                        .gpio_num = gpioPin,                //gpio&#x53E3;            .speed_mode = LEDC_LOW_SPEED_MODE,  //&#x901F;&#x5EA6;            //&#x901A;&#x9053;&#x8BBE;&#x7F6E;&#xFF0C;&#x4E00;&#x4E2A;&#x5B9A;&#x65F6;&#x5668;&#x6709;&#x516B;&#x4E2A;&#x9AD8;&#x901F;&#x901A;&#x9053;&#x548C;&#x516B;&#x4E2A;&#x4F4E;&#x901F;&#x901A;&#x9053;            .channel = i,                                   .timer_sel = LEDC_TIMER_0,          //&#x8BBE;&#x7F6E;&#x5B9A;&#x65F6;&#x5668;            .duty = 0        };ledc_channel_config(&amp;channelCfg);       //&#x8BBE;&#x7F6E;\n&#x8BBE;&#x7F6E;&#x5360;&#x7A7A;&#x6BD4;&#x51FD;&#x6570;ledc_set_duty(LEDC_LOW_SPEED_MODE, ch, duty);ledc_update_duty(LEDC_LOW_SPEED_MODE, ch);\nch&#x662F;&#x901A;&#x9053;&#xFF0C;&#x6BCF;&#x4E2A;&#x901A;&#x9053;&#x5BF9;&#x5E94;&#x4E00;&#x4E2A;pwm&#x8F93;&#x51FA;io,duty&#x5C31;&#x662F;&#x5360;&#x7A7A;&#x6BD4;\n\n&#x8235;&#x673A;&#x63A7;&#x5236;&#x5B9E;&#x6218;//servo_driver.h#ifndef _SERVO_DRIVER_H_#define _SERVO_DRIVER_H_#include &lt;stdint.h&gt;#define SERVO_NUMS (8)#ifdef __cplusplusextern &quot;C&quot; {#endif typedef struct{    uint8_t gpioPin;     float minAngleDeg;            float maxAngleDeg;            uint16_t minPulseOfUs;    uint16_t maxPulseOfUs;} servoConfig_t;//&#x9519;&#x8BEF;&#x7801;typedef enum {    SERVO_OK = 0,    SERVO_ERR_INVALID_ID,   //&#x4E0D;&#x5B58;&#x5728;&#x7684;&#x8235;&#x673A;&#x53F7;    SERVO_ERR_ANGLE_OUT_OF_RANGE    //&#x89D2;&#x5EA6;&#x8D85;&#x8FC7;&#x9608;&#x503C;} servoErrorCode_t;/** * @brief &#x521D;&#x59CB;&#x5316;&#x8235;&#x673A; * @param servoConfig &#x8235;&#x673A;&#x53C2;&#x6570; * @param servoNums &#x8235;&#x673A;&#x6570;&#x91CF; */void servo_init(const servoConfig_t *Config, uint8_t servoNums);/** * @brief &#x8BBE;&#x7F6E;&#x5355;&#x4E2A;&#x8235;&#x673A;&#x89D2;&#x5EA6; * @param servoId &#x8235;&#x673A;&#x53F7; * @param angleDeg &#x89D2;&#x5EA6; */int servo_set_angle(uint8_t servoId, float angleDeg);/** * @brief &#x6279;&#x91CF;&#x8BBE;&#x7F6E;&#x8235;&#x673A;&#x89D2;&#x5EA6; * @param angles &#x89D2;&#x5EA6; * @param servoNums &#x8235;&#x673A;&#x6570; */void servo_set_all_angles(const float* angles, uint8_t servoNums);#ifdef __cplusplus}#endif #endif\n\n//servo_driver.c#include &quot;servo_driver.h&quot;#include &quot;driver/ledc.h&quot;#include &quot;esp_log.h&quot;#define TAG &quot;SERVO_DRIVE&quot;typedef struct {    const servoConfig_t *servoConfigs;    uint8_t servoNums;    ledc_channel_config_t *servoChannels;} servoDriverCtx_t;static servoDriverCtx_t servoDriverCtx;/** * @brief &#x89D2;&#x5EA6;&#x8F6C;&#x5360;&#x7A7A;&#x6BD4; * @param servoId &#x8235;&#x673A;&#x53F7; * @param angleDeg &#x89D2;&#x5EA6; * @return &#x5360;&#x7A7A;&#x6BD4; */static uint32_t angle2duty(uint8_t servoId, float angleDeg){    //&#x53D6;&#x8235;&#x673A;&#x53F7;&#x5BF9;&#x5E94;&#x53C2;&#x6570;&#x7684;&#x6307;&#x9488;&#x7ED9;a2dConfig    const servoConfig_t *a2dConfig = &amp;servoDriverCtx.servoConfigs[servoId];    //&#x89D2;&#x5EA6;&#x9650;&#x5236;    if(angleDeg &lt; a2dConfig-&gt;minAngleDeg){        angleDeg = a2dConfig-&gt;minAngleDeg;    }else if(angleDeg &gt;a2dConfig-&gt;maxAngleDeg){        angleDeg = a2dConfig-&gt;maxAngleDeg;    }else        angleDeg = angleDeg;    //&#x8BA1;&#x7B97;&#x8109;&#x51B2;    float pluseOfUs = a2dConfig-&gt;minPulseOfUs +                      (angleDeg - a2dConfig-&gt;minAngleDeg) *                          (a2dConfig-&gt;maxPulseOfUs - a2dConfig-&gt;minPulseOfUs) /                          (a2dConfig-&gt;maxAngleDeg - a2dConfig-&gt;minAngleDeg);    //pluseOfUs * 1e-6,&#x628A;us&#x8F6C;&#x6362;&#x4E3A;s    //&#x5B9A;&#x65F6;&#x5668;&#x603B;&#x8BA1;&#x6570;&#x503C;(2^13) * &#x4FE1;&#x53F7;&#x9891;&#x7387;&#xFF08;50hz&#xFF09;    //&#x4EE5;&#x4E0A;&#x4E24;&#x4E2A;&#x76F8;&#x4E58;&#x5F97;&#x5360;&#x7A7A;&#x6BD4;    return (uint32_t)((pluseOfUs * 1e-6) * ((1 &lt;&lt; LEDC_TIMER_13_BIT) - 1) * 50);}void servo_init (const servoConfig_t *Config, uint8_t servoNums){    servoDriverCtx.servoConfigs = Config;    servoDriverCtx.servoNums = servoNums;    //&#x521D;&#x59CB;&#x5316;LEDC&#x5B9A;&#x65F6;&#x5668;    ledc_timer_config_t servoTimerCig = {        .speed_mode = LEDC_LOW_SPEED_MODE,        .duty_resolution = LEDC_TIMER_13_BIT,        .timer_num = LEDC_TIMER_0,        .freq_hz = 50,        .clk_cfg = LEDC_AUTO_CLK    };    ledc_timer_config(&amp;servoTimerCig);    //&#x914D;&#x7F6E;&#x901A;&#x9053;    servoDriverCtx.servoChannels = malloc(servoNums * sizeof(ledc_channel_config_t));    //&#x6309;&#x8235;&#x673A;&#x6570;&#x91CF;&#xFF0C;&#x901A;&#x9053;&#x7ED3;&#x6784;&#x4F53;&#x5927;&#x5C0F;&#x7533;&#x8BF7;&#x5185;&#x5B58;    for (int i = 0; i &lt; servoNums; i++){        //&#x6309;&#x6570;&#x7EC4;&#x8BBF;&#x95EE;&#x65B9;&#x5F0F;&#x5199;&#x5165;        servoDriverCtx.servoChannels[i] = (ledc_channel_config_t){            .gpio_num = Config[i].gpioPin,            .speed_mode = LEDC_LOW_SPEED_MODE,            .channel = i,            .timer_sel = LEDC_TIMER_0,            .duty = 0        };        ledc_channel_config(&amp;servoDriverCtx.servoChannels[i]);    }}int servo_set_angle (uint8_t servoId, float angleDeg){    static servoErrorCode_t servoErrorCode;        //&#x68C0;&#x67E5;&#x8235;&#x673A;&#x53F7;&#x5408;&#x6CD5;&#x6027;    if(servoId &gt;=servoDriverCtx.servoNums){        ESP_LOGE(TAG, &quot;Invalid servo ID: %d&quot;, servoId);        servoErrorCode = SERVO_ERR_INVALID_ID;        return servoErrorCode;    }    //&#x68C0;&#x67E5;&#x89D2;&#x5EA6;&#x5408;&#x6CD5;&#x6027;    const servoConfig_t *Config = &amp;servoDriverCtx.servoConfigs[servoId];    if(angleDeg &lt; Config-&gt;minAngleDeg || angleDeg &gt; Config-&gt;maxAngleDeg){        ESP_LOGE(TAG, &quot;Servo %d angle %.1f out of range [%.1f, %.1f]&quot;,                 servoId, angleDeg, Config-&gt;minAngleDeg, Config-&gt;maxAngleDeg);        servoErrorCode = SERVO_ERR_ANGLE_OUT_OF_RANGE;        return servoErrorCode;    }    uint32_t duty = angle2duty(servoId, angleDeg);    ledc_set_duty(LEDC_LOW_SPEED_MODE, servoId, duty);    ledc_update_duty(LEDC_LOW_SPEED_MODE, servoId);    servoErrorCode = SERVO_OK;    return servoErrorCode;}void servo_set_all_angles(const float* angles, uint8_t servoNums){    for (int i = 0; i &lt; servoNums; i++){        servo_set_angle(i, angles[i]);    }    }\n&#x5B9E;&#x9645;&#x5E94;&#x7528;&#xFF0C;&#x4EE5;&#x540C;&#x65F6;&#x63A7;&#x5236;&#x516B;&#x4E2A;&#x8235;&#x673A;&#x4E3A;&#x4F8B;\n//&#x6570;&#x7EC4;&#x7ED3;&#x6784;&#x4F53;&#x6210;&#x5458;&#xFF0C;gpio&#xFF0C;&#x6700;&#x5C0F;&#x89D2;&#x5EA6;&#xFF0C;&#x6700;&#x5927;&#x89D2;&#x5EA6;&#xFF0C;&#x6700;&#x5C0F;&#x8109;&#x51B2;&#xFF0C;&#x6700;&#x5927;&#x8109;&#x51B2;servoConfig_t servoConfigse[SERVO_NUMS] = {    {18, 0, 90, 500, 2500},    {19, 0, 180, 500, 2500},    {16, 90, 180, 500, 2500},    {17, 0, 180, 500, 2500},    {26, 0, 90, 500, 2500},    {27, 0, 180, 500, 2500},    {33, 90, 180, 500, 2500},    {32, 0, 180, 500, 2500},};servo_init(servoConfigse, SERVO_NUMS);\n\nUART esp32&#x4E2D;&#x7684;&#x4E32;&#x53E3;&#x6709;&#x4E09;&#x4E2A;&#xFF0C;UART0&#x662F;&#x4F5C;&#x4E3A;&#x4E0B;&#x8F7D;&#xFF0C;&#x8C03;&#x8BD5;&#x4E32;&#x53E3;&#x4F7F;&#x7528;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x6B21;&#x7528;&#x7684;&#x662F;&#x4E32;&#x53E3;2&#x3002;&#x76F8;&#x5173;&#x914D;&#x7F6E;&#x51FD;&#x6570;ESP&#x5B98;&#x65B9;&#x5DF2;&#x7ECF;&#x63D0;&#x4F9B;&#x4E86;&#xFF0C;&#x4E0B;&#x9762;&#x7684;&#x6587;&#x4EF6;&#x5F53;&#x4E2D;\n#include &quot;driver/uart.h&quot;\n\n&#x53C2;&#x6570;&#x8BBE;&#x7F6E;&#x9A71;&#x52A8;&#x5206;&#x4E3A;&#x4E09;&#x6B65;\n\nUART&#x9A71;&#x52A8;&#x6CE8;&#x518C;uart_driver_install(uart_port_t uart_num,   //&#x4E32;&#x53E3;&#x53F7;                    int rx_buffer_size,     //&#x63A5;&#x6536;&#x7AEF;&#x7F13;&#x51B2;&#x533A;                    int tx_buffer_size,     //&#x53D1;&#x9001;&#x7AEF;&#x7F13;&#x51B2;&#x533A;                    int event_queue_size,   //&#x961F;&#x5217;&#x5927;&#x5C0F;&#xFF0C;&#x6CA1;&#x6709;&#x5199;0                    QueueHandle_t *uart_queue, //&#x961F;&#x5217;&#x53E5;&#x67C4;&#xFF0C;&#x6CA1;&#x6709;&#x5199;NULL                    int intr_alloc_flags    //&#x4E2D;&#x65AD;&#x6807;&#x5FD7;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x5C31;0                    )   \n&#x793A;&#x4F8B;&#xFF1A;uart_driver_install(2, 1024*2, 0, 0, NULL, 0)\nUART&#x53C2;&#x6570;&#x8BBE;&#x7F6E;uart_param_config(uart_port_t uart_num,         //&#x4E32;&#x53E3;&#x53F7;                const uart_config_t *uart_config//&#x53C2;&#x6570;&#x7ED3;&#x6784;&#x4F53;&#x6307;&#x9488;                )\n\n&#x53C2;&#x6570;&#x7ED3;&#x6784;&#x4F53;&#xFF1A;\nuart_config_t uartConfig = {    .baud_rate = 115200,                    //&#x6CE2;&#x7279;&#x7387;    .data_bits = UART_DATA_8_BITS,          //&#x516B;&#x4F4D;&#x6570;&#x636E;&#x4F4D;    .parity = UART_PARITY_DISABLE,          //&#x6821;&#x9A8C;&#x4F4D;    .stop_bits = UART_STOP_BITS_1,          //&#x505C;&#x6B62;&#x4F4D;    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE   //&#x786C;&#x4EF6;&#x6D41;&#x63A7;&#x5236;};\n\n\nUART&#x5F15;&#x811A;&#x8BBE;&#x7F6E;uart_set_pin(uart_port_t uart_num,      //&#x4E32;&#x53E3;&#x53F7;            int tx_io_num,              //tx&#x5F15;&#x811A;&#xFF08;17&#xFF09;            int rx_io_num,              //rx&#x5F15;&#x811A;&#xFF08;16&#xFF09;            int rts_io_num,             //rts&#x5F15;&#x811A; &#x786C;&#x4EF6;&#x6D41;&#x63A7;&#x811A;            int cts_io_num              //cts&#x5F15;&#x811A; &#x786C;&#x4EF6;&#x6D41;&#x63A7;&#x811A;            )\n&#x793A;&#x4F8B;:&#x5982;&#x679C;&#x4E0D;&#x542F;&#x7528;&#x786C;&#x4EF6;&#x6D41;&#x63A7;&#xFF0C;rts cts&#x53C2;&#x6570;&#x53EF;&#x4EE5;&#x4F20;&#x5165;UART_PIN_NO_CHANGEuart_set_pin(2, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE)\n\n\n&#x5B9E;&#x6218;\n&#x521B;&#x5EFA;&#x7EC4;&#x4EF6;&#x8FD9;&#x91CC;&#x91C7;&#x7528;&#x81EA;&#x5B9A;&#x4E49;&#x7EC4;&#x4EF6;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x5728;ESP_IDF&#x4E2D;&#x4F7F;&#x7528;&#x547D;&#x4EE4;idf.py -C components create-component uart_driver\nuart_driver&#x90E8;&#x5206;&#x53EF;&#x4EE5;&#x81EA;&#x5B9A;&#x4E49;&#x540D;&#x79F0;\n\n&#x5728;components/uart_driver&#x6587;&#x4EF6;&#x5939;&#x4E0B;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x81EA;&#x52A8;&#x521B;&#x5EFA;&#x7684;.c .h&#x6587;&#x4EF6;\n\n&#x5F15;&#x5165;&quot;driver/uart.h&quot;&#x53CA;&#x4FEE;&#x6539;CMakeLists.txt&#x6587;&#x4EF6;components/uart_driver/CMakeLists.txt&#xFF0C;&#x6253;&#x5F00;&#x8FD9;&#x4E2A;txt&#x6587;&#x4EF6;,&#x5199;&#x5165;&#x4EE5;&#x4E0B;&#x5185;&#x5BB9;\nidf_component_register(SRCS &quot;uart_driver.c&quot;                    INCLUDE_DIRS &quot;include&quot;                    REQUIRES &quot;driver&quot;)\nREQUIRES &quot;driver&quot;&#x90E8;&#x5206;&#x5C31;&#x662F;&#x5728;&#x544A;&#x8BC9;cmake&#x5305;&#x542B;&#x4E86;driver&#x6587;&#x4EF6;&#x5939;&#x7684;&#x5185;&#x5BB9;&#xFF08;&#x6211;&#x731C;&#x7684;&#xFF09;\n\n&#x521D;&#x59CB;&#x5316;&#x51FD;&#x6570;&#x4EE5;&#x4E0B;&#x7684;&#x5185;&#x5BB9;&#x53EA;&#x662F;&#x6458;&#x53D6;&#x4E86;&#x6587;&#x4EF6;&#x90E8;&#x5206;&#x5185;&#x5BB9;&#xFF0C;&#x5177;&#x4F53;&#x60C5;&#x51B5;&#x6309;&#x6240;&#x9700;&#x914D;&#x7F6E;\n\n\n//uart_driver.htypedef struct {    int bandRate;   //&#x6CE2;&#x7279;&#x7387;    int uartNum;    //&#x4E32;&#x53E3;&#x53F7;    int txPin;    int rxPin;}uartPin_t;         //&#x8FD9;&#x91CC;&#x6211;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x7BA1;&#x7406;&#x81EA;&#x5B9A;&#x4E49;&#x6570;&#x636E;&#xFF0C;                    //&#x5176;&#x4ED6;&#x53C2;&#x6570;&#x4E00;&#x822C;&#x4E0D;&#x7528;&#x6539;&#x53D8;/** * @brief &#x521D;&#x59CB;&#x5316;&#x4E32;&#x53E3; * @param uartInitConfig &#x521D;&#x59CB;&#x5316;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4F53;&#xFF0C;&#x6CE2;&#x7279;&#x7387;&#xFF0C;&#x4E32;&#x53E3;&#x53F7;&#xFF0C;tx&#xFF0C;rx&#x5F15;&#x811A; */void uart_Init(uartPin_t *uartInitConfig);\n&#x51FD;&#x6570;&#x5B9E;&#x73B0;\n//uart_driver.cconst int uartBufferSize = (1024 * 2);void uart_Init(uartPin_t *uartInitConfig){    uartPin_t *uartInitPin = uartInitConfig;    uart_config_t uartConfig = {        .baud_rate = uartInitPin-&gt;bandRate,        .data_bits = UART_DATA_8_BITS,        .parity = UART_PARITY_DISABLE,        .stop_bits = UART_STOP_BITS_1,        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE    };    ESP_ERROR_CHECK(uart_driver_install(uartInitPin-&gt;uartNum, uartBufferSize, 0, 0, NULL, 0));    ESP_ERROR_CHECK(uart_param_config(uartInitPin-&gt;uartNum, &amp;uartConfig));    ESP_ERROR_CHECK(uart_set_pin(uartInitPin-&gt;uartNum, uartInitPin-&gt;txPin, uartInitPin-&gt;rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));}\nESP_ERROR_CHECK()&#x51FD;&#x6570;&#x8981;&#x5305;&#x542B;#include &quot;esp_err.h&quot;&#xFF0C;&#x7528;&#x4E8E;&#x68C0;&#x67E5;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x503C;&#xFF0C;&#x5982;&#x679C;&#x51FA;&#x9519;&#x7A0B;&#x5E8F;&#x4F1A;&#x76F4;&#x63A5;&#x505C;&#x6B62;\n\n&#x6D4B;&#x8BD5;&#x51FD;&#x6570;&#x4E3B;&#x673A;&#x53D1;&#x4EC0;&#x4E48;&#xFF0C;esp&#x518D;&#x53D1;&#x56DE;&#x6765;void uart_send_recive_test(void *pvParameters){    const char *testLen = &quot;Please send massage\\n&quot;;    uint8_t rxData[10];                             //&#x63A5;&#x6536;&#x6570;&#x7EC4;&#x5927;&#x5C0F;    uart_write_bytes(2, testLen, strlen(testLen));    while(1){        int length = 0;        ESP_ERROR_CHECK(uart_get_buffered_data_len(2, (size_t*)&amp;length));        if(length &gt; 0){            int readLength = uart_read_bytes(2, &amp;rxData, length, pdMS_TO_TICKS(100));            if(readLength &gt; 0){                uart_write_bytes(2, rxData, 10);            }        }        vTaskDelay(10);    }}\n\n&#x7247;&#x5185;&#x529F;&#x80FD;WIFI&#x8FD9;&#x8282;&#x53EA;&#x4ECB;&#x7ECD;WiFi&#x914D;&#x7F6E;&#xFF0C;&#x5982;&#x679C;&#x9700;&#x8981;&#x4F7F;&#x7528;WiFi&#x914D;&#x7F51;&#xFF0C;&#x8BF7;&#x8F6C;&#x5230;&#x914D;&#x7F51;&#x7684;&#x7AE0;&#x8282;\n&#x53C2;&#x6570;&#x8BBE;&#x7F6E;\n&#x521D;&#x59CB;&#x5316;TCP/IP&#x534F;&#x8BAE;&#x6808;ESP_ERROR_CHECK(esp_netif_init());ESP_ERROR_CHECK&#x7528;&#x4E8E;&#x68C0;&#x67E5;\n&#x914D;&#x7F6E;WIFI&#x53C2;&#x6570;&#x6A21;&#x5F0F;&#x53C2;&#x6570;esp_netif_create_default_wifi_sta();&#x7528;&#x4E8E;&#x8BBE;&#x7F6E;sta&#x6A21;&#x5F0F;&#x7684;&#x9ED8;&#x8BA4;&#x53C2;&#x6570;&#x53C2;&#x6570;&#x914D;&#x7F6E;:&#x9ED8;&#x8BA4;&#x53C2;&#x6570;wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();wifi_init_config_t&#x7ED3;&#x6784;&#x4F53;&#x7C7B;&#x578B;WIFI_INIT_CONFIG_DEFAULT()&#x8FD4;&#x56DE;&#x9ED8;&#x8BA4;&#x53C2;&#x6570;&#x53C2;&#x6570;&#x914D;&#x7F6E;&#xFF1A;&#x81EA;&#x5B9A;&#x4E49;&#x53C2;&#x6570;wifi_config_t wifi_config = {        .sta = {            .ssid = &quot;yourssid&quot;,            .password = &quot;yourpassword&quot;,        },}\n&#x8BBE;&#x7F6E;&#x53C2;&#x6570;ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));//&#x8BBE;&#x7F6E;sta&#x6A21;&#x5F0F;//&#x8BBE;&#x7F6E;&#x53C2;&#x6570;ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, wifi_config));\nwifi_&#x542F;&#x52A8;ESP_ERROR_CHECK(esp_wifi_start());\n\nwifi&#x4E8B;&#x4EF6;\n&#x8BBE;&#x7F6E;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;ESP_ERROR_CHECK(esp_event_loop_create_default());\n&#x58F0;&#x660E;&#x4E8B;&#x4EF6;&#x53E5;&#x67C4;&#x793A;&#x4F8B;&#xFF1A;esp_event_handler_instance_t instance_any_id;idesp_event_handler_instance_t instance_got_ip;&#x83B7;&#x53D6;ip\n&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,//&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;                                        ESP_EVENT_ANY_ID,//&#x4E8B;&#x4EF6;id                                        &amp;wifi_event_handler,//&#x5904;&#x7406;&#x51FD;&#x6570;                                        NULL,//&#x5904;&#x7406;&#x51FD;&#x6570;&#x53C2;&#x6570;                                        &amp;instance_any_id//&#x5B9E;&#x4F8B;&#x5316;&#x53C2;&#x6570;                                        ));ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,                                        IP_EVENT_STA_GOT_IP,                                        &amp;wifi_event_handler,                                        NULL,                                        &amp;instance_got_ip                                        ));\n&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;&#x540E;&#x8981;&#x5B9A;&#x4E49;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;\n&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;&#x8BF4;&#x660E;&#x5982;&#x679C;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;&#x662F;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x8981;&#x6839;&#x636E;&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x60C5;&#x51B5;&#x6765;&#x901A;&#x77E5;&#x54EA;&#x4E00;&#x4E2A;&#x4E8B;&#x4EF6;&#x54CD;&#x5E94;&#xFF0C;&#x53EF;&#x4EE5;&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;&#x6765;&#x7BA1;&#x7406;&#x4E0D;&#x540C;&#x7684;&#x4E8B;&#x4EF6;&#x3002;&#x5177;&#x4F53;&#x5982;&#x4F55;&#x505A;&#x5728;&#x4E0B;&#x8FF0;&#x7684;&#x5185;&#x5BB9;&#x4E2D;\n\n&#x5B9E;&#x6218;//wifi_driver.h#ifndef _WIFI_DRIVER_H#define _WIFI_DRIVER_H#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/semphr.h&quot;typedef struct {    char ssid[32];    char password[64];    // char ip[16];    // char gw[16];    // char netmask[16];} wifi_info_config_t;extern char sta_ip[16];extern bool sta_connected;extern bool ap_active;extern SemaphoreHandle_t wifiStaConnectedHandle;#ifdef __cplusplusextern &quot;C&quot; {#endif    void wifi_init(void);    void wifi_config_ap(void);    void wifi_config_sta(wifi_info_config_t *config);    bool wifi_has_saved_config(void);    void wifi_save_config(wifi_info_config_t *config);    void wifi_load_config(wifi_info_config_t *config);    void wifi_clear_config(void);    void wifi_close_ap(void);#ifdef _cplusplus}#endif#endif\n//wifi_driver.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;wifi_driver.h&quot;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/event_groups.h&quot;#include &quot;esp_wifi.h&quot;#include &quot;esp_event.h&quot;#include &quot;esp_log.h&quot;#include &quot;esp_err.h&quot;#define WIFI_CONNECTED_BIT BIT0 //&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x4E8B;&#x4EF6;&#x8BBE;&#x7F6E;&#x5728;&#x4E8B;&#x4EF6;&#x7EC4;0&#x4F4D;&#xFF0C;esp32&#x4E2D;&#x5BF9;&#x6240;&#x6709;&#x4F4D;&#x90FD;&#x6709;&#x5B9A;&#x4E49;#define WIFI_FAIL_BIT      BIT1 //&#x8FDE;&#x63A5;&#x5931;&#x8D25;#define EXAMPLE_ESP_MAXIMUM_RETRY 5 //&#x6700;&#x591A;&#x91CD;&#x8BD5;&#x6B21;&#x6570;static const char *TAG = &quot;wifi station&quot;;static int s_retry_num = 0;static EventGroupHandle_t s_wifi_event_group;   //&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;&#x53E5;&#x67C4;static void wifi_event_handler(void* arg, esp_event_base_t event_base,                                int32_t event_id, void* event_data){    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {//wifi&#x4E8B;&#x4EF6;        esp_wifi_connect();    } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {        if (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) {//&#x5C1D;&#x8BD5;5&#x6B21;&#x8FDE;&#x63A5;&#x4E0D;&#x4E0A;&#x5C31;&#x6253;&#x5370;&#x9519;&#x8BEF;&#x4FE1;&#x606F;            esp_wifi_connect();            s_retry_num++;            ESP_LOGI(TAG, &quot;retry to connect to the AP&quot;);        } else {            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);//&#x7ED9;wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x5931;&#x8D25;&#x4F4D;&#x7F6E;&#x4F4D;        }        ESP_LOGI(TAG,&quot;connect to the AP fail&quot;);    } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {//ip&#x4E8B;&#x4EF6;        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;        ESP_LOGI(TAG, &quot;got ip:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));        s_retry_num = 0;        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);//&#x7ED9;wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x5DF2;&#x8FDE;&#x63A5;&#x4F4D;&#x7F6E;&#x4F4D;    }}void wifi_init_sta(const char *ssid, const char *password){    s_wifi_event_group = xEventGroupCreate();       //&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;        //&#x521D;&#x59CB;&#x5316;TCP/IP&#x534F;&#x8BAE;&#x6808;    ESP_ERROR_CHECK(esp_netif_init());    //&#x521B;&#x5EFA;&#x9ED8;&#x8BA4;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;    ESP_ERROR_CHECK(esp_event_loop_create_default());     esp_netif_t *sta_netif = esp_netif_create_default_wifi_sta();    assert(sta_netif);    // WiFi&#x914D;&#x7F6E;    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));      esp_event_handler_instance_t instance_any_id;    esp_event_handler_instance_t instance_got_ip;    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,                                                        ESP_EVENT_ANY_ID,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_any_id));    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,                                                        IP_EVENT_STA_GOT_IP,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_got_ip));    wifi_config_t wifi_config = {        .sta = {            .ssid = &quot;&quot;,            .password = &quot;&quot;,            /* Authmode threshold resets to WPA2 as default if password matches WPA2 standards (password len =&gt; 8).             * If you want to connect the device to deprecated WEP/WPA networks, Please set the threshold value             * to WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK and set the password with length and format matching to             * WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK standards.             */            // .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,            // .sae_pwe_h2e = ESP_WIFI_SAE_MODE,            // .sae_h2e_identifier = EXAMPLE_H2E_IDENTIFIER,        },    };    strncpy((char*)wifi_config.sta.ssid, ssid, sizeof(wifi_config.sta.ssid));    strncpy((char*)wifi_config.sta.password, password, sizeof(wifi_config.sta.password));    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &amp;wifi_config));    ESP_ERROR_CHECK(esp_wifi_start());          ESP_LOGI(TAG, &quot;wifi_init_sta finished.&quot;);    /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */    //&#x7B49;&#x5F85;&#x8FDE;&#x63A5;&#x4E8B;&#x4EF6;&#x5EFA;&#x7ACB;&#x8D77;&#x6765;&#xFF0C;&#x6216;&#x8005;&#x5C1D;&#x8BD5;&#x6700;&#x5927;&#x8FDE;&#x63A5;&#x6570;&#x540E;&#x5931;&#x8D25;&#xFF0C;&#x7531;wifi_event_handler()&#x8BBE;&#x7F6E;&#xFF0C;    //&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x6CE8;&#x91CA;    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,            pdFALSE,            pdFALSE,            portMAX_DELAY);    /* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually     * happened. */    //&#x6839;&#x636E;&#x4E8B;&#x4EF6;&#x4F4D;&#x6765;&#x6D4B;&#x8BD5;&#x4E8B;&#x4EF6;&#x662F;&#x5426;&#x53D1;&#x751F;    if (bits &amp; WIFI_CONNECTED_BIT) {        ESP_LOGI(TAG, &quot;connected to ap SSID:%s password:%s&quot;,ssid, password);    } else if (bits &amp; WIFI_FAIL_BIT) {        ESP_LOGI(TAG, &quot;Failed to connect to SSID:%s, password:%s&quot;,ssid, password);    } else {        ESP_LOGE(TAG, &quot;UNEXPECTED EVENT&quot;);    }}\n\n\n\nAP+STA&#x6A21;&#x5F0F;&#x914D;&#x7F51;&#x672C;&#x8282;&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x63D0;&#x4F9B;&#x4E00;&#x79CD;AP+STA&#x6A21;&#x5F0F;&#x7684;&#x7B80;&#x5355;&#x914D;&#x7F51;&#x65B9;&#x6CD5;&#xFF0C;&#x8FD8;&#x5904;&#x4E8E;&#x6D4B;&#x8BD5;&#x9636;&#x6BB5;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x4E86;&#x89E3;http&#x670D;&#x52A1;&#x5668;&#xFF0C;&#x8BF7;&#x5728;&#x9605;&#x8BFB;&#x672C;&#x8282;&#x524D;&#x9605;&#x8BFB;HTTP&#x670D;&#x52A1;&#x5668;&#x7684;&#x90E8;&#x5206;&#x539F;&#x7406;&#xFF1A;\n\nesp32&#x5F00;&#x542F;STA+AP&#x6A21;&#x5F0F;&#xFF0C;&#x624B;&#x673A;&#x8FDE;&#x63A5;esp32&#x70ED;&#x70B9;&#xFF0C;&#x70ED;&#x70B9;&#x540D;&#x79F0;&#x548C;&#x5BC6;&#x7801;&#x81EA;&#x5B9A;&#x4E49;&#xFF0C;esp32&#x7684;ap&#x6A21;&#x5F0F;&#x9ED8;&#x8BA4;&#x7684;ip(192.168.4.1)&#xFF0C;\n&#x7528;&#x8FD9;&#x4E2A;ip&#x8BBF;&#x95EE;http&#x8D44;&#x6E90;&#xFF0C;&#x8BF7;&#x6C42;&#x4E00;&#x4E2A;&#x9875;&#x9762;&#x7528;&#x4E8E;&#x586B;&#x5199;WiFi&#x540D;&#x79F0;&#x548C;&#x5BC6;&#x7801;&#xFF0C;&#x5185;&#x90E8;&#x8FD4;&#x56DE;&#x5E76;&#x5B58;&#x5165;esp32&#x7684;NVS&#xFF0C;&#x4E0D;&#x4E86;&#x89E3;&#x7684;&#x540C;&#x5B66;&#x770B;&#x8FD9;&#x4E2A;\n&#x70B9;&#x51FB;&#x8FDE;&#x63A5;&#x540E;&#xFF0C;esp32&#x4F7F;&#x7528;&#x7528;&#x6237;&#x586B;&#x5199;&#x7684;WiFi&#x4FE1;&#x606F;&#x8FDE;&#x63A5;WiFi\n\n\n\n\n&#x6210;&#x529F;\n&#x5931;&#x8D25;\n\n\n\n&#x663E;&#x793A;&#x914D;&#x7F6E;&#x6210;&#x529F;&#xFF0C;&#x624B;&#x52A8;&#x5237;&#x65B0;&#x4E00;&#x4E0B;&#x9875;&#x9762;&#xFF0C;&#x70B9;&#x51FB;&#x4E0B;&#x4E00;&#x6B65;\n&#x663E;&#x793A;&#x914D;&#x7F6E;&#x9519;&#x8BEF;&#xFF0C;&#x8FD4;&#x56DE;&#x914D;&#x7F6E;&#x9875;&#x9762;\n\n\n\n&#x8FD9;&#x91CC;&#x4E00;&#x822C;&#x8FD8;&#x8FDE;&#x63A5;&#x7684;&#x662F;esp32&#x7684;&#x70ED;&#x70B9;&#xFF0C;&#x663E;&#x793A;&#x5206;&#x914D;&#x7684;ip&#x5730;&#x5740;&#x548C;&#x5173;&#x95ED;ap&#x6A21;&#x5F0F;&#x529F;&#x80FD;&#x3002;&#x63A8;&#x8350;&#x914D;&#x7F51;&#x6210;&#x529F;&#x540E;&#x5173;&#x95ED;ap&#xFF0C;&#x6BD4;&#x8F83;&#x8017;&#x7535;&#x3002;\n&#x70B9;&#x51FB;&#x8FDE;&#x63A5;&#x540E;&#x4F1A;&#x8DF3;&#x8F6C;&#x5230;&#x8DEF;&#x7531;&#x5668;&#x4E3A;esp32&#x5206;&#x914D;&#x7684;&#x7F51;&#x5740;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x6CA1;&#x6709;&#x53CD;&#x5E94;&#xFF0C;&#x56E0;&#x4E3A;esp32&#x4E0D;&#x54CD;&#x5E94;&#x8DEF;&#x7531;&#x5206;&#x914D;&#x7684;ip&#xFF1B;&#x8FD9;&#x65F6;&#x5019;&#x4E0D;&#x8981;&#x5173;&#x95ED;&#x7F51;&#x9875;&#x5C06;&#x8FDE;&#x63A5;esp32&#x7684;&#x8BBE;&#x5907;&#x5207;&#x6362;&#x5230;&#x914D;&#x7F6E;&#x7684;&#x5C40;&#x57DF;&#x7F51;&#xFF0C;&#x518D;&#x5237;&#x65B0;&#x4E00;&#x4E0B;&#x3002;\n&#x70B9;&#x51FB;&#x8BBF;&#x95EE;&#x8BBE;&#x5907;&#xFF0C;&#x81EA;&#x52A8;&#x8DF3;&#x8F6C;&#x5230;&#x6307;&#x5B9A;&#x7684;&#x63A7;&#x5236;&#x7F51;&#x9875;\n&#x76EE;&#x524D;&#x8FD8;&#x6CA1;&#x6709;&#x5B9E;&#x73B0;&#x56FA;&#x5B9A;ip&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x8FDE;&#x63A5;&#x9636;&#x6BB5;&#x7528;&#x4E32;&#x53E3;&#x67E5;&#x770B;&#x5206;&#x914D;&#x7684;ip&#x5730;&#x5740;&#xFF0C;&#x5982;&#x679C;&#x60F3;&#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x7684;wifi&#x4FE1;&#x606F;&#xFF0C;&#x8BF7;&#x4F7F;&#x7528;esp-idf&#x7684;&#x6E05;&#x7406;flash&#x7684;&#x5DE5;&#x5177;&#x5E76;&#x91CD;&#x65B0;&#x70E7;&#x5F55;&#x4EE3;&#x7801;&#x3002;&#x6E90;&#x7801;&#x5904;&#x4E8E;debug&#x9636;&#x6BB5;&#xFF0C;&#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#x4F1A;&#x81EA;&#x52A8;&#x6E05;&#x7406;nvs&#x7684;&#x6570;&#x636E;&#xFF0C;&#x4F46;&#x662F;&#x4E0D;&#x77E5;&#x9053;&#x4E3A;&#x4EC0;&#x4E48;&#x6E05;&#x7406;&#x4E0D;&#x4E86;wifi&#x4FE1;&#x606F;&#xFF0C;&#x540E;&#x7EED;&#x4F18;&#x5316;\n\n&#x5B9E;&#x6218;//wifi_driver.h#ifndef _WIFI_DRIVER_H#define _WIFI_DRIVER_H#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/semphr.h&quot;typedef struct {    char ssid[32];    char password[64];    // char ip[16];    // char gw[16];    // char netmask[16];} wifi_info_config_t;extern char sta_ip[16];extern bool sta_connected;extern bool ap_active;extern SemaphoreHandle_t wifiStaConnectedHandle;#ifdef __cplusplusextern &quot;C&quot; {#endif    void wifi_init(void);       //&#x521D;&#x59CB;&#x5316;    void wifi_config_ap(void);  //&#x8BBE;&#x7F6E;ap&#x6A21;&#x5F0F;    void wifi_config_sta(wifi_info_config_t *config);   //&#x8BBE;&#x7F6E;sta&#x6A21;&#x5F0F;    bool wifi_has_saved_config(void);                   //&#x67E5;&#x770B;&#x662F;&#x5426;&#x6709;&#x4FDD;&#x5B58;&#x7684;&#x914D;&#x7F6E;    void wifi_save_config(wifi_info_config_t *config);  //&#x4FDD;&#x5B58;wifi&#x914D;&#x7F6E;    void wifi_load_config(wifi_info_config_t *config);  //&#x52A0;&#x8F7D;&#x914D;&#x7F6E;    void wifi_clear_config(void);                       //&#x6E05;&#x9664;&#x914D;&#x7F6E;    void wifi_close_ap(void);                           //&#x5173;&#x95ED;ap&#x6A21;&#x5F0F;#ifdef _cplusplus}#endif#endif```c//wifi_driver.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;wifi_driver.h&quot;#include &quot;esp_wifi.h&quot;#include &quot;esp_event.h&quot;#include &quot;esp_check.h&quot;#include &quot;esp_netif.h&quot;#include &quot;lwip/ip_addr.h&quot;#include &quot;nvs_flash.h&quot;#include &quot;nvs.h&quot;//wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x4F4D;#define WIFI_CONNECTED_BIT BIT0#define WIFI_FAIL_BIT      BIT1#define EXAMPLE_ESP_MAXIMUM_RETRY 5//AP&#x6A21;&#x5F0F;&#x4FE1;&#x606F;#define EXAMPLE_ESP_WIFI_AP_SSID            &quot;ESP_WIFI_AP&quot;#define EXAMPLE_ESP_WIFI_AP_PASSWD          &quot;12345678&quot;#define EXAMPLE_ESP_WIFI_CHANNEL            6#define EXAMPLE_MAX_STA_CONN                4//nvs&#x4FDD;&#x5B58;wifi&#x914D;&#x7F6E;static const char *NVS_NAMESPACE = &quot;wifi_config&quot;;static const char *NVS_KEY = &quot;sta_config&quot;;//&#x8FDE;&#x63A5;&#x6A21;&#x5F0F;&#x4FE1;&#x606F;char sta_ip[16] = &quot;0.0.0.0&quot;;bool sta_connected = false;bool ap_active = true;//&#x65E5;&#x5FD7;&#x4FE1;&#x606F;static const char *TAG_AP = &quot;WiFi SoftAP&quot;;static const char *TAG_STA = &quot;WiFi Sta&quot;;static int s_retry_num = 0;// &#x58F0;&#x660E;&#x7F51;&#x7EDC;&#x63A5;&#x53E3;&#x6307;&#x9488;static esp_netif_t *sta_netif = NULL;static esp_netif_t *ap_netif = NULL;//&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;&#x53E5;&#x67C4;static EventGroupHandle_t s_wifi_event_group;   //&#x521B;&#x5EFA;sta&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x4FE1;&#x53F7;&#x91CF;SemaphoreHandle_t wifiStaConnectedHandle = NULL;static void wifi_event_handler(void* arg, esp_event_base_t event_base,                                int32_t event_id, void* event_data){    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_AP_STACONNECTED)     {        //wifi_event_ap_staconnected_t *event = (wifi_event_ap_staconnected_t *) event_data;        ESP_LOGI(TAG_AP, &quot;Station connected to AP&quot;);    }     else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_AP_STADISCONNECTED)     {        //wifi_event_ap_stadisconnected_t *event = (wifi_event_ap_stadisconnected_t *) event_data;        ESP_LOGI(TAG_AP, &quot;Station disconnected to AP&quot;);    }     else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START)     {        esp_wifi_connect();        s_retry_num = 0;        ESP_LOGI(TAG_STA, &quot;Station started&quot;);    }    else if(event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED)     {        if (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) {//&#x5C1D;&#x8BD5;5&#x6B21;&#x8FDE;&#x63A5;&#x4E0D;&#x4E0A;&#x5C31;&#x6253;&#x5370;&#x9519;&#x8BEF;&#x4FE1;&#x606F;            esp_wifi_connect();            s_retry_num++;            ESP_LOGI(TAG_STA, &quot;retry to connect to the AP&quot;);        } else {            //sta&#x8FDE;&#x63A5;&#x5931;&#x8D25;            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);//&#x7ED9;wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x5931;&#x8D25;&#x4F4D;&#x7F6E;&#x4F4D;            sta_connected = false;            xSemaphoreGive(wifiStaConnectedHandle);            ESP_LOGE(TAG_STA, &quot;&#x8D85;&#x8FC7;&#x6700;&#x5927;&#x91CD;&#x8FDE;&#x6B21;&#x6570;,&#x8FDE;&#x63A5;&#x5931;&#x8D25;&quot;);            // &#x542F;&#x7528; AP &#x6A21;&#x5F0F;&#x5141;&#x8BB8;&#x91CD;&#x65B0;&#x914D;&#x7F6E;            if (!ap_active) {                wifi_config_ap();             }        }    }    else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP)     {//ip&#x4E8B;&#x4EF6;        ip_event_got_ip_t *event = (ip_event_got_ip_t *) event_data;        ESP_LOGI(TAG_STA, &quot;Got IP:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));        sprintf(sta_ip, IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));        s_retry_num = 0;        //&#x8FDE;&#x63A5;&#x6210;&#x529F;        sta_connected = true;        xSemaphoreGive(wifiStaConnectedHandle);        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);    }}void wifi_init(void){    //&#x521B;&#x5EFA;&#x4E8C;&#x503C;&#x4FE1;&#x53F7;&#x91CF;&#xFF0C;wifi&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x4FE1;&#x53F7;&#x91CF;    wifiStaConnectedHandle = xSemaphoreCreateBinary();    //&#x521D;&#x59CB;&#x5316;&#x65F6;&#x95F4;&#x7EC4;    s_wifi_event_group = xEventGroupCreate();    //&#x521D;&#x59CB;&#x5316;TCP/IP&#x534F;&#x8BAE;&#x6808;    ESP_ERROR_CHECK(esp_netif_init());    //&#x521B;&#x5EFA;&#x9ED8;&#x8BA4;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;    ESP_ERROR_CHECK(esp_event_loop_create_default());     // &#x521B;&#x5EFA;&#x9ED8;&#x8BA4;&#x7F51;&#x7EDC;&#x63A5;&#x53E3;    if (sta_netif == NULL) {        sta_netif = esp_netif_create_default_wifi_sta();        assert(sta_netif != NULL);    }    // WiFi&#x9ED8;&#x8BA4;&#x914D;&#x7F6E;    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));     //wifi_config_sta(const char *ssid, const char *password);    esp_event_handler_instance_t instance_any_id;    esp_event_handler_instance_t instance_got_ip;    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,                                                        ESP_EVENT_ANY_ID,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_any_id));    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,                                                        IP_EVENT_STA_GOT_IP,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_got_ip));    // &#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709;&#x4FDD;&#x5B58;&#x7684;&#x914D;&#x7F6E;    if (wifi_has_saved_config()) {        wifi_info_config_t config;        wifi_load_config(&amp;config);                // &#x53EA;&#x5F00;&#x542F;STA&#x6A21;&#x5F0F;        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));        wifi_config_sta(&amp;config);        ap_active = false;        ESP_LOGI(TAG_STA, &quot;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x7684;&#x914D;&#x7F6E;&#x8FDE;&#x63A5;WiFi: %s&quot;, config.ssid);    } else {        // &#x5F00;&#x542F;AP+STA&#x6A21;&#x5F0F;        wifi_config_ap();     }        // &#x542F;&#x52A8;WiFi    ESP_ERROR_CHECK(esp_wifi_start());}void wifi_config_ap(void){    ESP_LOGI(TAG_AP, &quot;Starting AP mode...&quot;);    // &#x521B;&#x5EFA;AP&#x7F51;&#x7EDC;&#x63A5;&#x53E3;    if (ap_netif == NULL) {        ap_netif = esp_netif_create_default_wifi_ap();        assert(ap_netif != NULL);    }        wifi_config_t wifi_ap_config = {        .ap = {            .ssid = EXAMPLE_ESP_WIFI_AP_SSID,            .ssid_len = strlen(EXAMPLE_ESP_WIFI_AP_SSID),            .channel = EXAMPLE_ESP_WIFI_CHANNEL,            .password = EXAMPLE_ESP_WIFI_AP_PASSWD,            .max_connection = EXAMPLE_MAX_STA_CONN,            .authmode = WIFI_AUTH_WPA2_PSK,            .pmf_cfg = {                .required = false,            },        },    };    if (strlen(EXAMPLE_ESP_WIFI_AP_PASSWD) == 0) {        wifi_ap_config.ap.authmode = WIFI_AUTH_OPEN;    }    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_APSTA));    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &amp;wifi_ap_config));    ap_active = true;    ESP_LOGI(TAG_AP, &quot;AP+STA&#x6A21;&#x5F0F;&#x542F;&#x52A8;. AP SSID: %s&quot;, EXAMPLE_ESP_WIFI_AP_SSID);    // ESP_LOGI(TAG_AP, &quot;wifi_init_softap finished. SSID:%s password:%s channel:%d&quot;,    //          EXAMPLE_ESP_WIFI_AP_SSID, EXAMPLE_ESP_WIFI_AP_PASSWD, EXAMPLE_ESP_WIFI_CHANNEL);}void wifi_config_sta(wifi_info_config_t *config){    ESP_LOGI(TAG_STA, &quot;Connecting to WiFi: %s&quot;, config-&gt;ssid);    // &#x521B;&#x5EFA;STA&#x7F51;&#x7EDC;&#x63A5;&#x53E3;    if (sta_netif == NULL) {        sta_netif = esp_netif_create_default_wifi_sta();        assert(sta_netif != NULL);    }    wifi_config_t wifi_sta_config = {        .sta = {            .ssid = &quot;NULL&quot;,            .password = &quot;NULL&quot;,            /* Authmode threshold resets to WPA2 as default if password matches WPA2 standards (password len =&gt; 8).             * If you want to connect the device to deprecated WEP/WPA networks, Please set the threshold value             * to WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK and set the password with length and format matching to             * WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK standards.             */            .threshold.authmode = WIFI_AUTH_WPA2_PSK,            // .sae_pwe_h2e = ESP_WIFI_SAE_MODE,            // .sae_h2e_identifier = EXAMPLE_H2E_IDENTIFIER,        },    };    strncpy((char*)wifi_sta_config.sta.ssid, config-&gt;ssid, sizeof(wifi_sta_config.sta.ssid));    strncpy((char*)wifi_sta_config.sta.password, config-&gt;password, sizeof(wifi_sta_config.sta.password));    //ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_sta_config));    // // &#x8BBE;&#x7F6E;&#x9759;&#x6001;IP    // if (strlen(config-&gt;ip) &gt; 0 &amp;&amp; strlen(config-&gt;gw) &gt; 0 &amp;&amp; strlen(config-&gt;netmask) &gt; 0) {    //     esp_netif_ip_info_t ip_info;    //     memset(&amp;ip_info, 0, sizeof(ip_info));            //     ip_info.ip.addr = ipaddr_addr(config-&gt;ip);    //     ip_info.gw.addr = ipaddr_addr(config-&gt;gw);    //     ip_info.netmask.addr = ipaddr_addr(config-&gt;netmask);            //     esp_netif_dhcp_status_t dhcp_status;    //     esp_netif_t* netif = esp_netif_get_handle_from_ifkey(&quot;WIFI_STA_DEF&quot;);            //     if (esp_netif_dhcpc_get_status(netif, &amp;dhcp_status) == ESP_OK) {    //         if (dhcp_status == ESP_NETIF_DHCP_STARTED) {    //             ESP_ERROR_CHECK(esp_netif_dhcpc_stop(netif));    //         }    //         ESP_ERROR_CHECK(esp_netif_set_ip_info(netif, &amp;ip_info));    //     }    // }    ESP_LOGI(TAG_STA, &quot;wifi_init_sta finished.&quot;);    // &#x91CD;&#x7F6E;&#x91CD;&#x8FDE;&#x8BA1;&#x6570;&#x5668;    s_retry_num = 0;    ESP_ERROR_CHECK(esp_wifi_connect());            // /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum    //  * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */    // //&#x7B49;&#x5F85;&#x8FDE;&#x63A5;&#x4E8B;&#x4EF6;&#x5EFA;&#x7ACB;&#x8D77;&#x6765;&#xFF0C;&#x6216;&#x8005;&#x5C1D;&#x8BD5;&#x6700;&#x5927;&#x8FDE;&#x63A5;&#x6570;&#x540E;&#x5931;&#x8D25;&#xFF0C;&#x7531;wifi_event_handler()&#x8BBE;&#x7F6E;&#xFF0C;&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x6CE8;&#x91CA;    // EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,    //         WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,    //         pdFALSE,    //         pdFALSE,    //         portMAX_DELAY);    // /* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually    //  * happened. */    // //&#x6839;&#x636E;&#x4E8B;&#x4EF6;&#x4F4D;&#x6765;&#x6D4B;&#x8BD5;&#x4E8B;&#x4EF6;&#x662F;&#x5426;&#x53D1;&#x751F;    // if (bits &amp; WIFI_CONNECTED_BIT) {    //     ESP_LOGI(TAG_STA, &quot;connected to ap SSID:%s password:%s&quot;,ssid, password);    // } else if (bits &amp; WIFI_FAIL_BIT) {    //     ESP_LOGI(TAG_STA, &quot;Failed to connect to SSID:%s, password:%s&quot;,ssid, password);    // } else {    //     ESP_LOGE(TAG_STA, &quot;UNEXPECTED EVENT&quot;);    // }}bool wifi_has_saved_config(){    nvs_handle_t nvs;    //&#x8BFB;&#x547D;&#x540D;&#x7A7A;&#x95F4;    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &amp;nvs);    if (err != ESP_OK) {        return false;    }        wifi_info_config_t config;    size_t required_size = sizeof(config);    //&#x8BFB;&#x53D6;&#x5BF9;&#x5E94;&#x7684;&#x6570;&#x636E;    err = nvs_get_blob(nvs, NVS_KEY, &amp;config, &amp;required_size);    nvs_close(nvs);    //&#x4EFB;&#x610F;&#x4E3A;false&#x5219;&#x8FD4;&#x56DE;false    return (err == ESP_OK &amp;&amp; required_size == sizeof(config) &amp;&amp; strlen(config.ssid) &gt; 0);}void wifi_save_config(wifi_info_config_t *config){    nvs_handle_t nvs;    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &amp;nvs);    if (err != ESP_OK) {        ESP_LOGE(&quot;WIFI&quot;, &quot;&#x65E0;&#x6CD5;&#x6253;&#x5F00;NVS&#x547D;&#x540D;&#x7A7A;&#x95F4;&quot;);        return;    }        err = nvs_set_blob(nvs, NVS_KEY, config, sizeof(wifi_info_config_t));    if (err != ESP_OK) {        ESP_LOGE(&quot;WIFI&quot;, &quot;&#x4FDD;&#x5B58;&#x914D;&#x7F6E;&#x5931;&#x8D25;&quot;);        nvs_close(nvs);        return;    }        nvs_commit(nvs);    nvs_close(nvs);    ESP_LOGI(&quot;WIFI&quot;, &quot;WiFi&#x914D;&#x7F6E;&#x5DF2;&#x4FDD;&#x5B58;&quot;);}void wifi_load_config(wifi_info_config_t *config){    nvs_handle_t nvs;    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &amp;nvs);    if (err != ESP_OK) {        return;    }        size_t required_size = sizeof(wifi_info_config_t);    err = nvs_get_blob(nvs, NVS_KEY, config, &amp;required_size);    nvs_close(nvs);        if (err != ESP_OK || required_size != sizeof(wifi_info_config_t)) {        memset(config, 0, sizeof(wifi_info_config_t));    }}void wifi_clear_config(void){    // &#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x7684;WiFi&#x914D;&#x7F6E;    nvs_handle_t nvs;    if (nvs_open(NVS_NAMESPACE, NVS_READWRITE, &amp;nvs) == ESP_OK) {        nvs_erase_key(nvs, NVS_KEY);        nvs_commit(nvs);        nvs_close(nvs);        ESP_LOGI(TAG_STA, &quot;&#x5DF2;&#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x7684;WiFi&#x914D;&#x7F6E;&quot;);    }    }void wifi_close_ap(){    if (ap_active &amp;&amp; sta_connected) {        ap_active = false;        esp_wifi_set_mode(WIFI_MODE_STA);        ESP_LOGI(TAG_AP, &quot;AP&#x6A21;&#x5F0F;&#x5DF2;&#x5173;&#x95ED;&quot;);                // &#x9500;&#x6BC1;AP&#x7F51;&#x7EDC;&#x63A5;&#x53E3;        if (ap_netif != NULL) {            esp_netif_destroy(ap_netif);            ap_netif = NULL;        }    }}\n\n//http_server.h#ifndef _HTTP_SERVER_H#define _HTTP_SERVER_H#include &lt;stdint.h&gt;#include &quot;esp_http_server.h&quot;#ifdef __cplusplusextern &quot;C&quot; {#endifhttpd_handle_t start_webserver(void);void stop_webserver(void);#ifdef _cplusplus}#endif#endif\n\n//http_server.c#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;#include &quot;esp_check.h&quot;#include &quot;http_server.h&quot;#include &quot;cmd_parser.h&quot;#include &quot;wifi_driver.h&quot;#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))#define EXAMPLE_HTTP_QUERY_KEY_MAX_LEN  (64)static const char *TAG = &quot;HTTP&quot;;static httpd_handle_t server = NULL;        //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;// &#x7B80;&#x5355;&#x7684;HTML&#x5934;&#x90E8;static const char* html_header =     &quot;&lt;!DOCTYPE html&gt;&quot;    &quot;&lt;html&gt;&lt;head&gt;&quot;    &quot;&lt;meta charset=\\&quot;UTF-8\\&quot;&gt;&quot;    &quot;&lt;meta name=\\&quot;viewport\\&quot; content=\\&quot;width=device-width, initial-scale=1\\&quot;&gt;&quot;    &quot;&lt;title&gt;ESP32&#x63A7;&#x5236;&lt;/title&gt;&quot;    &quot;&lt;style&gt;&quot;    &quot;body { font-family: Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; }&quot;    &quot;h1 { color: #333; }&quot;    &quot;form { margin: 20px 0; }&quot;    &quot;input[type=text], input[type=password] { width: 100%; padding: 10px; margin: 5px 0; }&quot;    &quot;input[type=submit] { padding: 10px 20px; background: #4CAF50; color: white; border: none; cursor: pointer; }&quot;    &quot;input[type=submit]:hover { background: #45a049; }&quot;    &quot;.status { padding: 10px; background: #f0f0f0; margin: 10px 0; }&quot;    &quot;&lt;/style&gt;&quot;    &quot;&lt;/head&gt;&lt;body&gt;&quot;;// &#x7B80;&#x5355;&#x7684;HTML&#x5C3E;&#x90E8;static const char* html_footer = &quot;&lt;/body&gt;&lt;/html&gt;&quot;;// &#x914D;&#x7F51;&#x9875;&#x9762;static const char* html_form =     &quot;&lt;h1&gt;WiFi&#x914D;&#x7F6E;&lt;/h1&gt;&quot;    &quot;&lt;form action=&apos;/config&apos;&gt;&quot;    &quot;&lt;label for=&apos;ssid&apos;&gt;WiFi&#x540D;&#x79F0;:&lt;/label&gt;&quot;    &quot;&lt;input type=&apos;text&apos; id=&apos;ssid&apos; name=&apos;ssid&apos; required&gt;&lt;br&gt;&quot;    &quot;&lt;label for=&apos;password&apos;&gt;&#x5BC6;&#x7801;:&lt;/label&gt;&quot;    &quot;&lt;input type=&apos;password&apos; id=&apos;password&apos; name=&apos;password&apos;&gt;&lt;br&gt;&quot;    // &quot;&lt;h3&gt;&#x9759;&#x6001;IP (&#x53EF;&#x9009;)&lt;/h3&gt;&quot;    // &quot;&lt;label for=&apos;ip&apos;&gt;IP&#x5730;&#x5740;:&lt;/label&gt;&quot;    // &quot;&lt;input type=&apos;text&apos; id=&apos;ip&apos; name=&apos;ip&apos;&gt;&lt;br&gt;&quot;    // &quot;&lt;label for=&apos;gw&apos;&gt;&#x7F51;&#x5173;:&lt;/label&gt;&quot;    // &quot;&lt;input type=&apos;text&apos; id=&apos;gw&apos; name=&apos;gw&apos;&gt;&lt;br&gt;&quot;    // &quot;&lt;label for=&apos;netmask&apos;&gt;&#x5B50;&#x7F51;&#x63A9;&#x7801;:&lt;/label&gt;&quot;    // &quot;&lt;input type=&apos;text&apos; id=&apos;netmask&apos; name=&apos;netmask&apos;&gt;&lt;br&gt;&quot;    &quot;&lt;input type=&apos;submit&apos; value=&apos;&#x8FDE;&#x63A5;&apos;&gt;&quot;    &quot;&lt;/form&gt;&quot;;// &#x914D;&#x7F6E;&#x6210;&#x529F;&#x9875;&#x9762;static const char* html_success =     &quot;&lt;h1&gt;&#x914D;&#x7F6E;&#x6210;&#x529F;!&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x6B63;&#x5728;&#x8FDE;&#x63A5;&#x7F51;&#x7EDC;...&lt;/p&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;/device&apos;&gt;&#x4E0B;&#x4E00;&#x6B65;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;;//&#x914D;&#x7F6E;&#x9519;&#x8BEF;static const char* html_error =     &quot;&lt;h1&gt;&#x914D;&#x7F6E;&#x9519;&#x8BEF;&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x8BF7;&#x8F93;&#x5165;&#x6709;&#x6548;&#x7684;WiFi&#x540D;&#x79F0;&lt;/p&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;/&apos;&gt;&#x8FD4;&#x56DE;&#x914D;&#x7F6E;&#x9875;&#x9762;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;;// &#x8FDE;&#x63A5;&#x9875;&#x9762;static const char* html_device =     &quot;&lt;h1&gt;&#x8BBE;&#x5907;&#x63A7;&#x5236;&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x8BBE;&#x5907;&#x5DF2;&#x8FDE;&#x63A5;&lt;/p&gt;&quot;    &quot;&lt;p&gt;IP&#x5730;&#x5740;: %s&lt;/p&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;http://%s/command&apos;&gt;&#x8BBF;&#x95EE;&#x8BBE;&#x5907;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;http://%s/closeap&apos;&gt;&#x5173;&#x95ED;AP&#x6A21;&#x5F0F;&lt;/a&gt;&lt;/p&gt;&quot;;// AP&#x5173;&#x95ED;&#x9875;&#x9762;static const char* html_ap_off =     &quot;&lt;h1&gt;AP&#x6A21;&#x5F0F;&#x5DF2;&#x5173;&#x95ED;&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x4F7F;&#x7528;ip&#x5730;&#x5740;&lt;a href=http://%s/command&gt;&#x8BBF;&#x95EE;&#x8BBE;&#x5907;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;;static const char* html_control =     &quot;&lt;h1 style=&apos;text-align:center&apos;&gt;&#x673A;&#x5668;&#x4EBA;&#x63A7;&#x5236;&lt;/h1&gt;&quot;    &quot;&lt;div style=&apos;margin:20px auto;text-align:center&apos;&gt;&quot;    &quot;&lt;label&gt;&#x901F;&#x5EA6;&#x503C;&#xFF1A;&lt;input type=&apos;number&apos; id=&apos;speed&apos; min=&apos;1&apos; max=&apos;100&apos; value=&apos;70&apos; style=&apos;width:80px&apos;&gt;&lt;/label&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;div style=&apos;display:flex;flex-direction:column;align-items:center;gap:12px&apos;&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;forward\\&quot;)&apos;&gt;&#x2191;&lt;/button&gt;&quot;    &quot;&lt;div style=&apos;display:flex;gap:8px&apos;&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;left\\&quot;)&apos;&gt;&#x2190;&lt;/button&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;right\\&quot;)&apos;&gt;&#x2192;&lt;/button&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;backward\\&quot;)&apos;&gt;&#x2193;&lt;/button&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;background:#ff4444&apos; onclick=&apos;sendCmd(\\&quot;stop\\&quot;)&apos;&gt;&#x7D27;&#x6025;&#x505C;&#x6B62;&lt;/button&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;script&gt;&quot;    &quot;function sendCmd(cmd){&quot;    &quot;  let speed=document.getElementById(&apos;speed&apos;).value;&quot;    &quot;  fetch(`http://%s/command?cmd=${cmd}&amp;speed=${speed}`);&quot;    &quot;}&quot;    &quot;&lt;/script&gt;&quot;;/* URI &#x5904;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x5728;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x8D77; GET /helloworld &#x8BF7;&#x6C42;&#x65F6;&#x88AB;&#x8C03;&#x7528; *//* An HTTP GET handler */static esp_err_t hello_world_handler(httpd_req_t *req){\tchar *buf;\tsize_t buf_len;\t/* Get header value string length and allocate memory for length + 1,\t * extra byte for null termination */\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Host&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\t/* Copy null terminated value string into buffer */\t\tif (httpd_req_get_hdr_value_str(req, &quot;Host&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Host: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-2&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-2&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-2: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-1&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-1&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-1: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\t/* Set some custom headers */\t//&#x8BBE;&#x7F6E;&#x81EA;&#x5B9A;&#x4E49;&#x5934;\thttpd_resp_set_hdr(req, &quot;Custom-Header-1&quot;, &quot;Custom-Value-1&quot;);\thttpd_resp_set_hdr(req, &quot;Custom-Header-2&quot;, &quot;Custom-Value-2&quot;);\t/* Send response with custom headers and body set as the\t * string passed in user context*/\tconst char *resp_str = (const char *)req-&gt;user_ctx;\t\t\thttpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);\t//&#x53D1;&#x9001;resp_str&#x5B57;&#x7B26;&#x4E32;&#x5185;&#x5BB9;\t/* After sending the HTTP response the old HTTP request\t * headers are lost. Check if HTTP request headers can be read now. */\t//&#x54CD;&#x5E94;http&#x65E7;&#x8BF7;&#x6C42;&#x540E;&#x68C0;&#x67E5;\tif (httpd_req_get_hdr_value_len(req, &quot;Host&quot;) == 0)\t{\t\tESP_LOGI(TAG, &quot;Request headers lost&quot;);\t}\treturn ESP_OK;}static const httpd_uri_t hello_world = {    .uri = &quot;/helloworld&quot;,    .method = HTTP_GET,    .handler = hello_world_handler,    .user_ctx = &quot;Hello World!&quot;,};// static esp_err_t get_status_handler(httpd_req_t *req){// \tcommand_params_t get_status_handler;// \tif(command_get_current_command(&amp;get_status_handler)!=0){// \t\thttpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, &quot;Invalid command&quot;);//         return ESP_OK;// \t}// \tchar statusString[100];// \tsprintf(statusString,&quot;Command set: %s, Speed: %d%%, Continuous: %d&quot;,// \t\t\tcmd_strings[get_status_handler.type], get_status_handler.speed, get_status_handler.is_continuous);// \thttpd_resp_send(req, statusString, HTTPD_RESP_USE_STRLEN);// \treturn ESP_OK;// }// static const httpd_uri_t uri_get_status = {//     .uri = &quot;/status&quot;,//     .method = HTTP_GET,//     .handler = get_status_handler,//     .user_ctx = NULL,// };// HTTP&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x51FD;&#x6570;static esp_err_t root_handler(httpd_req_t *req){    char *html_content = NULL;        if (ap_active &amp;&amp; !sta_connected) {        // &#x663E;&#x793A;&#x914D;&#x7F51;&#x9875;&#x9762;        size_t len = strlen(html_header) + strlen(html_form) + strlen(html_footer) + 1;        html_content = malloc(len);        if (html_content) {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_form, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }    } else if (sta_connected) {        // &#x663E;&#x793A;&#x6210;&#x529F;&#x9875;&#x9762;        size_t len = strlen(html_header) + strlen(html_success) + strlen(html_footer) + 1;        html_content = malloc(len);        if (html_content) {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_success, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }    }        // &#x9ED8;&#x8BA4;&#x54CD;&#x5E94;    httpd_resp_send(req, &quot;&#x8BBE;&#x5907;&#x72B6;&#x6001;&#x672A;&#x77E5;&quot;, HTTPD_RESP_USE_STRLEN);    return ESP_OK;}static httpd_uri_t root_uri = {            .uri = &quot;/&quot;,            .method = HTTP_GET,            .handler = root_handler};//&#x914D;&#x7F6E;&#x51FD;&#x6570;static esp_err_t config_handler(httpd_req_t *req){    char query[200];    if (httpd_req_get_url_query_str(req, query, sizeof(query)) != ESP_OK) {        httpd_resp_send(req, &quot;&#x65E0;&#x6548;&#x8BF7;&#x6C42;&quot;, HTTPD_RESP_USE_STRLEN);        return ESP_FAIL;    }        wifi_info_config_t config = {0};        httpd_query_key_value(query, &quot;ssid&quot;, config.ssid, sizeof(config.ssid));    httpd_query_key_value(query, &quot;password&quot;, config.password, sizeof(config.password));        ESP_LOGI(&quot;HTTP&quot;, &quot;&#x6536;&#x5230;&#x914D;&#x7F6E;: SSID=%s, PASSWORD=%s&quot;, config.ssid, config.password);    // &#x4FDD;&#x5B58;&#x914D;&#x7F6E;&#x5230;NVS    wifi_save_config(&amp;config);        // &#x8BBE;&#x7F6E;STA&#x914D;&#x7F6E;    wifi_config_sta(&amp;config);    xSemaphoreTake(wifiStaConnectedHandle, pdTICKS_TO_MS(500));    // &#x663E;&#x793A;&#x6210;&#x529F;&#x9875;&#x9762;    if(sta_connected == true){        size_t len = strlen(html_header) + strlen(html_success) + strlen(html_footer) + 1;        char *html_content = malloc(len);        if (html_content)        {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_success, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }        httpd_resp_send(req, &quot;&#x914D;&#x7F6E;&#x5DF2;&#x4FDD;&#x5B58;&quot;, HTTPD_RESP_USE_STRLEN);    }    else if(sta_connected == false){        wifi_clear_config();        // &#x663E;&#x793A;&#x9519;&#x8BEF;&#x9875;&#x9762;        size_t len = strlen(html_header) + strlen(html_error) + strlen(html_footer) + 1;        char *html_content = malloc(len);        if (html_content) {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_error, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }        httpd_resp_send(req, &quot;&#x914D;&#x7F6E;&#x5DF2;&#x5220;&#x9664;&quot;, HTTPD_RESP_USE_STRLEN);    }        return ESP_OK;}static httpd_uri_t config_uri = {            .uri = &quot;/config&quot;,            .method = HTTP_GET,            .handler = config_handler};//&#x8BBE;&#x5907;&#x63A7;&#x5236;static esp_err_t device_handler(httpd_req_t *req){    char html_device_temp[256];    snprintf(html_device_temp, sizeof(html_device_temp), html_device, sta_ip, sta_ip, sta_ip);    size_t len = strlen(html_header) + strlen(html_device_temp) + strlen(html_footer) + 1;    char *html_content = malloc(len);    if (html_content) {        snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_device_temp, html_footer);        httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);        free(html_content);        return ESP_OK;    }    // &#x91CD;&#x5B9A;&#x5411;&#x56DE;&#x6839;&#x9875;&#x9762;    httpd_resp_set_status(req, &quot;303 See Other&quot;);    httpd_resp_set_hdr(req, &quot;Location&quot;, &quot;/&quot;);    httpd_resp_send(req, NULL, 0);        return ESP_OK;}static httpd_uri_t device_uri = {            .uri = &quot;/device&quot;,            .method = HTTP_GET,            .handler = device_handler};//&#x5173;&#x95ED;apstatic esp_err_t closeap_handler(httpd_req_t *req){    wifi_close_ap();        // &#x663E;&#x793A;AP&#x5173;&#x95ED;&#x9875;&#x9762;    char html_ap_off_temp[256];    snprintf(html_ap_off_temp, sizeof(html_ap_off_temp), html_ap_off, sta_ip);        size_t len = strlen(html_header) + strlen(html_ap_off_temp) + strlen(html_footer) + 1;    char *html_content = malloc(len);    if (html_content) {        snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_ap_off_temp, html_footer);        httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);        free(html_content);        return ESP_OK;    }        httpd_resp_send(req, &quot;AP&#x6A21;&#x5F0F;&#x5DF2;&#x5173;&#x95ED;&quot;, HTTPD_RESP_USE_STRLEN);    return ESP_OK;}static httpd_uri_t closeap_uri = {            .uri = &quot;/closeap&quot;,            .method = HTTP_GET,            .handler = closeap_handler};// favicon.ico &#x5904;&#x7406;&#x51FD;&#x6570;static esp_err_t favicon_handler(httpd_req_t *req){    // &#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x7A7A;&#x54CD;&#x5E94;    httpd_resp_set_status(req, &quot;204 No Content&quot;);    httpd_resp_send(req, NULL, 0);    return ESP_OK;}// &#x6DFB;&#x52A0; favicon.ico &#x5904;&#x7406;static httpd_uri_t favicon_uri = {            .uri = &quot;/favicon.ico&quot;,            .method = HTTP_GET,            .handler = favicon_handler};//&#x6307;&#x4EE4;&#x89E3;&#x6790;&#x51FD;&#x6570;&#xFF0C;&#x8FD9;&#x91CC;&#x53EF;&#x4EE5;&#x6362;&#x6210;&#x4F60;&#x9700;&#x8981;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x6307;&#x4EE4;&#x89E3;&#x6790;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x793A;&#x4F8B;static esp_err_t set_cmd_handler(httpd_req_t *req){    char html_control_temp[1024];    snprintf(html_control_temp, sizeof(html_control_temp), html_control, sta_ip);    size_t len = strlen(html_header) + strlen(html_control_temp) + strlen(html_footer) + 1;    char *html_content = malloc(len);    if (html_content) {        snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_control_temp, html_footer);        httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);        free(html_content);    }\tif(command_parse_http_get(req-&gt;uri)!=0){\t\thttpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, &quot;Invalid command&quot;);        return ESP_OK;\t}\thttpd_resp_send(req, &quot;OK&quot;, HTTPD_RESP_USE_STRLEN);    return ESP_OK;}static const httpd_uri_t cmdControl_uri = {    .uri = &quot;/command&quot;,    .method = HTTP_GET,    .handler = set_cmd_handler,    .user_ctx = NULL,};httpd_handle_t start_webserver(void){    //&#x751F;&#x6210;&#x9ED8;&#x8BA4;http&#x914D;&#x7F6E;&#x53C2;&#x6570;    httpd_config_t http_config = HTTPD_DEFAULT_CONFIG();    http_config.max_uri_handlers = 8;       //&#x6700;&#x5927;uri&#x6570;    if (httpd_start(&amp;server, &amp;http_config) == ESP_OK) {        /* &#x6CE8;&#x518C; URI &#x5904;&#x7406;&#x7A0B;&#x5E8F; */        // httpd_register_uri_handler(server, &amp;uri_get_status);        httpd_register_uri_handler(server, &amp;cmdControl_uri);        httpd_register_uri_handler(server, &amp;hello_world);        httpd_register_uri_handler(server, &amp;root_uri);        httpd_register_uri_handler(server, &amp;config_uri);        httpd_register_uri_handler(server, &amp;device_uri);        httpd_register_uri_handler(server, &amp;closeap_uri);        httpd_register_uri_handler(server, &amp;favicon_uri);        ESP_LOGI(TAG, &quot;Success starting server!&quot;);        return server;            }    /* &#x5982;&#x679C;&#x670D;&#x52A1;&#x5668;&#x542F;&#x52A8;&#x5931;&#x8D25;&#xFF0C;&#x8FD4;&#x56DE;&#x7684;&#x53E5;&#x67C4;&#x662F; NULL */    ESP_LOGI(TAG, &quot;Error starting server!&quot;);    return NULL;}void stop_webserver(void){    if (server) {        httpd_stop(server);        server = NULL;        ESP_LOGI(TAG, &quot;server stop&quot;);    }}\n&#x7F51;&#x7EDC;&#x534F;&#x8BAE;&#x8FD9;&#x5757;&#x7B14;&#x8005;&#x53EA;&#x662F;&#x7167;&#x732B;&#x753B;&#x864E;&#x52C9;&#x5F3A;&#x80FD;&#x7528;\n\nHTTP_ServerHTTP &#x5DE5;&#x4F5C;&#x539F;&#x7406;HTTP &#x534F;&#x8BAE;&#x5DE5;&#x4F5C;&#x4E8E;&#x5BA2;&#x6237;&#x7AEF;-&#x670D;&#x52A1;&#x7AEF;&#x67B6;&#x6784;&#x4E0A;&#x3002;\nHTTP &#x5DE5;&#x4F5C;&#x8FC7;&#x7A0B;&#x901A;&#x5E38;&#x5982;&#x4E0B;&#xFF1A;\n\n&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x8D77;&#x8BF7;&#x6C42;&#xFF1A;&#x7528;&#x6237;&#x901A;&#x8FC7;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;&#x5982;&#x6D4F;&#x89C8;&#x5668;&#xFF09;&#x8F93;&#x5165; URL&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x8D77;&#x4E00;&#x4E2A; HTTP &#x8BF7;&#x6C42;&#x3002;\n&#x670D;&#x52A1;&#x5668;&#x5904;&#x7406;&#x8BF7;&#x6C42;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x63A5;&#x6536;&#x5230;&#x8BF7;&#x6C42;&#x540E;&#xFF0C;&#x6839;&#x636E;&#x8BF7;&#x6C42;&#x7684;&#x7C7B;&#x578B;&#xFF08;&#x5982;GET&#x3001;POST&#x7B49;&#xFF09;&#x548C;&#x8BF7;&#x6C42;&#x7684;&#x8D44;&#x6E90;&#xFF0C;&#x8FDB;&#x884C;&#x76F8;&#x5E94;&#x7684;&#x5904;&#x7406;&#x3002;\n&#x670D;&#x52A1;&#x5668;&#x8FD4;&#x56DE;&#x54CD;&#x5E94;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x5C06;&#x5904;&#x7406;&#x7ED3;&#x679C;&#x5305;&#x88C5;&#x6210;HTTP&#x54CD;&#x5E94;&#x6D88;&#x606F;&#xFF0C;&#x53D1;&#x9001;&#x56DE;&#x5BA2;&#x6237;&#x7AEF;&#x3002;4.&#x5BA2;&#x6237;&#x7AEF;&#x6E32;&#x67D3;&#x9875;&#x9762;&#xFF1A;&#x5BA2;&#x6237;&#x7AEF;&#x63A5;&#x6536;&#x5230;&#x54CD;&#x5E94;&#x540E;&#xFF0C;&#x6839;&#x636E;&#x54CD;&#x5E94;&#x5185;&#x5BB9;&#xFF08;&#x5982;HTML&#x3001;&#x56FE;&#x7247;&#x7B49;&#xFF09;&#x6E32;&#x67D3;&#x9875;&#x9762;&#xFF0C;&#x5C55;&#x793A;&#x7ED9;&#x7528;&#x6237;&#x3002;Web &#x670D;&#x52A1;&#x5668;&#x6709;&#xFF1A;Nginx &#x670D;&#x52A1;&#x5668;&#xFF0C;Apache &#x670D;&#x52A1;&#x5668;&#xFF0C;IIS &#x670D;&#x52A1;&#x5668;&#xFF08;Internet Information Services&#xFF09;&#x7B49;&#x3002;\n\nHTTP &#x9ED8;&#x8BA4;&#x7AEF;&#x53E3;&#x53F7;&#x4E3A; 80&#xFF0C;&#x4F46;&#x662F;&#x4F60;&#x4E5F;&#x53EF;&#x4EE5;&#x6539;&#x4E3A; 8080 &#x6216;&#x8005;&#x5176;&#x4ED6;&#x7AEF;&#x53E3;&#x3002;\nHTTP &#x4E09;&#x70B9;&#x6CE8;&#x610F;&#x4E8B;&#x9879;&#xFF1A;\n\nHTTP &#x662F;&#x65E0;&#x8FDE;&#x63A5;&#xFF1A;&#x65E0;&#x8FDE;&#x63A5;&#x7684;&#x542B;&#x4E49;&#x662F;&#x9650;&#x5236;&#x6BCF;&#x6B21;&#x8FDE;&#x63A5;&#x53EA;&#x5904;&#x7406;&#x4E00;&#x4E2A;&#x8BF7;&#x6C42;&#xFF0C;&#x670D;&#x52A1;&#x5668;&#x5904;&#x7406;&#x5B8C;&#x5BA2;&#x6237;&#x7684;&#x8BF7;&#x6C42;&#xFF0C;&#x5E76;&#x6536;&#x5230;&#x5BA2;&#x6237;&#x7684;&#x5E94;&#x7B54;&#x540E;&#xFF0C;&#x5373;&#x65AD;&#x5F00;&#x8FDE;&#x63A5;&#xFF0C;&#x91C7;&#x7528;&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x53EF;&#x4EE5;&#x8282;&#x7701;&#x4F20;&#x8F93;&#x65F6;&#x95F4;&#x3002;\n\nHTTP &#x662F;&#x5A92;&#x4F53;&#x72EC;&#x7ACB;&#x7684;&#xFF1A;&#x8FD9;&#x610F;&#x5473;&#x7740;&#xFF0C;&#x53EA;&#x8981;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x5668;&#x77E5;&#x9053;&#x5982;&#x4F55;&#x5904;&#x7406;&#x7684;&#x6570;&#x636E;&#x5185;&#x5BB9;&#xFF0C;&#x4EFB;&#x4F55;&#x7C7B;&#x578B;&#x7684;&#x6570;&#x636E;&#x90FD;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;HTTP&#x53D1;&#x9001;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x4EE5;&#x53CA;&#x670D;&#x52A1;&#x5668;&#x6307;&#x5B9A;&#x4F7F;&#x7528;&#x9002;&#x5408;&#x7684; MIME-type &#x5185;&#x5BB9;&#x7C7B;&#x578B;&#x3002;\n\nHTTP &#x662F;&#x65E0;&#x72B6;&#x6001;&#xFF1A;HTTP &#x534F;&#x8BAE;&#x662F;&#x65E0;&#x72B6;&#x6001;&#x534F;&#x8BAE;&#xFF0C;&#x65E0;&#x72B6;&#x6001;&#x662F;&#x6307;&#x534F;&#x8BAE;&#x5BF9;&#x4E8E;&#x4E8B;&#x52A1;&#x5904;&#x7406;&#x6CA1;&#x6709;&#x8BB0;&#x5FC6;&#x80FD;&#x529B;&#xFF0C;&#x7F3A;&#x5C11;&#x72B6;&#x6001;&#x610F;&#x5473;&#x7740;&#x5982;&#x679C;&#x540E;&#x7EED;&#x5904;&#x7406;&#x9700;&#x8981;&#x524D;&#x9762;&#x7684;&#x4FE1;&#x606F;&#xFF0C;&#x5219;&#x5B83;&#x5FC5;&#x987B;&#x91CD;&#x4F20;&#xFF0C;&#x8FD9;&#x6837;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x6BCF;&#x6B21;&#x8FDE;&#x63A5;&#x4F20;&#x9001;&#x7684;&#x6570;&#x636E;&#x91CF;&#x589E;&#x5927;&#xFF0C;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x5728;&#x670D;&#x52A1;&#x5668;&#x4E0D;&#x9700;&#x8981;&#x5148;&#x524D;&#x4FE1;&#x606F;&#x65F6;&#x5B83;&#x7684;&#x5E94;&#x7B54;&#x5C31;&#x8F83;&#x5FEB;&#x3002;\n\n&#x4EE5;&#x4E0A;&#x5185;&#x5BB9;&#x6458;&#x81EA;&#x83DC;&#x9E1F;&#x6559;&#x7A0B;\n\n\n\n&#x53C2;&#x6570;&#x8BBE;&#x7F6E;\n&#x542F;&#x52A8;http&#x670D;&#x52A1;&#x5668;httpd_start(httpd_handle_t *handle, const httpd_config_t *config)  httpd_start(&amp;server, &amp;http_config)\nhttpd_config_t http_config = HTTPD_DEFAULT_CONFIG();    //&#x9ED8;&#x8BA4;&#x914D;&#x7F6E;\nhttp_config.max_uri_handlers = 8;       //&#x6700;&#x5927;uri&#x6570;\nstatic httpd_handle_t server = NULL;    //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;&#xFF0C;&#x9632;&#x6B62;&#x91CD;&#x590D;&#x542F;&#x52A8;HTTP&#x670D;&#x52A1;\n\n\n&#x5F53;http&#x670D;&#x52A1;&#x542F;&#x52A8;&#x6210;&#x529F;&#x540E;&#x9700;&#x8981;&#x6CE8;&#x518C;uri&#x5904;&#x7406;&#x51FD;&#x6570;httpd_register_uri_handler(httpd_handle_t handle,const httpd_uri_t *uri_handler) httpd_register_uri_handler(server, &amp;hello_world);\nstatic httpd_handle_t server = NULL;    //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;&#xFF0C;&#x9632;&#x6B62;&#x91CD;&#x590D;&#x542F;&#x52A8;HTTP&#x670D;&#x52A1;\n&amp;hello_world &#x6307;&#x5411;uri&#x5904;&#x7406;&#x51FD;&#x6570;&#x4E2D;&#x9700;&#x8981;&#x7684;&#x4FE1;&#x606F;&#x7ED3;&#x6784;&#x4F53;&#xFF1A;     static const httpd_uri_t hello_world = {    .uri = &quot;/helloworld&quot;,           //uri    .method = HTTP_GET,             //&#x65B9;&#x6CD5;    .handler = hello_world_handler, //&#x4E0A;&#x4E0B;&#x6587;&#x6570;&#x636E;    .user_ctx = &quot;Hello World!&quot;,     //&#x7528;&#x6237;&#x7684;&#x4E0A;&#x4E0B;&#x6587;};\n\n\n&#x505C;&#x6B62;http&#x670D;&#x52A1;&#x5668;httpd_stop(httpd_handle_t handle)  httpd_stop(server);\nstatic httpd_handle_t server = NULL;    //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;&#xFF0C;&#x9632;&#x6B62;&#x91CD;&#x590D;&#x542F;&#x52A8;HTTP&#x670D;&#x52A1;\n\n\n\n&#x5B9E;&#x6218;&#x4EE5;&#x8BF7;&#x6C42;hello world&#x4E3A;&#x4F8B;\n//http_server.h#ifndef _HTTP_SERVER_H#define _HTTP_SERVER_H#include &lt;stdint.h&gt;#include &quot;esp_http_server.h&quot;#ifdef __cplusplusextern &quot;C&quot; {#endifhttpd_handle_t start_webserver(void);void stop_webserver(void);#ifdef _cplusplus}#endif#endif\n//http_server.c#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;#include &quot;esp_check.h&quot;#include &quot;http_server.h&quot;#include &quot;cmd_parser.h&quot;#include &quot;wifi_driver.h&quot;#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))#define EXAMPLE_HTTP_QUERY_KEY_MAX_LEN  (64)static const char *TAG = &quot;HTTP&quot;;static httpd_handle_t server = NULL;        //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;/* URI &#x5904;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x5728;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x8D77; GET /helloworld &#x8BF7;&#x6C42;&#x65F6;&#x88AB;&#x8C03;&#x7528; *//* An HTTP GET handler */static esp_err_t hello_world_handler(httpd_req_t *req){\tchar *buf;\tsize_t buf_len;\t/* Get header value string length and allocate memory for length + 1,\t * extra byte for null termination */\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Host&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\t/* Copy null terminated value string into buffer */\t\tif (httpd_req_get_hdr_value_str(req, &quot;Host&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Host: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-2&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-2&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-2: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-1&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-1&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-1: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\t/* Set some custom headers */\t//&#x8BBE;&#x7F6E;&#x81EA;&#x5B9A;&#x4E49;&#x5934;\thttpd_resp_set_hdr(req, &quot;Custom-Header-1&quot;, &quot;Custom-Value-1&quot;);\thttpd_resp_set_hdr(req, &quot;Custom-Header-2&quot;, &quot;Custom-Value-2&quot;);\t/* Send response with custom headers and body set as the\t * string passed in user context*/\tconst char *resp_str = (const char *)req-&gt;user_ctx;\t\t\thttpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);\t//&#x53D1;&#x9001;resp_str&#x5B57;&#x7B26;&#x4E32;&#x5185;&#x5BB9;\t/* After sending the HTTP response the old HTTP request\t * headers are lost. Check if HTTP request headers can be read now. */\t//&#x54CD;&#x5E94;http&#x65E7;&#x8BF7;&#x6C42;&#x540E;&#x68C0;&#x67E5;\tif (httpd_req_get_hdr_value_len(req, &quot;Host&quot;) == 0)\t{\t\tESP_LOGI(TAG, &quot;Request headers lost&quot;);\t}\treturn ESP_OK;}//uri&#x914D;&#x7F6E;&#x4FE1;&#x606F;static const httpd_uri_t hello_world = {    .uri = &quot;/helloworld&quot;,    .method = HTTP_GET,    .handler = hello_world_handler,    .user_ctx = &quot;Hello World!&quot;,};//&#x542F;&#x52A8;http&#x670D;&#x52A1;httpd_handle_t start_webserver(void){    //&#x751F;&#x6210;&#x9ED8;&#x8BA4;http&#x914D;&#x7F6E;&#x53C2;&#x6570;    httpd_config_t http_config = HTTPD_DEFAULT_CONFIG();    http_config.max_uri_handlers = 8;       //&#x6700;&#x5927;uri&#x6570;    if (httpd_start(&amp;server, &amp;http_config) == ESP_OK) {        /* &#x6CE8;&#x518C; URI &#x5904;&#x7406;&#x7A0B;&#x5E8F; */        httpd_register_uri_handler(server, &amp;hello_world);        ESP_LOGI(TAG, &quot;Success starting server!&quot;);        return server;            }    /* &#x5982;&#x679C;&#x670D;&#x52A1;&#x5668;&#x542F;&#x52A8;&#x5931;&#x8D25;&#xFF0C;&#x8FD4;&#x56DE;&#x7684;&#x53E5;&#x67C4;&#x662F; NULL */    ESP_LOGI(TAG, &quot;Error starting server!&quot;);    return NULL;}//&#x505C;&#x6B62;http&#x670D;&#x52A1;void stop_webserver(void){    if (server) {        httpd_stop(server);        server = NULL;        ESP_LOGI(TAG, &quot;server stop&quot;);    }}","categories":["ESP32"],"tags":["笔记","ESP32"]},{"title":"stm32h750添加QRencode库，以zabr和quirc为例","url":"/2025/08/13/stm32h750%E6%B7%BB%E5%8A%A0QRencode%E5%BA%93%EF%BC%8C%E4%BB%A5zabr%E5%92%8Cquirc%E4%B8%BA%E4%BE%8B/","content":"&#x524D;&#x8A00;&#x5F00;&#x53D1;&#x677F; STM32H750VET6&#x5148;&#x8BF4;&#x7ED3;&#x8BBA;&#xFF1A;zbar 0.10&#x7F16;&#x8BD1;&#x51FA;&#x7684;&#x6587;&#x4EF6;&#x592A;&#x5927;&#x4E14;&#x6211;&#x7684;boot&#x8DF3;&#x8F6C;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x65E0;&#x6CD5;&#x5728;&#x5F00;&#x53D1;&#x677F;&#x4E0A;&#x8FD0;&#x884C;&#xFF0C;&#x4F46;&#x662F;&#x5728;pc&#x4E0A;&#x8FD0;&#x884C;&#x6CA1;&#x95EE;&#x9898;&#xFF0C;&#x9664;&#x4E86;&#x4E0D;&#x80FD;&#x8BC6;&#x522B;&#x6761;&#x5F62;&#x7801;&#x8FD9;&#x4E00;&#x70B9;&#x3002;&#x4E8E;&#x662F;&#x4F7F;&#x7528;&#x4E86;&#x66F4;&#x8F7B;&#x91CF;&#x7684;quirc&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x80FD;&#x5728;&#x5F00;&#x53D1;&#x677F;&#x4E0A;&#x5B9E;&#x65F6;&#x8BC6;&#x522B;QR&#x7801;&#x4E86;&#x1F606;&#x6240;&#x4EE5;&#x540E;&#x9762;&#x4E3B;&#x8981;&#x662F;&#x4ECB;&#x7ECD;quric\n\n\n&#x4E4B;&#x524D;&#x5728; stm32h750 &#x4E0A;&#x5B9E;&#x73B0;DCMI&#x9A71;&#x52A8;&#x6444;&#x50CF;&#x5934;&#x540E;&#xFF0C;&#x60F3;&#x52A0;&#x5165;&#x4E8C;&#x7EF4;&#x7801;&#x89E3;&#x7801;&#x529F;&#x80FD;&#x3002;&#x672C;&#x6765;&#x662F;&#x79FB;&#x690D;zbar&#xFF0C;&#x4E2D;&#x95F4;&#x51E0;&#x756A;&#x6298;&#x78E8;&#x5728;&#x732B;&#x54AA;&#x5927;&#x4F6C;&#x7684;&#x5D4C;&#x5165;&#x5F0F;&#x673A;&#x5668;&#x89C6;&#x89C9;&#x5E93;&#x4E2D;&#x53D1;&#x73B0;&#x4E86;zbar&#x7684;&#x5B8C;&#x6574;&#x79FB;&#x690D;&#xFF0C;&#x518D;&#x52A0;&#x4E0A;&#x4E4B;&#x524D;&#x975E;&#x6B63;&#x5F0F;&#x7801;&#x519C;&#x6709;&#x5173;&#x4E8E;&#x5728;F4&#x5E73;&#x53F0;&#x7684;&#x79FB;&#x690D;&#xFF0C;&#x5728;&#x6B64;&#x611F;&#x8C22;&#x4E24;&#x4F4D;&#x5927;&#x4F6C;&#x3002;\nquirc&#x79FB;&#x690D;&#x94FE;&#x63A5; &#xFF1A;https://github.com/dlbeer/quirc&#x4E0B;&#x8F7D;&#x540E;&#x6253;&#x5F00;quirc&#x6587;&#x4EF6;&#x5939;&#xFF0C; lib &#x6587;&#x4EF6;&#x5939;&#x662F;&#x4E8C;&#x7EF4;&#x7801;&#x8BC6;&#x522B;&#x7684;&#x6838;&#x5FC3;&#x6E90;&#x7801;&#xFF0C;&#x79FB;&#x690D;&#x65F6;&#x52A1;&#x5FC5; &#x5168;&#x62F7;&#x8D1D;&#x3002;&#x5176;&#x4ED6;&#x6587;&#x4EF6;&#x5939;&#x662F;&#x5728;&#x4E0D;&#x540C;&#x5E73;&#x53F0;&#x7684;&#x793A;&#x4F8B;&#x548C;&#x6D4B;&#x8BD5;&#x6837;&#x4F8B;&#xFF0C;&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x662F;&#x53C2;&#x8003; tests/qrtest.c\n&#x53EF;&#x4EE5;&#x8BA9;AI&#x53C2;&#x8003;&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x6539;&#x6210;&#x4F60;&#x7684;&#x5E73;&#x53F0;&#xFF0C;&#x6216;&#x8005;&#x662F;&#x53C2;&#x8003;:QR_img.h &#x91CC;&#x9762;&#x662F;&#x4EE5;&#x6570;&#x7EC4;&#x65B9;&#x5F0F;&#x5B58;&#x50A8;&#x7684;qr&#x7801;&#x56FE;&#x7247;&#xFF0C;RGB565&#x683C;&#x5F0F;&#xFF0C;quirc.h quirc&#x89E3;&#x7801;&#x7684;&#x6838;&#x5FC3;&#x5934;&#x6587;&#x4EF6;\n#include &quot;QR_img.h&quot;#include &quot;quirc.h&quot;#include &quot;quirctest.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// RGB565&#x8F6C;&#x7070;&#x5EA6;&#x56FE;&#x51FD;&#x6570;unsigned char *rgb565_to_grayscale(const unsigned char *rgb565, int width,                                   int height) {    size_t gray_size = width * height;    unsigned char *gray = (unsigned char *)malloc(gray_size);    if (!gray)        return NULL;    for (int i = 0; i &lt; width * height; i++) {        // &#x4ECE;RGB565&#x63D0;&#x53D6;RGB&#x5206;&#x91CF;        unsigned short pixel =            ((unsigned short)rgb565[i * 2] &lt;&lt; 8) | rgb565[i * 2 + 1];        unsigned char r = (pixel &gt;&gt; 11) &amp; 0x1F;        unsigned char g = (pixel &gt;&gt; 5) &amp; 0x3F;        unsigned char b = pixel &amp; 0x1F;        // &#x8F6C;&#x6362;&#x4E3A;8&#x4F4D;&#x503C;        r = (r * 255) / 31;        g = (g * 255) / 63;        b = (b * 255) / 31;        // &#x8BA1;&#x7B97;&#x7070;&#x5EA6;&#x503C; (&#x6807;&#x51C6;&#x516C;&#x5F0F;: Y = 0.299R + 0.587G + 0.114B)        gray[i] = (unsigned char)((r * 299 + g * 587 + b * 114) / 1000);    }    return gray;}int quirctest(const unsigned char *image_data, int width, int height) {    // &#x8C03;&#x7528;&#x7070;&#x5EA6;&#x8F6C;&#x6362;&#x51FD;&#x6570;    unsigned char *gray_image = rgb565_to_grayscale(image_data, width, height);    if (!gray_image) {        printf(&quot;Failed to convert image to grayscale.\\n&quot;);        return 1;    }    // &#x521D;&#x59CB;&#x5316;&#x89E3;&#x7801;&#x5668;    struct quirc *qr = quirc_new();    if (!qr) {        printf(&quot;Failed to initialize QR decoder.\\n&quot;);        free(gray_image);        return 1;    }    // &#x5C06;&#x7070;&#x5EA6;&#x56FE;&#x50CF;&#x6570;&#x636E;&#x52A0;&#x8F7D;&#x5230;&#x89E3;&#x7801;&#x5668;    if (quirc_resize(qr, width, height) &lt; 0) {        printf(&quot;Failed to resize QR decoder.\\n&quot;);        quirc_destroy(qr);        free(gray_image);        return 1;    }    unsigned char *qr_image = quirc_begin(qr, NULL, NULL);    memcpy(qr_image, gray_image, width * height);    quirc_end(qr);    // &#x8BC6;&#x522B;&#x548C;&#x89E3;&#x7801;&#x4E8C;&#x7EF4;&#x7801;    int count = quirc_count(qr);    if (count &lt;= 0) {        printf(&quot;No QR codes found.\\n&quot;);    } else {        printf(&quot;Found %d QR code(s).\\n&quot;, count);        for (int i = 0; i &lt; count; i++) {            struct quirc_code code;            struct quirc_data data;            quirc_extract(qr, i, &amp;code);            quirc_decode_error_t err = quirc_decode(&amp;code, &amp;data);            if (err == QUIRC_ERROR_DATA_ECC) {                quirc_flip(&amp;code);                err = quirc_decode(&amp;code, &amp;data);            }            if (err) {                printf(&quot;  Decode failed: %s\\n&quot;, quirc_strerror(err));            } else {                printf(&quot;  Decoded data: %s\\n&quot;, data.payload);            }        }    }    // &#x91CA;&#x653E;&#x89E3;&#x7801;&#x5668;    quirc_destroy(qr);    printf(&quot;QR code decoding completed.\\n&quot;);    // &#x91CA;&#x653E;&#x5185;&#x5B58;    free(gray_image);    return 0;}int main() {    // &#x5047;&#x8BBE;&#x56FE;&#x50CF;&#x5BBD;&#x5EA6;&#x548C;&#x9AD8;&#x5EA6;&#x4E3A;150x150    int width = 150;    int height = 150;    // &#x8C03;&#x7528;quirctest&#x51FD;&#x6570;    return quirctest(gImage_QR_img, width, height);}\n\n&#x76EE;&#x524D;&#x6CA1;&#x6709;&#x8BD5;&#x8FC7;&#x4E2D;&#x6587;&#x89E3;&#x7801;\nzbar&#x79FB;&#x690D;&#x6211;&#x6700;&#x5F00;&#x59CB;&#x79FB;&#x690D;zbar&#x5230;pc&#x60F3;&#x76F4;&#x63A5;&#x7528;&#x8BFB;&#x6570;&#x7EC4;&#x56FE;&#x50CF;&#x7684;&#x65B9;&#x5F0F;&#x6765;&#x6D4B;&#x8BD5;&#x89E3;&#x7801;&#x529F;&#x80FD;&#xFF0C;&#x4F46;&#x662F;&#xFF0C;&#x5982;&#x679C;&#x4F60;&#x548C;&#x6211;&#x4E00;&#x6837;&#x662F;win&#x4E0B;&#x7684;mingw&#xFF0C;&#x4E00;&#x5B9A;&#x4F1A;&#x5728; iconv &#x94FE;&#x63A5;&#x5E93;&#x4E0A;&#x5361;&#x4F4F;&#x90A3;&#x4E48;iconv&#x662F;&#x4EC0;&#x4E48;&#x5462;&#xFF0C;&#x8BF7;bing&#x4E00;&#x4E0B;&#x56E0;&#x4E3A;&#x7F51;&#x4E0A;&#x7684;incov&#x94FE;&#x63A5;&#x5E93;&#x5728;mingw&#x4E0B;&#x90FD;&#x4E0D;&#x80FD;&#x7528;&#xFF0C;&#x8981;&#x4E48;&#x6362;&#x5DE5;&#x5177;&#x94FE;&#xFF0C;&#x8981;&#x4E48;&#x5C31;&#x81EA;&#x5DF1;&#x60F3;&#x529E;&#x6CD5;&#x4E0D;&#x4F7F;&#x7528;incov&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x624B;&#x52A8;&#x7F16;&#x7801;&#x800C;&#x4E0D;&#x4F7F;&#x7528;&#x5E93;\n&#x5F00;&#x59CB;&#x79FB;&#x690D;&#x7F51;&#x4E0A;&#x627E;&#x4E00;&#x4EFD;zbar0.10&#x7248;&#x672C;&#x7684;&#xFF0C;&#x7528;&#x4E8E;&#x5D4C;&#x5165;&#x5F0F;&#x7684;&#x57FA;&#x672C;&#x4E0A;&#x90FD;&#x662F;&#x57FA;&#x4E8E;&#x6B64;&#x7248;&#x79FB;&#x690D;&#x7684;&#x6253;&#x5F00;&#x5176;&#x4E2D;&#x7684; zbar &#x6587;&#x4EF6;&#x5939;&#xFF0C;&#x7136;&#x540E;&#x6839;&#x636E;&#x5F00;&#x5934;&#x6211;&#x63A8;&#x8350;&#x7684;&#x4E24;&#x4F4D;&#x5927;&#x4F6C;&#x7684;&#x8FDB;&#x884C;&#x79FB;&#x690D;&#x548C;&#x88C1;&#x526A;&#xFF0C;&#x5176;&#x4E2D;&#x6700;&#x91CD;&#x8981;&#x7684; config.h &#x6587;&#x4EF6;&#xFF0C;&#x56E0;&#x4E3A;&#x9664;&#x4E86;linux&#x4E0B;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;autoconf&#x751F;&#x6210;&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#xFF0C;&#x5176;&#x4ED6;&#x5E73;&#x53F0;&#x5C31;&#x53EA;&#x80FD;&#x62F7;&#x8D1D;&#xFF0C;&#x5F53;&#x7136;&#xFF0C;&#x8FD9;&#x4E24;&#x4F4D;&#x5927;&#x4F6C;&#x7684;&#x6587;&#x7AE0;&#x548C;&#x6E90;&#x7801;&#x4E2D;&#x90FD;&#x6709;&#x5BF9;&#x5E94;&#x7684;&#x90E8;&#x5206;&#xFF0C; &#x8FD8;&#x6709; include/zbar.h &#x4E5F;&#x8981;&#x6DFB;&#x52A0;&#x8FDB;&#x6765;\n&#x4FEE;&#x6539;&#x6E90;&#x7801;&#x505A;&#x5B8C;&#x524D;&#x9762;&#x7684;&#x5C31;&#x53EF;&#x4EE5;&#x5F00;&#x59CB;&#x624B;&#x52A8;&#x7F16;&#x7801;&#xFF0C;&#x8FD9;&#x91CC;&#x6211;&#x63A8;&#x8350;&#x732B;&#x54AA;&#x5927;&#x4F6C;&#x7684;zbar&#x79FB;&#x690D;&#xFF0C;&#x4F60;&#x751A;&#x81F3;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;copy&#x3002;&#x4F46;&#x662F;&#x91CC;&#x9762;&#x6709;&#x4E00;&#x4E9B;&#x5B8F;&#x5B9A;&#x4E49;&#x9700;&#x8981;&#x4FEE;&#x6539;&#xFF0C;&#x4E3B;&#x8981;&#x662F;malloc&#x7B49;&#x7533;&#x8BF7;&#x5185;&#x5B58;&#x7684;&#xFF0C;&#x8FD9;&#x91CC;&#x90FD;&#x968F;&#x4FBF;&#xFF0C;&#x6211;&#x662F;&#x6539;&#x6210;&#x4E86;&#x6807;&#x51C6;c&#x7684;&#x540D;&#x79F0;\n&#x6211;&#x5728;pc&#x4E0A;&#x6D4B;&#x8BD5;&#x65F6;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x8BC6;&#x522B;QR&#x4F46;&#x662F;&#x4E0D;&#x80FD;&#x8BC6;&#x522B;code128&#x7B49;&#x6761;&#x7801;&#xFF0C;&#x6211;&#x4E5F;&#x4E0D;&#x77E5;&#x9053;&#x4E3A;&#x4EC0;&#x4E48;&#x3002;&#x4EA4;&#x53C9;&#x7F16;&#x8BD1;&#x540E;&#x80FD;&#x5360;&#x7528;&#x8FD1;80kb&#x7684;flash&#xFF0C;h750&#x7247;&#x5185;&#x53EA;&#x6709;128kb&#xFF0C;&#x7247;&#x5916;&#x8FD0;&#x884C;&#x53C8;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x8FD9;&#x4E5F;&#x662F;&#x6211;&#x6362;&#x6210;quirc&#x7684;&#x539F;&#x56E0;&#xFF0C;&#x53CD;&#x6B63;&#x53EA;&#x8BC6;&#x522B;QR&#x7801;\n&#x4FEE;&#x6539;&#x7684;&#x6587;&#x4EF6;&#x4E3B;&#x8981;&#x662F;&#x96C6;&#x4E2D;&#x5728; qrcode/qrdectxt.c &#xFF0C;&#x4E0D;&#x518D;&#x4F7F;&#x7528;iconv&#x6765;&#x8FDB;&#x884C;&#x5B57;&#x7B26;&#x7F16;&#x7801;&#x4E4B;&#x95F4;&#x8F6C;&#x6362;&#xFF0C;&#x800C;&#x662F;&#x624B;&#x52A8;&#x6307;&#x5B9A;unicode&#x8F6C;gb2312&#x5177;&#x4F53;&#x4FEE;&#x6539;&#x5728;&#x732B;&#x54AA;&#x5927;&#x4F6C;&#x7684;&#x5E93;&#x4E2D;\n&#x5B8C;\n","categories":["STM32"],"tags":["STM32","QRencode"]},{"title":"嵌入式boot开发（一）","url":"/2025/09/18/%E5%B5%8C%E5%85%A5%E5%BC%8Fboot%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/","content":"&#x524D;&#x8A00;&#x5728;&#x5D4C;&#x5165;&#x5F0F;&#x5F00;&#x53D1;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x5C06;&#x7A0B;&#x5E8F;&#x653E;&#x5728;&#x5916;&#x90E8;flash&#xFF0C;&#x8FDC;&#x7A0B;&#x5347;&#x7EA7;&#xFF0C;&#x79BB;&#x7EBF;&#x70E7;&#x5F55;&#x7B49;&#x7B49;&#xFF0C;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#x5C31;&#x9700;&#x8981;&#x4E00;&#x4E2A;bootloader&#x7A0B;&#x5E8F;&#x6765;&#x5F15;&#x5BFC;&#x7A0B;&#x5E8F;&#x7684;&#x52A0;&#x8F7D;&#x3002;boot&#x8BD1;&#x4E3A;&#x5F15;&#x5BFC;&#xFF0C;loader&#x8BD1;&#x4E3A;&#x52A0;&#x8F7D;&#x3002;&#x672C;&#x7CFB;&#x5217;&#x6587;&#x7AE0;&#x65E8;&#x5728;&#x8BB0;&#x5F55;&#x5B66;&#x4E60;&#x7F16;&#x5199;boot&#x7A0B;&#x5E8F;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5E73;&#x53F0;&#x4E3A;STM32H750VBT6&#xFF0C;HAL&#x5E93;&#x3002;&#x5176;&#x4ED6;&#x5E73;&#x53F0;&#x80AF;&#x7565;&#x6709;&#x4E0D;&#x540C;&#xFF0C;&#x4F46;&#x662F;&#x60F3;&#x6CD5;&#x662F;&#x4E00;&#x81F4;&#x7684;\nbootloader&#x7528;&#x6765;&#x505A;&#x4EC0;&#x4E48;boot&#x52A0;&#x8F7D;&#x7A0B;&#x5E8F;&#xFF0C;&#x81EA;&#x7136;&#x5C31;&#x9700;&#x8981;&#x77E5;&#x9053;&#x7A0B;&#x5E8F;&#x5728;&#x54EA;&#x91CC;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x6765;&#x68C0;&#x6D4B;app&#x662F;&#x5426;&#x88AB;&#x5199;&#x5165;&#x5230;&#x6307;&#x5B9A;&#x5730;&#x70B9; is_application_valid() ,&#x5982;&#x679C;app&#x5730;&#x5740;&#x6709;&#x7A0B;&#x5E8F;&#xFF0C;&#x5219; jump_to_application() &#xFF0C;&#x5426;&#x5219;&#x5C31;&#x8FDB;&#x5165; bootloader_mode() &#x3002;\nboot&#x662F;&#x4E0A;&#x7535;&#x540E;&#x6267;&#x884C;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7A0B;&#x5E8F;&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x7684;&#x5730;&#x5740;&#x662F;&#x56FA;&#x5B9A;&#x7684;&#xFF0C;&#x4F46;&#x662F;app&#x7A0B;&#x5E8F;&#x9700;&#x8981;&#x6211;&#x4EEC;&#x624B;&#x52A8;&#x6307;&#x5B9A;&#x4E00;&#x4E2A;&#x5730;&#x5740; APP_ADDRESS &#xFF0C;&#x6211;&#x6682;&#x65F6;&#x5C06;app&#x653E;&#x5728;0x08010000&#x3002;\nboot&#x90E8;&#x5206;&#x5927;&#x6982;&#x770B;&#x8D77;&#x6765;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF1A;\n//bootloaderint main(void) {    HAL_Init();    SystemClock_Config();    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    LED_On(&amp;LED);    if (is_application_valid()) {        jump_to_application();    } else {        bootloader_mode();    }    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {    }    /* USER CODE END 3 */}\n\n&#x68C0;&#x6D4B;app&#xFF0C;&#x8DF3;&#x8F6C;&#xFF0C;boot&#x6A21;&#x5F0F;&#x4E09;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x5B9E;&#x73B0;\n&#x68C0;&#x6D4B;app&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x68C0;&#x6D4B;&#x6808;&#x9876;&#x6307;&#x9488;&#x4F7F;&#x5176;&#x4E0D;&#x8981;&#x8D8A;&#x754C;&#x3002; &#x68C0;&#x6D4B; Reset_Handler &#x7A0B;&#x5E8F;&#x6307;&#x9488;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x56E0;&#x4E3A;&#x7A0B;&#x5E8F;&#x9ED8;&#x8BA4;&#x5165;&#x53E3;&#x70B9;&#x662F;&#x5B83;&#x3002;\n&#x8DF3;&#x8F6C;app&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x5173;&#x95ED;&#x4E2D;&#x65AD;&#xFF0C;&#x8BBE;&#x7F6E;&#x6808;&#x9876;&#x6307;&#x9488;&#xFF0C;&#x91CD;&#x8BBE;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x7684;&#x504F;&#x79FB;&#x503C;&#xFF0C;&#x8DF3;&#x8F6C;&#x5230; Reset_Handler &#xFF0C; Reset_Handler &#x7684;&#x5185;&#x5BB9;&#x5728;&#x542F;&#x52A8;&#x6587;&#x4EF6; startup_stm32h750xx.s&#x4E2D;&#xFF0C;&#x5176;&#x529F;&#x80FD;&#x4E3B;&#x8981;&#x662F;&#x521D;&#x59CB;&#x5316;&#x3002;\n\n&#x6808;&#x9876;&#x6307;&#x9488;&#x548C; Reset_Handler &#x5728;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x7684;&#x5F00;&#x5934;&#x548C;&#x504F;&#x79FB;4&#x5B57;&#x8282;&#x7684;&#x5730;&#x65B9;&#x800C;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x5728;&#x7A0B;&#x5E8F;&#x7684;&#x5F00;&#x5934;&#xFF0C;&#x56E0;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x6765;&#x8BBF;&#x95EE;&#x8FD9;&#x4E24;&#x4E2A;&#x5730;&#x5740;\n// &#x8FD9;&#x4E0D;&#x662F;&#x5904;&#x7406;&#x5668;&#x8981;&#x6C42;&#x7684;&#xFF0C;&#x800C;&#x662F;&#x6211;&#x4EEC;&#x4E3A;&#x4E86;&#x65B9;&#x4FBF;&#x8BBF;&#x95EE;&#x800C;&#x5B9A;&#x4E49;&#x7684;typedef struct {    uint32_t stack_ptr;      // &#x504F;&#x79FB;0x00: &#x521D;&#x59CB;&#x6808;&#x6307;&#x9488;    pFunction reset_handler; // &#x504F;&#x79FB;0x04: &#x590D;&#x4F4D;&#x5904;&#x7406;&#x7A0B;&#x5E8F;    // &#x540E;&#x7EED;&#x8FD8;&#x6709;&#x5176;&#x4ED6;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#xFF0C;&#x4F46;Bootloader&#x901A;&#x5E38;&#x53EA;&#x9700;&#x8981;&#x524D;&#x4E24;&#x4E2A;} VectorTable_t;\n\nis_application_valid()\n&#x8FD9;&#x91CC;&#x6211;&#x7684;ram&#x5927;&#x5C0F;&#x662F;0x20000&#x4E5F;&#x5C31;&#x662F;128kb\nreset_handler&#x5730;&#x5740;&#x53D8;&#x91CF;&#x7EDD;&#x5BF9;&#x5927;&#x4E8E;app&#x8D77;&#x59CB;&#x5730;&#x5740;&#xFF0C;&#x4F46;&#x662F;&#x5C0F;&#x4E8E;flash&#x6700;&#x5927;&#x503C;\n&#x5982;&#x679C;flash&#x88AB;&#x64E6;&#x9664;&#x5219;&#x5176;&#x503C;&#x4E3A;&#x5168;F/0&#xFF0C;&#x901A;&#x8FC7;&#x68C0;&#x6D4B;app&#x5730;&#x5740;&#x540E;16&#x4E2A;&#x5B57;&#x6765;&#x5224;&#x65AD;app&#x5730;&#x5740;&#x662F;&#x5426;&#x6709;&#x7A0B;&#x5E8F;\n\nuint8_t is_application_valid(void) {    //&#x5C06;app&#x5730;&#x5740;&#x5F3A;&#x884C;&#x8F6C;&#x6362;&#x4E3A;&#x6307;&#x9488;&#xFF0C;&#x7136;&#x540E;&#x901A;&#x8FC7;&#x6307;&#x9488;&#x8BBF;&#x95EE;    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // check stack ptr is in valid addr scoop    // stm32 RAM usually start 0x2000 0000    if ((app_vector_table-&gt;stack_ptr &lt; 0x20000000) ||        (app_vector_table-&gt;stack_ptr &gt; 0x20020000)) {        return 0;    }    // check reset handle ptr is in valid addr scoop    uint32_t reset_handler = (uint32_t)app_vector_table-&gt;reset_handler;    if (reset_handler &lt; APP_ADDRESS ||        reset_handler &gt; FLASH_END) { /* &#x5FC5;&#x987B;&#x5728;&#x5E94;&#x7528;&#x7A0B;&#x5E8F; Flash &#x533A;&#x57DF;&#x5185; */        return 0;    }    // check irq table is 0 or 1 (esare state)    uint32_t *app_start = (uint32_t *)APP_ADDRESS;    for (int i = 0; i &lt; 16; i++) // check the first 16 word    {        if (app_start[i] != 0xFFFFFFFF &amp;&amp; app_start[i] != 0x00000000) {            // not empty data, app exit            // printf(&quot;Application validation passed\\r\\n&quot;);            return 1;        }    }    return 0;}\n\njump_to_application()&#x8DF3;&#x8F6C;app&#x65F6;&#x9700;&#x8981;&#x5148;&#x5173;&#x95ED;&#x4E2D;&#x65AD;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x8FD9;&#x91CC;&#x5DF2;&#x7ECF;&#x5173;&#x95ED;&#x4E2D;&#x65AD;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;app&#x51FD;&#x6570;&#x6267;&#x884C;&#x65F6;&#x4E00;&#x5B9A;&#x8981;&#x6253;&#x5F00;\nvoid jump_to_application(void) {    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // disabel irq    __disable_irq();    // set top stack pointer    __set_MSP(app_vector_table-&gt;stack_ptr);    // set irq table offset    SCB-&gt;VTOR = APP_ADDRESS;    // jump to app reset handle programe    app_vector_table-&gt;reset_handler();    // if jump defeated, programe don&apos;t run to here    while (1)        ;}\n\nbootloader_mode()&#x56E0;&#x4E3A;&#x53EA;&#x662F;&#x5B9E;&#x73B0;&#x7B80;&#x5355;&#x7684;&#x7A0B;&#x5E8F;&#x8DF3;&#x8F6C;&#xFF0C;&#x6240;&#x4EE5;boot&#x6A21;&#x5F0F;&#x53EA;&#x6709;&#x4E00;&#x4E2A;1s&#x7684;&#x706F;&#x540E;&#x7EED;&#x53EF;&#x4EE5;&#x6539;&#x4E3A;&#x624B;&#x52A8;&#x8FDB;&#x5165;boot&#x6A21;&#x5F0F;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x5176;&#x4E2D;&#x5B9E;&#x73B0;&#x56FA;&#x4EF6;&#x66F4;&#x65B0;&#x7B49;&#x529F;&#x80FD;\nvoid bootloader_mode(void) {    // app addr is no programe    while (1) {        LED_Blink(&amp;LED, 1000);    }}\n\n&#x7F16;&#x8BD1;boot&#x76F4;&#x63A5;&#x7F16;&#x8BD1;&#xFF0C;&#x4E0D;&#x8981;&#x4FEE;&#x6539;&#x4EFB;&#x4F55;&#x8BBE;&#x7F6E;&#xFF0C;&#x5C31;&#x548C;&#x5E73;&#x5E38;&#x7F16;&#x8BD1;&#x88F8;&#x673A;&#x7A0B;&#x5E8F;&#x90A3;&#x6837;\napp&#x8BE5;&#x505A;&#x4EC0;&#x4E48;?&#x9884;&#x5B9A;&#x4E49;app&#x5730;&#x5740; #define APP_ADDRESS 0x08010000\napp&#x7A0B;&#x5E8F;app&#x7A0B;&#x5E8F;&#x9700;&#x8981;&#x5728;&#x4E3B;&#x51FD;&#x6570;&#x4E00;&#x5F00;&#x59CB;&#x5C31;&#x6267;&#x884C; SCB-&gt;VTOR = APP_ADDRESS;\n&#x4E3A;&#x4EC0;&#x4E48;&#xFF0C;&#x6211;&#x4EEC;&#x4E0D;&#x662F;&#x5728; jump_to_application() &#x51FD;&#x6570;&#x4E2D;&#x6267;&#x884C;&#x8FC7;&#x4E00;&#x6B21;&#x4E86;&#x5417;&#x56E0;&#x4E3A;VTOR&#xFF08;Vector Table Offset Register&#xFF09;&#x662F;&#x4E00;&#x4E2A;&#x6613;&#x5931;&#x6027;&#x5BC4;&#x5B58;&#x5668;&#xFF0C;&#x8FD9;&#x610F;&#x5473;&#x7740;&#xFF1A;\n\n&#x590D;&#x4F4D;&#x4F1A;&#x6E05;&#x9664;VTOR&#xFF1A;&#x4EFB;&#x4F55;&#x5F62;&#x5F0F;&#x7684;&#x7CFB;&#x7EDF;&#x590D;&#x4F4D;&#xFF08;&#x5305;&#x62EC;&#x8F6F;&#x4EF6;&#x590D;&#x4F4D;&#xFF09;&#x90FD;&#x4F1A;&#x5C06;VTOR&#x91CD;&#x7F6E;&#x4E3A;&#x9ED8;&#x8BA4;&#x503C;&#xFF08;&#x901A;&#x5E38;&#x662F;0&#xFF09;\n&#x7535;&#x6E90;&#x5468;&#x671F;&#x4F1A;&#x6E05;&#x9664;VTOR&#xFF1A;&#x65AD;&#x7535;&#x518D;&#x4E0A;&#x7535;&#x4E5F;&#x4F1A;&#x91CD;&#x7F6E;VTOR\n&#x4E0D;&#x662F;&#x6C38;&#x4E45;&#x6027;&#x8BBE;&#x7F6E;&#xFF1A;VTOR&#x4E0D;&#x4F1A;&#x5728;&#x590D;&#x4F4D;&#x4E4B;&#x95F4;&#x4FDD;&#x6301;&#x5176;&#x503C;\n\nint main(void) {    /* USER CODE BEGIN 1 */    SCB-&gt;VTOR = APP_ADDRESS;    __enable_irq();    /* USER CODE END 1 *    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* Configure the system clock */    SystemClock_Config();    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    printf(&quot;test&quot;);    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        LED_Blink(&amp;LED, 100);        /* USER CODE BEGIN 3 */    }    /* USER CODE END 3 */}\n\n&#x8FDB;&#x5165;app&#x7A0B;&#x5E8F;&#x540E;&#xFF0C;led&#x706F;&#x5FEB;&#x95EA;&#xFF0C;&#x4E0E;boot&#x7684;&#x6162;&#x95EA;&#x5206;&#x5F00;\n&#x7F16;&#x8BD1;&#x94FE;&#x63A5;&#x6587;&#x4EF6;&#x4FEE;&#x6539;&#x5982;&#x679C;&#x4F60;&#x4F7F;&#x7528;&#x7684;&#x662F;armgcc&#x7F16;&#x8BD1;&#x94FE;&#xFF0C;&#x5E76;&#x4F7F;&#x7528;.ld&#x6587;&#x4EF6;&#x7EC4;&#x7EC7;&#x7F16;&#x8BD1;&#xFF0C;&#x5C31;&#x9700;&#x8981;&#x5728;cubemx&#x751F;&#x6210;&#x7684; STM32H750XX_FLASH.ld &#x6587;&#x4EF6;&#x4E2D;&#x4FEE;&#x6539;\n/* Specify the memory areas */MEMORY{DTCMRAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 128KRAM (xrw)      : ORIGIN = 0x24000000, LENGTH = 512KRAM_D2 (xrw)      : ORIGIN = 0x30000000, LENGTH = 288KRAM_D3 (xrw)      : ORIGIN = 0x38000000, LENGTH = 64KITCMRAM (xrw)      : ORIGIN = 0x00000000, LENGTH = 64KFLASH (rx)      : ORIGIN = 0x08010000, LENGTH = 128K  //&#x91CD;&#x70B9;&#xFF0C;&#x4E0E;APP_ADDRESS&#x4FDD;&#x6301;&#x4E00;&#x81F4;&#xFF0C;&#x6CE8;&#x610F;ram&#x548C;flash&#x5927;&#x5C0F;}\n\nkeil&#x8BBE;&#x7F6E;&#x5982;&#x679C;&#x662F;keil&#xFF0C;&#x9B54;&#x672F;&#x68D2;-&gt;target &#x4E0B;&#x65B9;&#x6709;&#x8BBE;&#x7F6E;ROM&#x7684;&#x8D77;&#x59CB;&#x5730;&#x5740;&#xFF0C;&#x8BBE;&#x7F6E;&#x4E3A;APP_ADDRESS&#x7684;&#x503C;\n&#x70E7;&#x5F55;&#x5148;&#x70E7;&#x5F55;boot&#xFF0C;led&#x7F13;&#x6162;&#x95EA;&#x70C1;&#x5219;&#x8BF4;&#x660E;boot&#x8FD0;&#x884C;&#x6B63;&#x5E38;&#x518D;&#x70E7;&#x5F55;app&#xFF0C;led&#x5FEB;&#x95EA;&#x8BF4;&#x660E;app&#x8FD0;&#x884C;&#x6B63;&#x5E38;&#x590D;&#x4F4D;&#x4E00;&#x4E0B;&#xFF0C;led&#x5FEB;&#x95EA;\nopenocd&#x6CA1;&#x8BD5;&#x8FC7;&#xFF0C;&#x4F46;&#x662F;openocd&#x9ED8;&#x8BA4;&#x5168;&#x64E6;&#x9664;flash&#xFF0C;&#x9700;&#x8981;&#x4FEE;&#x6539;&#x8BBE;&#x7F6E;&#xFF0C;&#x4F7F;&#x4E4B;&#x53EA;&#x64E6;&#x9664;&#x5199;&#x5165;&#x7684;&#x7A7A;&#x95F4;\nSTM32Cubeprogrammer&#x5728;&#x4E0B;&#x8F7D;&#x65F6;&#xFF0C;&#x52FE;&#x9009;&#x5728;&#x7F16;&#x7A0B;&#x4E4B;&#x524D;&#x4E0D;&#x8FDB;&#x884C;&#x95EA;&#x5B58;&#x64E6;&#x9664;&#x3002;&#x70E7;&#x5F55;&#x540E;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8BBE;&#x5907;&#x5185;&#x5B58;&#x67E5;&#x770B;&#x7684;&#x5DE5;&#x5177;&#x67E5;&#x770B;boot&#x7A0B;&#x5E8F;(&#x4F4D;&#x4E8E;0x0800 0000)&#x548C;app&#x7A0B;&#x5E8F;(0x0801 0000)&#x6709;&#x6CA1;&#x6709;&#x7A0B;&#x5E8F;&#x5199;&#x5165;\n&#x8865;&#x5145;\nled&#x9A71;&#x52A8;&#x968F;&#x4FBF;&#x5199;&#x4E00;&#x4E0B;&#x5C31;&#x884C;&#xFF0C;&#x95EA;&#x70C1;&#x7528;&#x5EF6;&#x8FDF;&#x51FD;&#x6570;\n&#x6211;&#x662F;armgcc&#x7F16;&#x8BD1;&#x94FE;&#xFF0C;&#x4F46;&#x662F;keil&#x5E94;&#x8BE5;&#x662F;&#x4E00;&#x6837;&#x7684;\n&#x4E00;&#x5B9A;&#x4E00;&#x5B9A;&#x8981;&#x8BB0;&#x4F4F;&#xFF0C;app&#x7F16;&#x8BD1;&#x65F6;&#x8981;&#x5148;&#x4FEE;&#x6539;flash&#x8D77;&#x59CB;&#x5730;&#x5740;\n\n&#x7A0B;&#x5E8F;&#x603B;&#x89C8;&#x901A;&#x8FC7;&#x7F16;&#x8BD1;&#x5F00;&#x5173;&#x6765;&#x63A7;&#x5236;&#x7F16;&#x8BD1;&#x51FA;&#x4EC0;&#x4E48;&#x7A0B;&#x5E8F;&#xFF0C;&#x65B9;&#x4FBF;&#x6D4B;&#x8BD5;\n/* USER CODE BEGIN Header *//** ****************************************************************************** * @file           : main.c * @brief          : Main program body ****************************************************************************** * @attention * * Copyright (c) 2025 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS-IS. * ****************************************************************************** *//* USER CODE END Header *//* Includes ------------------------------------------------------------------*/#include &quot;main.h&quot;#include &quot;gpio.h&quot;#include &quot;quadspi.h&quot;/* Private includes ----------------------------------------------------------*//* USER CODE BEGIN Includes */#include &quot;key_driver.h&quot;#include &quot;led_driver.h&quot;#include &lt;stdio.h&gt;/* USER CODE END Includes *//* Private typedef -----------------------------------------------------------*//* USER CODE BEGIN PTD *//* USER CODE END PTD *//* Private define ------------------------------------------------------------*//* USER CODE BEGIN PD */#define BOOT// #define APP#define APP_ADDRESS 0x08010000/* USER CODE END PD *//* Private macro -------------------------------------------------------------*//* USER CODE BEGIN PM */typedef void (*pFunction)(void);typedef struct {    uint32_t stack_ptr;    pFunction reset_handler;} VectorTable_t;/* USER CODE END PM *//* Private variables ---------------------------------------------------------*//* USER CODE BEGIN PV */LED_Device_t LED;KEY_Device_t K1;/* USER CODE END PV *//* Private function prototypes -----------------------------------------------*/void SystemClock_Config(void);static void MPU_Config(void);/* USER CODE BEGIN PFP */uint8_t is_application_valid(void);void jump_to_application(void);void bootloader_mode(void);/* USER CODE END PFP *//* Private user code ---------------------------------------------------------*//* USER CODE BEGIN 0 *//* USER CODE END 0 */#if defined(BOOT)// start:0x0800 0000 size:0x20000/** * @brief  The application entry point. * @retval int */int main(void) {    /* USER CODE BEGIN 1 */    /* USER CODE END 1 */    /* MPU     * Configuration--------------------------------------------------------*/    // MPU_Config();    /* MCU     * Configuration--------------------------------------------------------*/    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* USER CODE BEGIN Init */    /* USER CODE END Init */    /* Configure the system clock */    SystemClock_Config();    /* USER CODE BEGIN SysInit */    /* USER CODE END SysInit */    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    printf(&quot;test&quot;);    LED_On(&amp;LED);    if (is_application_valid()) {        jump_to_application();    } else {        bootloader_mode();    }    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        /* USER CODE BEGIN 3 */    }    /* USER CODE END 3 */}#endif#if defined(APP)// start:0x0801 0000 size:0x10000/** * @brief  The application entry point. * @retval int */int main(void) {    /* USER CODE BEGIN 1 */    SCB-&gt;VTOR = APP_ADDRESS;    __enable_irq();    /* USER CODE END 1 */    /* MPU     * Configuration--------------------------------------------------------*/    // MPU_Config();    /* MCU     * Configuration--------------------------------------------------------*/    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* USER CODE BEGIN Init */    /* USER CODE END Init */    /* Configure the system clock */    SystemClock_Config();    /* USER CODE BEGIN SysInit */    /* USER CODE END SysInit */    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    printf(&quot;test&quot;);    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        LED_Blink(&amp;LED, 100);        /* USER CODE BEGIN 3 */    }    /* USER CODE END 3 */}#endif/** * @brief System Clock Configuration * @retval None */void SystemClock_Config(void) {    RCC_OscInitTypeDef RCC_OscInitStruct = {0};    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};    /** Supply configuration update enable     */    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);    /** Configure the main internal regulator output voltage     */    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {    }    /** Initializes the RCC Oscillators according to the specified parameters     * in the RCC_OscInitTypeDef structure.     */    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;    RCC_OscInitStruct.HSEState = RCC_HSE_ON;    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;    RCC_OscInitStruct.PLL.PLLM = 5;    RCC_OscInitStruct.PLL.PLLN = 160;    RCC_OscInitStruct.PLL.PLLP = 2;    RCC_OscInitStruct.PLL.PLLQ = 2;    RCC_OscInitStruct.PLL.PLLR = 2;    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;    RCC_OscInitStruct.PLL.PLLFRACN = 0;    if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) {        Error_Handler();    }    /** Initializes the CPU, AHB and APB buses clocks     */    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |                                  RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;    if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {        Error_Handler();    }}/* USER CODE BEGIN 4 */uint8_t is_application_valid(void) {    // RAM_size = 20000; // DTCMRAM    // FLASH_size = 20000;    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // check stack ptr is in valid addr scoop    // stm32 RAM usually start 0x2000 0000    if ((app_vector_table-&gt;stack_ptr &lt; 0x20000000) ||        (app_vector_table-&gt;stack_ptr &gt; 0x20020000)) {        return 0;    }    // check reset handle ptr is in valid addr scoop    uint32_t reset_handler = (uint32_t)app_vector_table-&gt;reset_handler;    if (reset_handler &lt; APP_ADDRESS ||        reset_handler &gt; FLASH_END) { /* &#x5FC5;&#x987B;&#x5728;&#x5E94;&#x7528;&#x7A0B;&#x5E8F; Flash &#x533A;&#x57DF;&#x5185; */        return 0;    }    // check irq table is 0 or 1 (esare state)    uint32_t *app_start = (uint32_t *)APP_ADDRESS;    for (int i = 0; i &lt; 16; i++) // check the first 16 word    {        if (app_start[i] != 0xFFFFFFFF &amp;&amp; app_start[i] != 0x00000000) {            // not empty data, app exit            // printf(&quot;Application validation passed\\r\\n&quot;);            return 1;        }    }    return 0;}void jump_to_application(void) {    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // disabel irq    __disable_irq();    // set top stack pointer    __set_MSP(app_vector_table-&gt;stack_ptr);    // set irq table offset    SCB-&gt;VTOR = APP_ADDRESS;    // jump to app reset handle programe    app_vector_table-&gt;reset_handler();    // if jump defeated, programe don&apos;t run to here    while (1)        ;}void bootloader_mode(void) {    // app addr is no programe    while (1) {        LED_Blink(&amp;LED, 1000);    }}/* USER CODE END 4 *//* MPU Configuration */void MPU_Config(void) {    MPU_Region_InitTypeDef MPU_InitStruct = {0};    /* Disables the MPU */    HAL_MPU_Disable();    /** Initializes and configures the Region and the memory to be protected     */    MPU_InitStruct.Enable = MPU_REGION_ENABLE;    MPU_InitStruct.Number = MPU_REGION_NUMBER0;    MPU_InitStruct.BaseAddress = 0x0;    MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;    MPU_InitStruct.SubRegionDisable = 0x87;    MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;    MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;    MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;    MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;    MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;    MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;    HAL_MPU_ConfigRegion(&amp;MPU_InitStruct);    /* Enables the MPU */    HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);}/** * @brief  This function is executed in case of error occurrence. * @retval None */void Error_Handler(void) {    /* USER CODE BEGIN Error_Handler_Debug */    /* User can add his own implementation to report the HAL error return state     */    __disable_irq();    while (1) {    }    /* USER CODE END Error_Handler_Debug */}#ifdef USE_FULL_ASSERT/** * @brief  Reports the name of the source file and the source line number *         where the assert_param error has occurred. * @param  file: pointer to the source file name * @param  line: assert_param error line source number * @retval None */void assert_failed(uint8_t *file, uint32_t line) {    /* USER CODE BEGIN 6 */    /* User can add his own implementation to report the file name and line       number, ex: printf(&quot;Wrong parameters value: file %s on line %d\\r\\n&quot;,       file, line) */    /* USER CODE END 6 */}#endif /* USE_FULL_ASSERT */\n","categories":["Bootloader"],"tags":["STM32","BootLoader"]}]