[{"title":"嵌入式驱动开发 记录驱动ST7735过程","url":"/2025/05/09/development%20of%20the%20st7735%20driver/","content":"前言寒假回家没事做，特意带了一块1.8寸的TFT屏来练习驱动开发，驱动为ST7735，主控为是RCT6。用了三天加上查阅网上资料，算是磕磕绊绊的把驱动写完了。把开发过程中的过程和问题记录一下，做个备忘。\nST7735介绍ST7735的介绍网上非常多，我就不再重复了。对于ST7735，屏幕的显示原理不是我们应该深究的地方。只谈应用，我个人觉得其内部的RAM（姑且这么称呼）很有意思，还有写入指令一定要仔细，以及ST7735的是在上升沿读入指令数据，这点非常重要，后文会提到。\n硬件spi驱动驱动ST7735的过程也是学习配置spi的过程，所以我选择使用硬件spi。驱动屏幕不需要读数据，用不到MISO线。\n引脚定义\n\n\nGPIO\nST7735\n说明\n\n\n\nPA7\nSDA\n数据写入\n\n\nPA5\nSCL\n时钟\n\n\nPA4\nCS\n片选， 0选中 1忽略\n\n\nPC4\nRESET\n硬件复位\n\n\nPC5\nDC\n数据命令选择，0写命令 1写数据\n\n\nBLK引脚接高即可\n初始化spiSPI_InitStr.SPI_BaudRatePrescaler   = SPI_BaudRatePrescaler_2;// 使分频值达到最大SPI_InitStr.SPI_CPHA\t\t\t    = SPI_CPHA_2Edge;\t\t  // 上升沿有效SPI_InitStr.SPI_CPOL\t\t\t\t= SPI_CPOL_High;\t\t  // 低电平有效,空闲时为高SPI_InitStr.SPI_CRCPolynomial\t    = 7;\t\t\t\t\t  // 无 CRC 校验SPI_InitStr.SPI_DataSize\t\t\t= SPI_DataSize_8b;\t\t  // 发送字长为 8 位SPI_InitStr.SPI_Direction\t\t    = SPI_Direction_1Line_Tx; // 方向为发送SPI_InitStr.SPI_FirstBit\t\t\t= SPI_FirstBit_MSB;\t\t  // 高位先行SPI_InitStr.SPI_Mode\t\t\t\t= SPI_Mode_Master;\t\t  // 主机模式SPI_InitStr.SPI_NSS\t\t\t\t    = SPI_NSS_Soft;\t\t\t  // 软件控制\nCPHA控制在那个（第一or第二）边沿发送CPOL控制spi空闲时的状态（高or低）模式0 ：CPOL设置空闲时为低，当要传数据时MOSI拉高再拉低完成一位数据传输，上升沿为第一个边沿，也就是CPHA设置为1edge。模式3 : CPOL设置空闲时为高，当要传数据时MOSI拉低再拉高完成一位数据传输，上升沿为第二个边沿，也就是CPHA设置为2edge。\n\nST7735要求上升沿接收，也就是将SPI配置为模式0和模式3，如下图。\n\n（ST7735数据手册104页）\n在编写发送函数时要注意：对st7735读写都需要在片选信号拉低的情况下进行，不然st7735会忽略时钟SCL信号也就是说，不论读写都需要先将CS置0，然后再根据读写情况对DC置复位，读写结束后将CS拉高，详情可参考下面的发送函数\nspi写数据函数：\nenum TFT_DATA_CMD&#123;\tTFT_DC_CMD=0,\tTFT_DC_DATA=1&#125;;void SPI1_WriteData(uint8_t data)&#123;\tuint16_t timeout=0;\twhile(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET)&#123;\t//发送缓冲区为空时（TXE=1）才可以写入\t\tif(++timeout &gt; 200)\t\t\t\t\t\t\t\t\t\t//超时200直接退出\t\t\treturn;\t&#125;\tSPI_I2S_SendData(SPI1,data);&#125;void TFT_ST7735_Write(int c_d,uint8_t data)&#123;\tTFT_DC = c_d;\tSPI_CS = 0;\tSPI1_WriteData(data);\tSPI_CS = 1;&#125;\n\n\nST7735初始化网上初始化命令的教程有很多，直接照抄即可，下为我的配置：\nvoid TFT_ST7735_Config(void)&#123;\tTFT_ST7735_Reset();\tTFT_ST7735_Write(TFT_DC_CMD,TFT_SLPOUT);\tdelay_ms(120);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR2);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR3);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\t//===============inversion of control=============\tTFT_ST7735_Write(TFT_DC_CMD, TFT_INVCRT);\tTFT_ST7735_Write(TFT_DC_DATA, 0x03);\t//===============power set========================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x28);\tTFT_ST7735_Write(TFT_DC_DATA, 0x08);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\t\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR2);\tTFT_ST7735_Write(TFT_DC_DATA, 0xC0);\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR3);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR4);\tTFT_ST7735_Write(TFT_DC_DATA, 0x8D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2A);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR5);\tTFT_ST7735_Write(TFT_DC_DATA, 0x8D);\tTFT_ST7735_Write(TFT_DC_DATA, 0xEE);\t//===============vcom set=========================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_VMCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x1A);\t\t//===============scanning direction set===========\t\tif(TFT_DIRECTION==0)\t\tTFT_ST7735_SetScanDirection(0x00);//显示方向选择\telse if(TFT_DIRECTION==1)\tTFT_ST7735_SetScanDirection(0xC0);\telse if(TFT_DIRECTION==2)\tTFT_ST7735_SetScanDirection(0xA0);\telse\t\t\t\t\t\tTFT_ST7735_SetScanDirection(0x70);\t\t//===============gamma sequence set===============\tTFT_ST7735_Write(TFT_DC_CMD, TFT_GMCTRP1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x22);\tTFT_ST7735_Write(TFT_DC_DATA, 0x07);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2E);\tTFT_ST7735_Write(TFT_DC_DATA, 0x30);\tTFT_ST7735_Write(TFT_DC_DATA, 0x25);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x28);\tTFT_ST7735_Write(TFT_DC_DATA, 0x26);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2E);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\tTFT_ST7735_Write(TFT_DC_DATA, 0x01);\tTFT_ST7735_Write(TFT_DC_DATA, 0x03);\tTFT_ST7735_Write(TFT_DC_DATA, 0x13);\tTFT_ST7735_Write(TFT_DC_CMD, TFT_GMCTRN1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x16);\tTFT_ST7735_Write(TFT_DC_DATA, 0x06);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x26);\tTFT_ST7735_Write(TFT_DC_DATA, 0x23);\tTFT_ST7735_Write(TFT_DC_DATA, 0x27);\tTFT_ST7735_Write(TFT_DC_DATA, 0x27);\tTFT_ST7735_Write(TFT_DC_DATA, 0x25);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3B);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\tTFT_ST7735_Write(TFT_DC_DATA, 0x01);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x13);\t//===============color format set=================\tTFT_ST7735_SetColorFormat(0x05);\t//===============display on=======================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_DISPON);&#125;\n踩坑记录网上初始化命令的教程有很多，我主要说一下我在初始化中有过疑惑的几个点\n\n0x36hMADCTL命令（ST7735数据手册142页）spi数据高位先行，RGB位设置为0选择以 “RGB” 的顺序读入颜色数据\n\n初始化成功后花屏ST7735的frame memory（显存）上电后为随机值，故初始化后花屏，全屏填充白色就可以了ST7735数据手册89页）\n\n\n","categories":["STM32"],"tags":["STM32","笔记","ST7735驱动"]},{"title":"FreeRTOS备忘","url":"/2025/05/26/FreeRTOS%E5%A4%87%E5%BF%98/","content":"前言本文章用于记录学习FreeRTOS中使用过的函数，功能等内容，目的是为了方便自己快速查函数用法，归档和踩坑记录。\n\n文章主要分为以下几个板块：任务管理，队列机制，中断管理（待补充…）每个板块的大致组织结构为:1.函数名称2.函数参数3.函数作用4.函数注意及踩坑\n\n任务管理这里主要介绍FreeRTOS的任务管理机制，主要是任务相关函数的使用\n任务创建动态任务创建\n函数名称：xTaskCreate\nxTaskCreate(TaskFunction_t pxTaskCode,                  //任务函数指针            const char * const pcName,                  //任务名称            const configSTACK_DEPTH_TYPE usStackDepth,  //栈大小            void * const pvParameters,                  //任务参数            UBaseType_t uxPriority,                     //任务优先级            TaskHandle_t * const pxCreatedTask )        //任务句柄\n函数参数：  前几个参数都是用户自定义的，在传入参数的时候需要注意数据类型  \n\n函数作用： 如函数名称所示，是动态创建任务函数，与之相对还有一个静态创建任务函数\n\n注意： 如参数部分所示\n\n\n示例：\n//任务优先级#define START_TASK_PRIO\t\t\t1//任务堆栈，实际为*4，是因为数据类型为uint32_t#define START_STACK_SIZE\t\t128//任务句柄，是任务堆栈栈顶TaskHandle_t StartTask_Handler;//任务函数声明void StartTask(void *pvParameters);\n（待补充。。。）\n任务删除动态任务删除\n函数名称：vTaskDelete\nvTaskDelete( TaskHandle_t xTaskToDelete )\n函数参数：  传入想要删除的任务的句柄，在传入参数的时候需要注意数据类型  \n\n函数作用： 如函数名称所示，是动态删除任务函数，与之相对还有一个静态删除任务函数\n\n注意： 如果是只执行一次的函数，在执行结束后一定要删除自己，释放内存\n\n\n示例：\nvTaskDelete(StartTask_Handler);\n\n（待补充。。。）\n任务挂起与恢复任务挂起\n函数名称：vTaskSuspendvoid vTaskSuspend( TaskHandle_t xTaskToSuspend)\n函数参数： 传入任务句柄，注意数据类型\n注意： 参数为NULL则是挂起自身，任务句柄可以通过xTaskGetHandle()根据任务名来获取\n\n任务恢复\n函数名称：vTaskResume()void vTaskResume( TaskHandle_t xTaskToResume)\n函数参数： 传入任务句柄，注意数据类型\n\n任务恢复FromISR\n函数名称：vTaskResumeFromISR()BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume)\n函数参数： 传入任务句柄，注意数据类型\n注意： 在中断服务函数中使用\n返回值pdTURE 要恢复的任务优先级高于或等于当前运行中的任务优先级（被打断的任务），也就是说出中断后要进行一次上下文切换pdFALSE 与上面的相反，不用上下文切换\n\n临界区保护临界区是介于各个任务之间公共区域，每个任务都可以访问其内部资源，这势必会导致资源竞争，所以在进入临界区时要进行临界区保护，关闭中断，保护内部完整性执行\n进入&#x2F;退出临界区\n函数名称：taskENTER_CRITICALtaskEXIT_CRITICAL\n\n函数参数：  NULL\n\n函数作用： 如函数名称所示执行taskENTER_CRITICAL，进入临界区，关中断，调度器依赖的systick定时器也被关闭，所以不会有任何其他高优先级任务打断。执行taskENTER_CRITICAL，退出临界区，开中断，调度恢复\n\n注意： 临界区因为不能调度任务，所以临界区内代码尽量简洁，执行越快越好，不影响系统的实时性\n\n\n示例： \ntaskENTER_CRITICAL();//读写变量，调用公共函数taskEXIT_CRITICAL();\n进入&#x2F;退出临界区FromISR\n函数名称：taskENTER_CRITICAL_FROM_ISR()taskEXIT_CRITICAL_FROM_ISR(x)本质是宏定义，在portmacro.h中定义\n\n函数参数：  NULL，x\n\n函数作用： 如函数名称所示在中断内执行taskENTER_CRITICAL_FROM_ISR()，进入临界区，关中断，保存当前BASEPRI寄存器值，写入configMAX_SYSCALL_INTERRUPT_PRIORITY，返回之前的BASEPRI寄存器值(手动保存中断屏蔽寄存器上下文)，退出临界区时要用到在中断内执行taskEXIT_CRITICAL_FROM_ISR()，退出临界区，读进入临界区返回的值，恢复之前的中断\n\n注意： 临界区因为不能调度任务，所以临界区内代码尽量简洁，执行越快越好，不影响系统的实时性\n\n\n示例： \nBASEPRI_value = taskENTER_CRITICAL_FROM_ISR();//读写变量，调用公共函数taskEXIT_CRITICAL(BASEPRI_value);\n\n延时相对延时vTaskDelay()参数 xTicksToDelay要延迟的时间说明 以调用此函数的时间为起点进行延时，每次延时的时间受逻辑运行影响，不稳定适用于简单的非周期任务，或者等待外部事件的固定时长\n绝对延时xTaskDelayUntil()参数pxPreviousWakeTime  第一次使用绝对延迟函数要将此参数在while循环外初始化\n\nTickType_t xLastWakeTime &#x3D; xTaskGetTickCount(); &#x2F;&#x2F; 正确不是 TickType_t xLastWakeTime;（未初始化） \n\nxTimeIncrement 任务延迟的时间节拍数，相对于pxPreviousWakeTime而言  \n说明绝对的周期执行，同时会阻塞任务，因为要保证绝对的周期。但是遇到高优先级和中断还是不能执行，不够函数会自动补偿时间情况一：如果100ms的延时，但是执行task1执行了20ms，那就将task1阻塞80ms来保证绝对延时情况二：如果100ms的延时，但是执行task1被抢占耗时10ms，那就将task1阻塞90ms来保证绝对延时  \n注意  \n\n绝对延时函数参数初始化在循环外\n不能在临界区调用，会导致任务无法切换\n任务处理时间不能超过延时时间，否则会跳过阻塞一直执行\n\n任务信息列表、队列中断中断管理开关中断\n函数名称 portENABLE_INTERRUPTS () portDISABLE_INTERRUPTS() 本质上是宏定义，在portmacro.h中定义\n注意 开中断就是向BASEPRI寄存器写入0，BASEPRI寄存器是一个可编程的中断屏蔽寄存器，写入0就是停止屏蔽也就是开，关中断就是写入configMAX_SYSCALL_INTERRUPT_PRIORITY,比如写入0x60来屏蔽优先级低于0x60的中断\n\n","categories":["FreeRTOS"],"tags":["STM32","笔记","FreeRTOS"]},{"title":"lua学习笔记","url":"/2025/06/22/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"前言本文主要记录学习lua中一些易错，易混淆的点\n逻辑运算符and当两个值（无论是数值还是字符串）vala,valb进行and运算时运算式：vala and valb\n\nvala valb都为真（也就是不为nil或false）返回valb\nvala valb有一个为nil或false，返回vala示例当有三个变量local a = falselocal b = 0local c = 1\n分别进行and运算\n\n\n函数\n输出\n\n\n\nprint(b and c)\n1\n\n\nprint(a and b)\nfalse\n\n\nprint(b&gt;-1)\ntrue\n\n\nprint(b &gt; -1 and ‘yes’)\nyes\n\n\n\n\nor当两个值（无论是数值还是字符串）vala,valb进行or运算时运算式：vala or valb\n\nvala valb任意一个为nil或false，返回不为nil或false的真值\nvala valb都为真返回vala\nvala valb都为假返回valb示例当有四个变量local a = falselocal b = nillocal c = 0local d = 1\n分别进行or运算\n\n\n函数\n输出\n\n\n\nprint(a or c) print(b or c)\n0\n\n\nprint(d or a) print(d or b)\n1\n\n\nprint(c or d)\n0\n\n\nprint(b or c)\n1\n\n\nprint(a or b)\nnil\n\n\nprint(b or a)\nfalse\n\n\n\n\n短路求值形如print(b &gt; 10 and &quot;yes&quot; or &quot;no&quot;)假设b&gt;10是false，先和&quot;yes&quot;进行与运算，得false;再或运算，得&quot;no&quot;假设b&gt;10是true， 先和&quot;yes&quot;进行与运算，得&quot;yes&quot;;再或运算，得&quot;yes&quot;示例\nlocal b = 0print(b &gt; 10 and &quot;yes&quot; or &quot;no&quot;)print(b &gt; -1 and &#x27;yes&#x27; or &#x27;no&#x27;)输出noyes","categories":["lua"],"tags":["lua"]},{"title":"大学生想兼职赚钱就别指望还能学技术","url":"/2025/05/25/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%83%B3%E5%85%BC%E8%81%8C%E8%B5%9A%E9%92%B1%E5%B0%B1%E5%88%AB%E6%8C%87%E6%9C%9B%E8%BF%98%E8%83%BD%E5%AD%A6%E6%8A%80%E6%9C%AF/","content":"前言在5月21日，我正式结束了我在少儿编程培训班（以下简称机构）的兼职合计三次交作品——350+650+150&#x3D;1150，一共七个，历时三个月，记一下这次的经历。先说结论：大学生如果是为了赚钱就直接去赚钱最多的兼职，比如家教之类的，别想着去干自己专业相关的兼职还能赚钱，你的时间很宝贵，而且实际情况大概率不是你想的那样。\n第一次接触2月21日从群里看到有个机构需要人，负责制作嵌入式小作品和可能的授课，看到这个消息的我很开心，因为这个兼职和我的专业很契合，于是兴冲冲的联系学长。交了一个小简历，25号给了我机构负责人老师的微信（以下简称h老师）  \n2月25日加上微信，确认了面试时间在2月28日\n2月28日我去的前一天（2.27）没有再和h老师确认，于是被放鸽子了不过h老师说机构有别的老师在，让我上去还是去搞了一次不伦不类的“面试”。最后只确认了上班的时间和我主要的工作，给小学生做科创比赛作品。但其实后面就是有时间要做东西才去。\n\n一开始去早了，还和楼下保安聊了一会，最后会提到\n\n3月3日晚上和h老师在微信上确认了要干啥，用Arduino，这个h老师非常在意 “开源”，他给我一些关于比赛的资料和做的项目都是他说的 “开源”。后面会回收伏笔还有做项目需要的硬件我先自己买，后面他在补给我\n\ns所谓开源，点进去一看，有想法，代码——只有截图，图纸——只要图片，什么源文件都没有，然后 “开源”\n\n正式开工正式开工前正式和h老师见了一面，人很不错，说话也客气，没有因为我是学生就怎么样，这也是我虽然吐槽但是还是认真干我该干的活的原因之一确认下来一个项目起价150，根据难度上调价格。  \n3月11日开始做，去了机构，说是给我分配电脑（这个我一开始就问过他了，他给我说东西都有），其实就是机构授课的老师的笔记本，谁不在就把谁的给我，而且问的时候哪里的老师也不清楚具体情况。总的来说，我就是独立出来干活，和他们没有交集非常古老的联想商务本，没有电池，卡的批爆。根本没法用，磨蹭了一下午我就走了，后面就是带自己的电脑\n3月19日做完了两个，h老师来看完要给我结钱，因为是第一次搞，怎么要价我也不好开口，最后是两个一共350。七点钟从机构离开，我非常兴奋，因为是第一次赚到钱，脚步都是轻的。这段时间我每天下午三点到，六点多快七点走。\n\n在这里做项目，题目都是自己想，除了写程序，调硬件 还要负责制作外观，撰写文档 不过是给小学生做的，都比较简单，可是架不住它事多。我也是第一次学建模和3d打印\n\n中间还有段小插曲，h老师问我怎么使用3d打印机，其实我也是第一次接触啊，这种东西看看官方的使用文档不就知道了吗。于是晚上给我打视频让我教怎么用😶\n3月23日前面歇了几天之前提过，这里做东西题目要自己想，于是我到处查创客网站和科创比赛获奖名单想了三个毙了两个，因为是很常见的东西。h老师让我先做，于是我买了东西准备快递到了就去做，在等待的时候h老师告诉我：搜一下让生活更美好主题，找两个项目我:😓，我靠，这种宽泛的主题说了和没说有啥两样不过最后还是凑了俩上去，中间他和我说，做东西要往大做\n4月15日这三个做的差不多了，他告诉我再做一个停车场的，这次外观不是3d打印了，而是玻纤板切割组装，为了这个我又去学习开源的CAD软件libreCAD\n4月25日中间时间要组装前三个，还要调试第四个的硬软件，这天我才把图纸画出来，又正逢五一假期，等到切割的样板到，已经是5.5了\n5月5日我到机构一看样板（木板切割的）发现h老师把我的图层都合并在一起了，导致大部分地方都切错了，我也没说，大概组装了一下发现没大问题，再把小问题修改了一下。后面我问他使用玻纤板切割的话公差要留多少合适，答案是没有\n\n四月中旬的时候我说我暑假要去实习，h老师说本来是想让我暑假把我做的项目教给小朋友，然后再开一个使用3d打印机的课程。我表示暑假应该不留，他说到时候再说吧\n\n5月7日h老师问我五月是不是再做一些，我答应了，后面看来其实非常不应该，做完手头的就应该直接告辞，后面就是折磨。然后我又想了一个，还是买东西等快递\n\n这中间发生了很搞笑的事，我说了一个双人对战口算机的想法，他先是说这个年年有人做，当我说这个我搜了没见过和类似的东西后，他又改口：确实不常见，然后问我是不是 “开源” 的。我是这个是我自己想的，而且之前做的也都是只有想法，没有源码和外壳文件只能自己做。他回我——“👍，人才”\n\n5月13日玻纤板终于回来了，我装了两个下午，主要是我没加公差，比如一个插件那种就要留一点余量。然后和他说了后面的安排，明确了我五月干完就要走。然后给我结了钱，前三个各150，第四个200。结完钱和我说下次来做个小车，具体当面和我说\n5月19日和h老师见了一面，我表示如果小车太难搞我可能没时间做了，他表示理解然后晚上给我发了一个链接我当时看完都傻眼了，告诉他我做不了\n5月20日最后一个也做完了。把源码，外壳模型文件，手册啥的都整理好了。验收了一下，给我结完最后一个150，我就走了。走的时候还和楼下保安聊了几句，总结就是这里挣不到什么钱还浪费时间\n回顾与总结历时差不多三个月，我去每次去机构都是公交通勤，路上要倒车，来回一次4块。两点多从学校走，三点到机构，一般都是做到六点多才走，等回学校时都七八点了，有几次搞忘时间，等回学校已经九点了。在那里不能说啥也没学到，为了做东西还是自学了一点技能，不过和我浪费掉的时间比真不算什么。为了做机构的项目，有时候闲着还想想题目，还是有点折磨的。五月中我还准备暑假实习，其实已经有点晚了，而且我也没有自己的项目，简历上空空荡荡的哈哈哈，如果你要准备实习的话还是不要浪费时间，做一些能展现水平的东西，给小学生做的小东西没啥用。\n最后，钱也没挣到，时间浪费许多，虽然有一点收获，但总体是亏的\n文章标题其实是暴论，事实也可能没那么糟。\n","categories":["日常生活"],"tags":["日常生活","兼职","大学生","随想"]}]