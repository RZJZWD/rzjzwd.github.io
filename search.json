[{"title":"åµŒå…¥å¼é©±åŠ¨å¼€å‘ è®°å½•é©±åŠ¨ST7735è¿‡ç¨‹","url":"/2025/05/09/development%20of%20the%20st7735%20driver/","content":"å‰è¨€å¯’å‡å›å®¶æ²¡äº‹åšï¼Œç‰¹æ„å¸¦äº†ä¸€å—1.8å¯¸çš„TFTå±æ¥ç»ƒä¹ é©±åŠ¨å¼€å‘ï¼Œé©±åŠ¨ä¸ºST7735ï¼Œä¸»æ§ä¸ºæ˜¯RCT6ã€‚ç”¨äº†ä¸‰å¤©åŠ ä¸ŠæŸ¥é˜…ç½‘ä¸Šèµ„æ–™ï¼Œç®—æ˜¯ç£•ç£•ç»Šç»Šçš„æŠŠé©±åŠ¨å†™å®Œäº†ã€‚æŠŠå¼€å‘è¿‡ç¨‹ä¸­çš„è¿‡ç¨‹å’Œé—®é¢˜è®°å½•ä¸€ä¸‹ï¼Œåšä¸ªå¤‡å¿˜ã€‚\nST7735ä»‹ç»ST7735çš„ä»‹ç»ç½‘ä¸Šéå¸¸å¤šï¼Œæˆ‘å°±ä¸å†é‡å¤äº†ã€‚å¯¹äºST7735ï¼Œå±å¹•çš„æ˜¾ç¤ºåŸç†ä¸æ˜¯æˆ‘ä»¬åº”è¯¥æ·±ç©¶çš„åœ°æ–¹ã€‚åªè°ˆåº”ç”¨ï¼Œæˆ‘ä¸ªäººè§‰å¾—å…¶å†…éƒ¨çš„RAMï¼ˆå§‘ä¸”è¿™ä¹ˆç§°å‘¼ï¼‰å¾ˆæœ‰æ„æ€ï¼Œè¿˜æœ‰å†™å…¥æŒ‡ä»¤ä¸€å®šè¦ä»”ç»†ï¼Œä»¥åŠST7735çš„æ˜¯åœ¨ä¸Šå‡æ²¿è¯»å…¥æŒ‡ä»¤æ•°æ®ï¼Œè¿™ç‚¹éå¸¸é‡è¦ï¼Œåæ–‡ä¼šæåˆ°ã€‚\nç¡¬ä»¶spié©±åŠ¨é©±åŠ¨ST7735çš„è¿‡ç¨‹ä¹Ÿæ˜¯å­¦ä¹ é…ç½®spiçš„è¿‡ç¨‹ï¼Œæ‰€ä»¥æˆ‘é€‰æ‹©ä½¿ç”¨ç¡¬ä»¶spiã€‚é©±åŠ¨å±å¹•ä¸éœ€è¦è¯»æ•°æ®ï¼Œç”¨ä¸åˆ°MISOçº¿ã€‚\nå¼•è„šå®šä¹‰\n\n\nGPIO\nST7735\nè¯´æ˜\n\n\n\nPA7\nSDA\næ•°æ®å†™å…¥\n\n\nPA5\nSCL\næ—¶é’Ÿ\n\n\nPA4\nCS\nç‰‡é€‰ï¼Œ 0é€‰ä¸­ 1å¿½ç•¥\n\n\nPC4\nRESET\nç¡¬ä»¶å¤ä½\n\n\nPC5\nDC\næ•°æ®å‘½ä»¤é€‰æ‹©ï¼Œ0å†™å‘½ä»¤ 1å†™æ•°æ®\n\n\nBLKå¼•è„šæ¥é«˜å³å¯\nåˆå§‹åŒ–spiSPI_InitStr.SPI_BaudRatePrescaler   = SPI_BaudRatePrescaler_2;// ä½¿åˆ†é¢‘å€¼è¾¾åˆ°æœ€å¤§SPI_InitStr.SPI_CPHA\t\t\t    = SPI_CPHA_2Edge;\t\t  // ä¸Šå‡æ²¿æœ‰æ•ˆSPI_InitStr.SPI_CPOL\t\t\t\t= SPI_CPOL_High;\t\t  // ä½ç”µå¹³æœ‰æ•ˆ,ç©ºé—²æ—¶ä¸ºé«˜SPI_InitStr.SPI_CRCPolynomial\t    = 7;\t\t\t\t\t  // æ—  CRC æ ¡éªŒSPI_InitStr.SPI_DataSize\t\t\t= SPI_DataSize_8b;\t\t  // å‘é€å­—é•¿ä¸º 8 ä½SPI_InitStr.SPI_Direction\t\t    = SPI_Direction_1Line_Tx; // æ–¹å‘ä¸ºå‘é€SPI_InitStr.SPI_FirstBit\t\t\t= SPI_FirstBit_MSB;\t\t  // é«˜ä½å…ˆè¡ŒSPI_InitStr.SPI_Mode\t\t\t\t= SPI_Mode_Master;\t\t  // ä¸»æœºæ¨¡å¼SPI_InitStr.SPI_NSS\t\t\t\t    = SPI_NSS_Soft;\t\t\t  // è½¯ä»¶æ§åˆ¶\nCPHAæ§åˆ¶åœ¨é‚£ä¸ªï¼ˆç¬¬ä¸€orç¬¬äºŒï¼‰è¾¹æ²¿å‘é€CPOLæ§åˆ¶spiç©ºé—²æ—¶çš„çŠ¶æ€ï¼ˆé«˜orä½ï¼‰æ¨¡å¼0 ï¼šCPOLè®¾ç½®ç©ºé—²æ—¶ä¸ºä½ï¼Œå½“è¦ä¼ æ•°æ®æ—¶MOSIæ‹‰é«˜å†æ‹‰ä½å®Œæˆä¸€ä½æ•°æ®ä¼ è¾“ï¼Œä¸Šå‡æ²¿ä¸ºç¬¬ä¸€ä¸ªè¾¹æ²¿ï¼Œä¹Ÿå°±æ˜¯CPHAè®¾ç½®ä¸º1edgeã€‚æ¨¡å¼3 : CPOLè®¾ç½®ç©ºé—²æ—¶ä¸ºé«˜ï¼Œå½“è¦ä¼ æ•°æ®æ—¶MOSIæ‹‰ä½å†æ‹‰é«˜å®Œæˆä¸€ä½æ•°æ®ä¼ è¾“ï¼Œä¸Šå‡æ²¿ä¸ºç¬¬äºŒä¸ªè¾¹æ²¿ï¼Œä¹Ÿå°±æ˜¯CPHAè®¾ç½®ä¸º2edgeã€‚\n\nST7735è¦æ±‚ä¸Šå‡æ²¿æ¥æ”¶ï¼Œä¹Ÿå°±æ˜¯å°†SPIé…ç½®ä¸ºæ¨¡å¼0å’Œæ¨¡å¼3ï¼Œå¦‚ä¸‹å›¾ã€‚\n\nï¼ˆST7735æ•°æ®æ‰‹å†Œ104é¡µï¼‰\nåœ¨ç¼–å†™å‘é€å‡½æ•°æ—¶è¦æ³¨æ„ï¼šå¯¹st7735è¯»å†™éƒ½éœ€è¦åœ¨ç‰‡é€‰ä¿¡å·æ‹‰ä½çš„æƒ…å†µä¸‹è¿›è¡Œï¼Œä¸ç„¶st7735ä¼šå¿½ç•¥æ—¶é’ŸSCLä¿¡å·ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸è®ºè¯»å†™éƒ½éœ€è¦å…ˆå°†CSç½®0ï¼Œç„¶åå†æ ¹æ®è¯»å†™æƒ…å†µå¯¹DCç½®å¤ä½ï¼Œè¯»å†™ç»“æŸåå°†CSæ‹‰é«˜ï¼Œè¯¦æƒ…å¯å‚è€ƒä¸‹é¢çš„å‘é€å‡½æ•°\nspiå†™æ•°æ®å‡½æ•°ï¼š\nenum TFT_DATA_CMD&#123;\tTFT_DC_CMD=0,\tTFT_DC_DATA=1&#125;;void SPI1_WriteData(uint8_t data)&#123;\tuint16_t timeout=0;\twhile(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET)&#123;\t//å‘é€ç¼“å†²åŒºä¸ºç©ºæ—¶ï¼ˆTXE=1ï¼‰æ‰å¯ä»¥å†™å…¥\t\tif(++timeout &gt; 200)\t\t\t\t\t\t\t\t\t\t//è¶…æ—¶200ç›´æ¥é€€å‡º\t\t\treturn;\t&#125;\tSPI_I2S_SendData(SPI1,data);&#125;void TFT_ST7735_Write(int c_d,uint8_t data)&#123;\tTFT_DC = c_d;\tSPI_CS = 0;\tSPI1_WriteData(data);\tSPI_CS = 1;&#125;\n\n\nST7735åˆå§‹åŒ–ç½‘ä¸Šåˆå§‹åŒ–å‘½ä»¤çš„æ•™ç¨‹æœ‰å¾ˆå¤šï¼Œç›´æ¥ç…§æŠ„å³å¯ï¼Œä¸‹ä¸ºæˆ‘çš„é…ç½®ï¼š\nvoid TFT_ST7735_Config(void)&#123;\tTFT_ST7735_Reset();\tTFT_ST7735_Write(TFT_DC_CMD,TFT_SLPOUT);\tdelay_ms(120);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR2);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_FRMCTR3);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x05);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3C);\t\t//===============inversion of control=============\tTFT_ST7735_Write(TFT_DC_CMD, TFT_INVCRT);\tTFT_ST7735_Write(TFT_DC_DATA, 0x03);\t//===============power set========================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x28);\tTFT_ST7735_Write(TFT_DC_DATA, 0x08);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\t\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR2);\tTFT_ST7735_Write(TFT_DC_DATA, 0xC0);\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR3);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR4);\tTFT_ST7735_Write(TFT_DC_DATA, 0x8D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2A);\t\tTFT_ST7735_Write(TFT_DC_CMD, TFT_PWCTR5);\tTFT_ST7735_Write(TFT_DC_DATA, 0x8D);\tTFT_ST7735_Write(TFT_DC_DATA, 0xEE);\t//===============vcom set=========================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_VMCTR1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x1A);\t\t//===============scanning direction set===========\t\tif(TFT_DIRECTION==0)\t\tTFT_ST7735_SetScanDirection(0x00);//æ˜¾ç¤ºæ–¹å‘é€‰æ‹©\telse if(TFT_DIRECTION==1)\tTFT_ST7735_SetScanDirection(0xC0);\telse if(TFT_DIRECTION==2)\tTFT_ST7735_SetScanDirection(0xA0);\telse\t\t\t\t\t\tTFT_ST7735_SetScanDirection(0x70);\t\t//===============gamma sequence set===============\tTFT_ST7735_Write(TFT_DC_CMD, TFT_GMCTRP1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x22);\tTFT_ST7735_Write(TFT_DC_DATA, 0x07);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2E);\tTFT_ST7735_Write(TFT_DC_DATA, 0x30);\tTFT_ST7735_Write(TFT_DC_DATA, 0x25);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x28);\tTFT_ST7735_Write(TFT_DC_DATA, 0x26);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2E);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3A);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\tTFT_ST7735_Write(TFT_DC_DATA, 0x01);\tTFT_ST7735_Write(TFT_DC_DATA, 0x03);\tTFT_ST7735_Write(TFT_DC_DATA, 0x13);\tTFT_ST7735_Write(TFT_DC_CMD, TFT_GMCTRN1);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x16);\tTFT_ST7735_Write(TFT_DC_DATA, 0x06);\tTFT_ST7735_Write(TFT_DC_DATA, 0x0D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x26);\tTFT_ST7735_Write(TFT_DC_DATA, 0x23);\tTFT_ST7735_Write(TFT_DC_DATA, 0x27);\tTFT_ST7735_Write(TFT_DC_DATA, 0x27);\tTFT_ST7735_Write(TFT_DC_DATA, 0x25);\tTFT_ST7735_Write(TFT_DC_DATA, 0x2D);\tTFT_ST7735_Write(TFT_DC_DATA, 0x3B);\tTFT_ST7735_Write(TFT_DC_DATA, 0x00);\tTFT_ST7735_Write(TFT_DC_DATA, 0x01);\tTFT_ST7735_Write(TFT_DC_DATA, 0x04);\tTFT_ST7735_Write(TFT_DC_DATA, 0x13);\t//===============color format set=================\tTFT_ST7735_SetColorFormat(0x05);\t//===============display on=======================\tTFT_ST7735_Write(TFT_DC_CMD, TFT_DISPON);&#125;\nè¸©å‘è®°å½•ç½‘ä¸Šåˆå§‹åŒ–å‘½ä»¤çš„æ•™ç¨‹æœ‰å¾ˆå¤šï¼Œæˆ‘ä¸»è¦è¯´ä¸€ä¸‹æˆ‘åœ¨åˆå§‹åŒ–ä¸­æœ‰è¿‡ç–‘æƒ‘çš„å‡ ä¸ªç‚¹\n\n0x36hMADCTLå‘½ä»¤ï¼ˆST7735æ•°æ®æ‰‹å†Œ142é¡µï¼‰spiæ•°æ®é«˜ä½å…ˆè¡Œï¼ŒRGBä½è®¾ç½®ä¸º0é€‰æ‹©ä»¥ â€œRGBâ€ çš„é¡ºåºè¯»å…¥é¢œè‰²æ•°æ®\n\nåˆå§‹åŒ–æˆåŠŸåèŠ±å±ST7735çš„frame memoryï¼ˆæ˜¾å­˜ï¼‰ä¸Šç”µåä¸ºéšæœºå€¼ï¼Œæ•…åˆå§‹åŒ–åèŠ±å±ï¼Œå…¨å±å¡«å……ç™½è‰²å°±å¯ä»¥äº†ST7735æ•°æ®æ‰‹å†Œ89é¡µï¼‰\n\n\n","categories":["STM32"],"tags":["STM32","ç¬”è®°","ST7735é©±åŠ¨"]},{"title":"FreeRTOSå¤‡å¿˜","url":"/2025/05/26/FreeRTOS%E5%A4%87%E5%BF%98/","content":"å‰è¨€æœ¬æ–‡ç« ç”¨äºè®°å½•å­¦ä¹ FreeRTOSä¸­ä½¿ç”¨è¿‡çš„å‡½æ•°ï¼ŒåŠŸèƒ½ç­‰å†…å®¹ï¼Œç›®çš„æ˜¯ä¸ºäº†æ–¹ä¾¿è‡ªå·±å¿«é€ŸæŸ¥å‡½æ•°ç”¨æ³•ï¼Œå½’æ¡£å’Œè¸©å‘è®°å½•ã€‚\n\næ–‡ç« ä¸»è¦åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ¿å—ï¼šä»»åŠ¡ç®¡ç†ï¼Œé˜Ÿåˆ—æœºåˆ¶ï¼Œä¸­æ–­ç®¡ç†ï¼ˆå¾…è¡¥å……â€¦ï¼‰æ¯ä¸ªæ¿å—çš„å¤§è‡´ç»„ç»‡ç»“æ„ä¸º:1.å‡½æ•°åç§°2.å‡½æ•°å‚æ•°3.å‡½æ•°ä½œç”¨4.å‡½æ•°æ³¨æ„åŠè¸©å‘\n\n\nä»»åŠ¡ç®¡ç†è¿™é‡Œä¸»è¦ä»‹ç»FreeRTOSçš„ä»»åŠ¡ç®¡ç†æœºåˆ¶ï¼Œä¸»è¦æ˜¯ä»»åŠ¡ç›¸å…³å‡½æ•°çš„ä½¿ç”¨\nä»»åŠ¡åˆ›å»ºåŠ¨æ€ä»»åŠ¡åˆ›å»º\nå‡½æ•°åç§°ï¼šxTaskCreate\nxTaskCreate(TaskFunction_t pxTaskCode,                  //ä»»åŠ¡å‡½æ•°æŒ‡é’ˆ            const char * const pcName,                  //ä»»åŠ¡åç§°            const configSTACK_DEPTH_TYPE usStackDepth,  //æ ˆå¤§å°            void * const pvParameters,                  //ä»»åŠ¡å‚æ•°            UBaseType_t uxPriority,                     //ä»»åŠ¡ä¼˜å…ˆçº§            TaskHandle_t * const pxCreatedTask )        //ä»»åŠ¡å¥æŸ„\nå‡½æ•°å‚æ•°ï¼š  å‰å‡ ä¸ªå‚æ•°éƒ½æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„ï¼Œåœ¨ä¼ å…¥å‚æ•°çš„æ—¶å€™éœ€è¦æ³¨æ„æ•°æ®ç±»å‹  \n\nå‡½æ•°ä½œç”¨ï¼š å¦‚å‡½æ•°åç§°æ‰€ç¤ºï¼Œæ˜¯åŠ¨æ€åˆ›å»ºä»»åŠ¡å‡½æ•°ï¼Œä¸ä¹‹ç›¸å¯¹è¿˜æœ‰ä¸€ä¸ªé™æ€åˆ›å»ºä»»åŠ¡å‡½æ•°\n\næ³¨æ„ï¼š å¦‚å‚æ•°éƒ¨åˆ†æ‰€ç¤º\n\n\nç¤ºä¾‹ï¼š\n//ä»»åŠ¡ä¼˜å…ˆçº§#define START_TASK_PRIO\t\t\t1//ä»»åŠ¡å †æ ˆï¼Œå®é™…ä¸º*4ï¼Œæ˜¯å› ä¸ºæ•°æ®ç±»å‹ä¸ºuint32_t#define START_STACK_SIZE\t\t128//ä»»åŠ¡å¥æŸ„ï¼Œæ˜¯ä»»åŠ¡å †æ ˆæ ˆé¡¶TaskHandle_t StartTask_Handler;//ä»»åŠ¡å‡½æ•°å£°æ˜void StartTask(void *pvParameters);\nï¼ˆå¾…è¡¥å……ã€‚ã€‚ã€‚ï¼‰\nä»»åŠ¡åˆ é™¤åŠ¨æ€ä»»åŠ¡åˆ é™¤\nå‡½æ•°åç§°ï¼švTaskDelete\nvTaskDelete( TaskHandle_t xTaskToDelete )\nå‡½æ•°å‚æ•°ï¼š  ä¼ å…¥æƒ³è¦åˆ é™¤çš„ä»»åŠ¡çš„å¥æŸ„ï¼Œåœ¨ä¼ å…¥å‚æ•°çš„æ—¶å€™éœ€è¦æ³¨æ„æ•°æ®ç±»å‹  \n\nå‡½æ•°ä½œç”¨ï¼š å¦‚å‡½æ•°åç§°æ‰€ç¤ºï¼Œæ˜¯åŠ¨æ€åˆ é™¤ä»»åŠ¡å‡½æ•°ï¼Œä¸ä¹‹ç›¸å¯¹è¿˜æœ‰ä¸€ä¸ªé™æ€åˆ é™¤ä»»åŠ¡å‡½æ•°\n\næ³¨æ„ï¼š å¦‚æœæ˜¯åªæ‰§è¡Œä¸€æ¬¡çš„å‡½æ•°ï¼Œåœ¨æ‰§è¡Œç»“æŸåä¸€å®šè¦åˆ é™¤è‡ªå·±ï¼Œé‡Šæ”¾å†…å­˜\n\n\nç¤ºä¾‹ï¼š\nvTaskDelete(StartTask_Handler);\n\nï¼ˆå¾…è¡¥å……ã€‚ã€‚ã€‚ï¼‰\nä»»åŠ¡æŒ‚èµ·ä¸æ¢å¤ä»»åŠ¡æŒ‚èµ·\nå‡½æ•°åç§°ï¼švTaskSuspendvoid vTaskSuspend( TaskHandle_t xTaskToSuspend)\nå‡½æ•°å‚æ•°ï¼š ä¼ å…¥ä»»åŠ¡å¥æŸ„ï¼Œæ³¨æ„æ•°æ®ç±»å‹\næ³¨æ„ï¼š å‚æ•°ä¸ºNULLåˆ™æ˜¯æŒ‚èµ·è‡ªèº«ï¼Œä»»åŠ¡å¥æŸ„å¯ä»¥é€šè¿‡xTaskGetHandle()æ ¹æ®ä»»åŠ¡åæ¥è·å–\n\nä»»åŠ¡æ¢å¤\nå‡½æ•°åç§°ï¼švTaskResume()void vTaskResume( TaskHandle_t xTaskToResume)\nå‡½æ•°å‚æ•°ï¼š ä¼ å…¥ä»»åŠ¡å¥æŸ„ï¼Œæ³¨æ„æ•°æ®ç±»å‹\n\nä»»åŠ¡æ¢å¤FromISR\nå‡½æ•°åç§°ï¼švTaskResumeFromISR()BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume)\nå‡½æ•°å‚æ•°ï¼š ä¼ å…¥ä»»åŠ¡å¥æŸ„ï¼Œæ³¨æ„æ•°æ®ç±»å‹\næ³¨æ„ï¼š åœ¨ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ä½¿ç”¨\nè¿”å›å€¼pdTURE è¦æ¢å¤çš„ä»»åŠ¡ä¼˜å…ˆçº§é«˜äºæˆ–ç­‰äºå½“å‰è¿è¡Œä¸­çš„ä»»åŠ¡ä¼˜å…ˆçº§ï¼ˆè¢«æ‰“æ–­çš„ä»»åŠ¡ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´å‡ºä¸­æ–­åè¦è¿›è¡Œä¸€æ¬¡ä¸Šä¸‹æ–‡åˆ‡æ¢pdFALSE ä¸ä¸Šé¢çš„ç›¸åï¼Œä¸ç”¨ä¸Šä¸‹æ–‡åˆ‡æ¢\n\nä¸´ç•ŒåŒºä¿æŠ¤ä¸´ç•ŒåŒºæ˜¯ä»‹äºå„ä¸ªä»»åŠ¡ä¹‹é—´å…¬å…±åŒºåŸŸï¼Œæ¯ä¸ªä»»åŠ¡éƒ½å¯ä»¥è®¿é—®å…¶å†…éƒ¨èµ„æºï¼Œè¿™åŠ¿å¿…ä¼šå¯¼è‡´èµ„æºç«äº‰ï¼Œæ‰€ä»¥åœ¨è¿›å…¥ä¸´ç•ŒåŒºæ—¶è¦è¿›è¡Œä¸´ç•ŒåŒºä¿æŠ¤ï¼Œå…³é—­ä¸­æ–­ï¼Œä¿æŠ¤å†…éƒ¨å®Œæ•´æ€§æ‰§è¡Œ\nè¿›å…¥&#x2F;é€€å‡ºä¸´ç•ŒåŒº\nå‡½æ•°åç§°ï¼štaskENTER_CRITICALtaskEXIT_CRITICAL\n\nå‡½æ•°å‚æ•°ï¼š  NULL\n\nå‡½æ•°ä½œç”¨ï¼š å¦‚å‡½æ•°åç§°æ‰€ç¤ºæ‰§è¡ŒtaskENTER_CRITICALï¼Œè¿›å…¥ä¸´ç•ŒåŒºï¼Œå…³ä¸­æ–­ï¼Œè°ƒåº¦å™¨ä¾èµ–çš„systickå®šæ—¶å™¨ä¹Ÿè¢«å…³é—­ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰ä»»ä½•å…¶ä»–é«˜ä¼˜å…ˆçº§ä»»åŠ¡æ‰“æ–­ã€‚æ‰§è¡ŒtaskENTER_CRITICALï¼Œé€€å‡ºä¸´ç•ŒåŒºï¼Œå¼€ä¸­æ–­ï¼Œè°ƒåº¦æ¢å¤\n\næ³¨æ„ï¼š ä¸´ç•ŒåŒºå› ä¸ºä¸èƒ½è°ƒåº¦ä»»åŠ¡ï¼Œæ‰€ä»¥ä¸´ç•ŒåŒºå†…ä»£ç å°½é‡ç®€æ´ï¼Œæ‰§è¡Œè¶Šå¿«è¶Šå¥½ï¼Œä¸å½±å“ç³»ç»Ÿçš„å®æ—¶æ€§\n\n\nç¤ºä¾‹ï¼š \ntaskENTER_CRITICAL();//è¯»å†™å˜é‡ï¼Œè°ƒç”¨å…¬å…±å‡½æ•°taskEXIT_CRITICAL();\nè¿›å…¥&#x2F;é€€å‡ºä¸´ç•ŒåŒºFromISR\nå‡½æ•°åç§°ï¼štaskENTER_CRITICAL_FROM_ISR()taskEXIT_CRITICAL_FROM_ISR(x)æœ¬è´¨æ˜¯å®å®šä¹‰ï¼Œåœ¨portmacro.hä¸­å®šä¹‰\n\nå‡½æ•°å‚æ•°ï¼š  NULLï¼Œx\n\nå‡½æ•°ä½œç”¨ï¼š å¦‚å‡½æ•°åç§°æ‰€ç¤ºåœ¨ä¸­æ–­å†…æ‰§è¡ŒtaskENTER_CRITICAL_FROM_ISR()ï¼Œè¿›å…¥ä¸´ç•ŒåŒºï¼Œå…³ä¸­æ–­ï¼Œä¿å­˜å½“å‰BASEPRIå¯„å­˜å™¨å€¼ï¼Œå†™å…¥configMAX_SYSCALL_INTERRUPT_PRIORITYï¼Œè¿”å›ä¹‹å‰çš„BASEPRIå¯„å­˜å™¨å€¼(æ‰‹åŠ¨ä¿å­˜ä¸­æ–­å±è”½å¯„å­˜å™¨ä¸Šä¸‹æ–‡)ï¼Œé€€å‡ºä¸´ç•ŒåŒºæ—¶è¦ç”¨åˆ°åœ¨ä¸­æ–­å†…æ‰§è¡ŒtaskEXIT_CRITICAL_FROM_ISR()ï¼Œé€€å‡ºä¸´ç•ŒåŒºï¼Œè¯»è¿›å…¥ä¸´ç•ŒåŒºè¿”å›çš„å€¼ï¼Œæ¢å¤ä¹‹å‰çš„ä¸­æ–­\n\næ³¨æ„ï¼š ä¸´ç•ŒåŒºå› ä¸ºä¸èƒ½è°ƒåº¦ä»»åŠ¡ï¼Œæ‰€ä»¥ä¸´ç•ŒåŒºå†…ä»£ç å°½é‡ç®€æ´ï¼Œæ‰§è¡Œè¶Šå¿«è¶Šå¥½ï¼Œä¸å½±å“ç³»ç»Ÿçš„å®æ—¶æ€§\n\n\nç¤ºä¾‹ï¼š \nBASEPRI_value = taskENTER_CRITICAL_FROM_ISR();//è¯»å†™å˜é‡ï¼Œè°ƒç”¨å…¬å…±å‡½æ•°taskEXIT_CRITICAL(BASEPRI_value);\n\nå»¶æ—¶ç›¸å¯¹å»¶æ—¶vTaskDelay()å‚æ•° xTicksToDelayè¦å»¶è¿Ÿçš„æ—¶é—´è¯´æ˜ ä»¥è°ƒç”¨æ­¤å‡½æ•°çš„æ—¶é—´ä¸ºèµ·ç‚¹è¿›è¡Œå»¶æ—¶ï¼Œæ¯æ¬¡å»¶æ—¶çš„æ—¶é—´å—é€»è¾‘è¿è¡Œå½±å“ï¼Œä¸ç¨³å®šé€‚ç”¨äºç®€å•çš„éå‘¨æœŸä»»åŠ¡ï¼Œæˆ–è€…ç­‰å¾…å¤–éƒ¨äº‹ä»¶çš„å›ºå®šæ—¶é•¿\nç»å¯¹å»¶æ—¶xTaskDelayUntil()å‚æ•°pxPreviousWakeTime  ç¬¬ä¸€æ¬¡ä½¿ç”¨ç»å¯¹å»¶è¿Ÿå‡½æ•°è¦å°†æ­¤å‚æ•°åœ¨whileå¾ªç¯å¤–åˆå§‹åŒ–\n\nTickType_t xLastWakeTime &#x3D; xTaskGetTickCount(); &#x2F;&#x2F; æ­£ç¡®ä¸æ˜¯ TickType_t xLastWakeTime;ï¼ˆæœªåˆå§‹åŒ–ï¼‰ \n\nxTimeIncrement ä»»åŠ¡å»¶è¿Ÿçš„æ—¶é—´èŠ‚æ‹æ•°ï¼Œç›¸å¯¹äºpxPreviousWakeTimeè€Œè¨€  \nè¯´æ˜ç»å¯¹çš„å‘¨æœŸæ‰§è¡Œï¼ŒåŒæ—¶ä¼šé˜»å¡ä»»åŠ¡ï¼Œå› ä¸ºè¦ä¿è¯ç»å¯¹çš„å‘¨æœŸã€‚ä½†æ˜¯é‡åˆ°é«˜ä¼˜å…ˆçº§å’Œä¸­æ–­è¿˜æ˜¯ä¸èƒ½æ‰§è¡Œï¼Œä¸å¤Ÿå‡½æ•°ä¼šè‡ªåŠ¨è¡¥å¿æ—¶é—´æƒ…å†µä¸€ï¼šå¦‚æœ100msçš„å»¶æ—¶ï¼Œä½†æ˜¯æ‰§è¡Œtask1æ‰§è¡Œäº†20msï¼Œé‚£å°±å°†task1é˜»å¡80msæ¥ä¿è¯ç»å¯¹å»¶æ—¶æƒ…å†µäºŒï¼šå¦‚æœ100msçš„å»¶æ—¶ï¼Œä½†æ˜¯æ‰§è¡Œtask1è¢«æŠ¢å è€—æ—¶10msï¼Œé‚£å°±å°†task1é˜»å¡90msæ¥ä¿è¯ç»å¯¹å»¶æ—¶  \næ³¨æ„  \n\nç»å¯¹å»¶æ—¶å‡½æ•°å‚æ•°åˆå§‹åŒ–åœ¨å¾ªç¯å¤–\nä¸èƒ½åœ¨ä¸´ç•ŒåŒºè°ƒç”¨ï¼Œä¼šå¯¼è‡´ä»»åŠ¡æ— æ³•åˆ‡æ¢\nä»»åŠ¡å¤„ç†æ—¶é—´ä¸èƒ½è¶…è¿‡å»¶æ—¶æ—¶é—´ï¼Œå¦åˆ™ä¼šè·³è¿‡é˜»å¡ä¸€ç›´æ‰§è¡Œ\n\nä»»åŠ¡ä¿¡æ¯åˆ—è¡¨ã€é˜Ÿåˆ—ä¸­æ–­ä¸­æ–­ç®¡ç†å¼€å…³ä¸­æ–­\nå‡½æ•°åç§° portENABLE_INTERRUPTS () portDISABLE_INTERRUPTS() æœ¬è´¨ä¸Šæ˜¯å®å®šä¹‰ï¼Œåœ¨portmacro.hä¸­å®šä¹‰\næ³¨æ„ å¼€ä¸­æ–­å°±æ˜¯å‘BASEPRIå¯„å­˜å™¨å†™å…¥0ï¼ŒBASEPRIå¯„å­˜å™¨æ˜¯ä¸€ä¸ªå¯ç¼–ç¨‹çš„ä¸­æ–­å±è”½å¯„å­˜å™¨ï¼Œå†™å…¥0å°±æ˜¯åœæ­¢å±è”½ä¹Ÿå°±æ˜¯å¼€ï¼Œå…³ä¸­æ–­å°±æ˜¯å†™å…¥configMAX_SYSCALL_INTERRUPT_PRIORITY,æ¯”å¦‚å†™å…¥0x60æ¥å±è”½ä¼˜å…ˆçº§ä½äº0x60çš„ä¸­æ–­\n\n","categories":["FreeRTOS"],"tags":["STM32","ç¬”è®°","FreeRTOS"]},{"title":"luaå­¦ä¹ ç¬”è®°","url":"/2025/06/22/lua%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"å‰è¨€æœ¬æ–‡ä¸»è¦è®°å½•å­¦ä¹ luaä¸­ä¸€äº›æ˜“é”™ï¼Œæ˜“æ··æ·†çš„ç‚¹\n\né€»è¾‘è¿ç®—ç¬¦andå½“ä¸¤ä¸ªå€¼ï¼ˆæ— è®ºæ˜¯æ•°å€¼è¿˜æ˜¯å­—ç¬¦ä¸²ï¼‰vala,valbè¿›è¡Œandè¿ç®—æ—¶è¿ç®—å¼ï¼švala and valb\n\nvala valbéƒ½ä¸ºçœŸï¼ˆä¹Ÿå°±æ˜¯ä¸ä¸ºnilæˆ–falseï¼‰è¿”å›valb\nvala valbæœ‰ä¸€ä¸ªä¸ºnilæˆ–falseï¼Œè¿”å›valaç¤ºä¾‹å½“æœ‰ä¸‰ä¸ªå˜é‡local a = falselocal b = 0local c = 1\nåˆ†åˆ«è¿›è¡Œandè¿ç®—\n\n\nå‡½æ•°\nè¾“å‡º\n\n\n\nprint(b and c)\n1\n\n\nprint(a and b)\nfalse\n\n\nprint(b&gt;-1)\ntrue\n\n\nprint(b &gt; -1 and â€˜yesâ€™)\nyes\n\n\n\n\norå½“ä¸¤ä¸ªå€¼ï¼ˆæ— è®ºæ˜¯æ•°å€¼è¿˜æ˜¯å­—ç¬¦ä¸²ï¼‰vala,valbè¿›è¡Œorè¿ç®—æ—¶è¿ç®—å¼ï¼švala or valb\n\nvala valbä»»æ„ä¸€ä¸ªä¸ºnilæˆ–falseï¼Œè¿”å›ä¸ä¸ºnilæˆ–falseçš„çœŸå€¼\nvala valbéƒ½ä¸ºçœŸè¿”å›vala\nvala valbéƒ½ä¸ºå‡è¿”å›valbç¤ºä¾‹å½“æœ‰å››ä¸ªå˜é‡local a = falselocal b = nillocal c = 0local d = 1\nåˆ†åˆ«è¿›è¡Œorè¿ç®—\n\n\nå‡½æ•°\nè¾“å‡º\n\n\n\nprint(a or c) print(b or c)\n0\n\n\nprint(d or a) print(d or b)\n1\n\n\nprint(c or d)\n0\n\n\nprint(b or c)\n1\n\n\nprint(a or b)\nnil\n\n\nprint(b or a)\nfalse\n\n\n\n\nçŸ­è·¯æ±‚å€¼å½¢å¦‚print(b &gt; 10 and &quot;yes&quot; or &quot;no&quot;)å‡è®¾b&gt;10æ˜¯falseï¼Œå…ˆå’Œ&quot;yes&quot;è¿›è¡Œä¸è¿ç®—ï¼Œå¾—false;å†æˆ–è¿ç®—ï¼Œå¾—&quot;no&quot;å‡è®¾b&gt;10æ˜¯trueï¼Œ å…ˆå’Œ&quot;yes&quot;è¿›è¡Œä¸è¿ç®—ï¼Œå¾—&quot;yes&quot;;å†æˆ–è¿ç®—ï¼Œå¾—&quot;yes&quot;ç¤ºä¾‹\nlocal b = 0print(b &gt; 10 and &quot;yes&quot; or &quot;no&quot;)print(b &gt; -1 and &#x27;yes&#x27; or &#x27;no&#x27;)è¾“å‡ºnoyes","categories":["lua"],"tags":["lua"]},{"title":"å¤§å­¦ç”Ÿæƒ³å…¼èŒèµšé’±å°±åˆ«æŒ‡æœ›è¿˜èƒ½å­¦æŠ€æœ¯","url":"/2025/05/25/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%83%B3%E5%85%BC%E8%81%8C%E8%B5%9A%E9%92%B1%E5%B0%B1%E5%88%AB%E6%8C%87%E6%9C%9B%E8%BF%98%E8%83%BD%E5%AD%A6%E6%8A%80%E6%9C%AF/","content":"å‰è¨€åœ¨5æœˆ21æ—¥ï¼Œæˆ‘æ­£å¼ç»“æŸäº†æˆ‘åœ¨å°‘å„¿ç¼–ç¨‹åŸ¹è®­ç­ï¼ˆä»¥ä¸‹ç®€ç§°æœºæ„ï¼‰çš„å…¼èŒåˆè®¡ä¸‰æ¬¡äº¤ä½œå“â€”â€”350+650+150&#x3D;1150ï¼Œä¸€å…±ä¸ƒä¸ªï¼Œå†æ—¶ä¸‰ä¸ªæœˆï¼Œè®°ä¸€ä¸‹è¿™æ¬¡çš„ç»å†ã€‚å…ˆè¯´ç»“è®ºï¼šå¤§å­¦ç”Ÿå¦‚æœæ˜¯ä¸ºäº†èµšé’±å°±ç›´æ¥å»èµšé’±æœ€å¤šçš„å…¼èŒï¼Œæ¯”å¦‚å®¶æ•™ä¹‹ç±»çš„ï¼Œåˆ«æƒ³ç€å»å¹²è‡ªå·±ä¸“ä¸šç›¸å…³çš„å…¼èŒè¿˜èƒ½èµšé’±ï¼Œä½ çš„æ—¶é—´å¾ˆå®è´µï¼Œè€Œä¸”å®é™…æƒ…å†µå¤§æ¦‚ç‡ä¸æ˜¯ä½ æƒ³çš„é‚£æ ·ã€‚\n\n\nç¬¬ä¸€æ¬¡æ¥è§¦2æœˆ21æ—¥ä»ç¾¤é‡Œçœ‹åˆ°æœ‰ä¸ªæœºæ„éœ€è¦äººï¼Œè´Ÿè´£åˆ¶ä½œåµŒå…¥å¼å°ä½œå“å’Œå¯èƒ½çš„æˆè¯¾ï¼Œçœ‹åˆ°è¿™ä¸ªæ¶ˆæ¯çš„æˆ‘å¾ˆå¼€å¿ƒï¼Œå› ä¸ºè¿™ä¸ªå…¼èŒå’Œæˆ‘çš„ä¸“ä¸šå¾ˆå¥‘åˆï¼Œäºæ˜¯å…´å†²å†²çš„è”ç³»å­¦é•¿ã€‚äº¤äº†ä¸€ä¸ªå°ç®€å†ï¼Œ25å·ç»™äº†æˆ‘æœºæ„è´Ÿè´£äººè€å¸ˆçš„å¾®ä¿¡ï¼ˆä»¥ä¸‹ç®€ç§°hè€å¸ˆï¼‰  \n2æœˆ25æ—¥åŠ ä¸Šå¾®ä¿¡ï¼Œç¡®è®¤äº†é¢è¯•æ—¶é—´åœ¨2æœˆ28æ—¥\n2æœˆ28æ—¥æˆ‘å»çš„å‰ä¸€å¤©ï¼ˆ2.27ï¼‰æ²¡æœ‰å†å’Œhè€å¸ˆç¡®è®¤ï¼Œäºæ˜¯è¢«æ”¾é¸½å­äº†ä¸è¿‡hè€å¸ˆè¯´æœºæ„æœ‰åˆ«çš„è€å¸ˆåœ¨ï¼Œè®©æˆ‘ä¸Šå»è¿˜æ˜¯å»æäº†ä¸€æ¬¡ä¸ä¼¦ä¸ç±»çš„â€œé¢è¯•â€ã€‚æœ€ååªç¡®è®¤äº†ä¸Šç­çš„æ—¶é—´å’Œæˆ‘ä¸»è¦çš„å·¥ä½œï¼Œç»™å°å­¦ç”Ÿåšç§‘åˆ›æ¯”èµ›ä½œå“ã€‚ä½†å…¶å®åé¢å°±æ˜¯æœ‰æ—¶é—´è¦åšä¸œè¥¿æ‰å»ã€‚\n\nä¸€å¼€å§‹å»æ—©äº†ï¼Œè¿˜å’Œæ¥¼ä¸‹ä¿å®‰èŠäº†ä¸€ä¼šï¼Œæœ€åä¼šæåˆ°\n\n3æœˆ3æ—¥æ™šä¸Šå’Œhè€å¸ˆåœ¨å¾®ä¿¡ä¸Šç¡®è®¤äº†è¦å¹²å•¥ï¼Œç”¨Arduinoï¼Œè¿™ä¸ªhè€å¸ˆéå¸¸åœ¨æ„ â€œå¼€æºâ€ï¼Œä»–ç»™æˆ‘ä¸€äº›å…³äºæ¯”èµ›çš„èµ„æ–™å’Œåšçš„é¡¹ç›®éƒ½æ˜¯ä»–è¯´çš„ â€œå¼€æºâ€ã€‚åé¢ä¼šå›æ”¶ä¼ç¬”è¿˜æœ‰åšé¡¹ç›®éœ€è¦çš„ç¡¬ä»¶æˆ‘å…ˆè‡ªå·±ä¹°ï¼Œåé¢ä»–åœ¨è¡¥ç»™æˆ‘\n\nsæ‰€è°“å¼€æºï¼Œç‚¹è¿›å»ä¸€çœ‹ï¼Œæœ‰æƒ³æ³•ï¼Œä»£ç â€”â€”åªæœ‰æˆªå›¾ï¼Œå›¾çº¸â€”â€”åªè¦å›¾ç‰‡ï¼Œä»€ä¹ˆæºæ–‡ä»¶éƒ½æ²¡æœ‰ï¼Œç„¶å â€œå¼€æºâ€\n\næ­£å¼å¼€å·¥æ­£å¼å¼€å·¥å‰æ­£å¼å’Œhè€å¸ˆè§äº†ä¸€é¢ï¼Œäººå¾ˆä¸é”™ï¼Œè¯´è¯ä¹Ÿå®¢æ°”ï¼Œæ²¡æœ‰å› ä¸ºæˆ‘æ˜¯å­¦ç”Ÿå°±æ€ä¹ˆæ ·ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘è™½ç„¶åæ§½ä½†æ˜¯è¿˜æ˜¯è®¤çœŸå¹²æˆ‘è¯¥å¹²çš„æ´»çš„åŸå› ä¹‹ä¸€ç¡®è®¤ä¸‹æ¥ä¸€ä¸ªé¡¹ç›®èµ·ä»·150ï¼Œæ ¹æ®éš¾åº¦ä¸Šè°ƒä»·æ ¼ã€‚  \n3æœˆ11æ—¥å¼€å§‹åšï¼Œå»äº†æœºæ„ï¼Œè¯´æ˜¯ç»™æˆ‘åˆ†é…ç”µè„‘ï¼ˆè¿™ä¸ªæˆ‘ä¸€å¼€å§‹å°±é—®è¿‡ä»–äº†ï¼Œä»–ç»™æˆ‘è¯´ä¸œè¥¿éƒ½æœ‰ï¼‰ï¼Œå…¶å®å°±æ˜¯æœºæ„æˆè¯¾çš„è€å¸ˆçš„ç¬”è®°æœ¬ï¼Œè°ä¸åœ¨å°±æŠŠè°çš„ç»™æˆ‘ï¼Œè€Œä¸”é—®çš„æ—¶å€™å“ªé‡Œçš„è€å¸ˆä¹Ÿä¸æ¸…æ¥šå…·ä½“æƒ…å†µã€‚æ€»çš„æ¥è¯´ï¼Œæˆ‘å°±æ˜¯ç‹¬ç«‹å‡ºæ¥å¹²æ´»ï¼Œå’Œä»–ä»¬æ²¡æœ‰äº¤é›†éå¸¸å¤è€çš„è”æƒ³å•†åŠ¡æœ¬ï¼Œæ²¡æœ‰ç”µæ± ï¼Œå¡çš„æ‰¹çˆ†ã€‚æ ¹æœ¬æ²¡æ³•ç”¨ï¼Œç£¨è¹­äº†ä¸€ä¸‹åˆæˆ‘å°±èµ°äº†ï¼Œåé¢å°±æ˜¯å¸¦è‡ªå·±çš„ç”µè„‘\n3æœˆ19æ—¥åšå®Œäº†ä¸¤ä¸ªï¼Œhè€å¸ˆæ¥çœ‹å®Œè¦ç»™æˆ‘ç»“é’±ï¼Œå› ä¸ºæ˜¯ç¬¬ä¸€æ¬¡æï¼Œæ€ä¹ˆè¦ä»·æˆ‘ä¹Ÿä¸å¥½å¼€å£ï¼Œæœ€åæ˜¯ä¸¤ä¸ªä¸€å…±350ã€‚ä¸ƒç‚¹é’Ÿä»æœºæ„ç¦»å¼€ï¼Œæˆ‘éå¸¸å…´å¥‹ï¼Œå› ä¸ºæ˜¯ç¬¬ä¸€æ¬¡èµšåˆ°é’±ï¼Œè„šæ­¥éƒ½æ˜¯è½»çš„ã€‚è¿™æ®µæ—¶é—´æˆ‘æ¯å¤©ä¸‹åˆä¸‰ç‚¹åˆ°ï¼Œå…­ç‚¹å¤šå¿«ä¸ƒç‚¹èµ°ã€‚\n\nåœ¨è¿™é‡Œåšé¡¹ç›®ï¼Œé¢˜ç›®éƒ½æ˜¯è‡ªå·±æƒ³ï¼Œé™¤äº†å†™ç¨‹åºï¼Œè°ƒç¡¬ä»¶ è¿˜è¦è´Ÿè´£åˆ¶ä½œå¤–è§‚ï¼Œæ’°å†™æ–‡æ¡£ ä¸è¿‡æ˜¯ç»™å°å­¦ç”Ÿåšçš„ï¼Œéƒ½æ¯”è¾ƒç®€å•ï¼Œå¯æ˜¯æ¶ä¸ä½å®ƒäº‹å¤šã€‚æˆ‘ä¹Ÿæ˜¯ç¬¬ä¸€æ¬¡å­¦å»ºæ¨¡å’Œ3dæ‰“å°\n\nä¸­é—´è¿˜æœ‰æ®µå°æ’æ›²ï¼Œhè€å¸ˆé—®æˆ‘æ€ä¹ˆä½¿ç”¨3dæ‰“å°æœºï¼Œå…¶å®æˆ‘ä¹Ÿæ˜¯ç¬¬ä¸€æ¬¡æ¥è§¦å•Šï¼Œè¿™ç§ä¸œè¥¿çœ‹çœ‹å®˜æ–¹çš„ä½¿ç”¨æ–‡æ¡£ä¸å°±çŸ¥é“äº†å—ã€‚äºæ˜¯æ™šä¸Šç»™æˆ‘æ‰“è§†é¢‘è®©æˆ‘æ•™æ€ä¹ˆç”¨ğŸ˜¶\n3æœˆ23æ—¥å‰é¢æ­‡äº†å‡ å¤©ä¹‹å‰æè¿‡ï¼Œè¿™é‡Œåšä¸œè¥¿é¢˜ç›®è¦è‡ªå·±æƒ³ï¼Œäºæ˜¯æˆ‘åˆ°å¤„æŸ¥åˆ›å®¢ç½‘ç«™å’Œç§‘åˆ›æ¯”èµ›è·å¥–åå•æƒ³äº†ä¸‰ä¸ªæ¯™äº†ä¸¤ä¸ªï¼Œå› ä¸ºæ˜¯å¾ˆå¸¸è§çš„ä¸œè¥¿ã€‚hè€å¸ˆè®©æˆ‘å…ˆåšï¼Œäºæ˜¯æˆ‘ä¹°äº†ä¸œè¥¿å‡†å¤‡å¿«é€’åˆ°äº†å°±å»åšï¼Œåœ¨ç­‰å¾…çš„æ—¶å€™hè€å¸ˆå‘Šè¯‰æˆ‘ï¼šæœä¸€ä¸‹è®©ç”Ÿæ´»æ›´ç¾å¥½ä¸»é¢˜ï¼Œæ‰¾ä¸¤ä¸ªé¡¹ç›®æˆ‘:ğŸ˜“ï¼Œæˆ‘é ï¼Œè¿™ç§å®½æ³›çš„ä¸»é¢˜è¯´äº†å’Œæ²¡è¯´æœ‰å•¥ä¸¤æ ·ä¸è¿‡æœ€åè¿˜æ˜¯å‡‘äº†ä¿©ä¸Šå»ï¼Œä¸­é—´ä»–å’Œæˆ‘è¯´ï¼Œåšä¸œè¥¿è¦å¾€å¤§åš\n4æœˆ15æ—¥è¿™ä¸‰ä¸ªåšçš„å·®ä¸å¤šäº†ï¼Œä»–å‘Šè¯‰æˆ‘å†åšä¸€ä¸ªåœè½¦åœºçš„ï¼Œè¿™æ¬¡å¤–è§‚ä¸æ˜¯3dæ‰“å°äº†ï¼Œè€Œæ˜¯ç»çº¤æ¿åˆ‡å‰²ç»„è£…ï¼Œä¸ºäº†è¿™ä¸ªæˆ‘åˆå»å­¦ä¹ å¼€æºçš„CADè½¯ä»¶libreCAD\n4æœˆ25æ—¥ä¸­é—´æ—¶é—´è¦ç»„è£…å‰ä¸‰ä¸ªï¼Œè¿˜è¦è°ƒè¯•ç¬¬å››ä¸ªçš„ç¡¬è½¯ä»¶ï¼Œè¿™å¤©æˆ‘æ‰æŠŠå›¾çº¸ç”»å‡ºæ¥ï¼Œåˆæ­£é€¢äº”ä¸€å‡æœŸï¼Œç­‰åˆ°åˆ‡å‰²çš„æ ·æ¿åˆ°ï¼Œå·²ç»æ˜¯5.5äº†\n5æœˆ5æ—¥æˆ‘åˆ°æœºæ„ä¸€çœ‹æ ·æ¿ï¼ˆæœ¨æ¿åˆ‡å‰²çš„ï¼‰å‘ç°hè€å¸ˆæŠŠæˆ‘çš„å›¾å±‚éƒ½åˆå¹¶åœ¨ä¸€èµ·äº†ï¼Œå¯¼è‡´å¤§éƒ¨åˆ†åœ°æ–¹éƒ½åˆ‡é”™äº†ï¼Œæˆ‘ä¹Ÿæ²¡è¯´ï¼Œå¤§æ¦‚ç»„è£…äº†ä¸€ä¸‹å‘ç°æ²¡å¤§é—®é¢˜ï¼Œå†æŠŠå°é—®é¢˜ä¿®æ”¹äº†ä¸€ä¸‹ã€‚åé¢æˆ‘é—®ä»–ä½¿ç”¨ç»çº¤æ¿åˆ‡å‰²çš„è¯å…¬å·®è¦ç•™å¤šå°‘åˆé€‚ï¼Œç­”æ¡ˆæ˜¯æ²¡æœ‰\n\nå››æœˆä¸­æ—¬çš„æ—¶å€™æˆ‘è¯´æˆ‘æš‘å‡è¦å»å®ä¹ ï¼Œhè€å¸ˆè¯´æœ¬æ¥æ˜¯æƒ³è®©æˆ‘æš‘å‡æŠŠæˆ‘åšçš„é¡¹ç›®æ•™ç»™å°æœ‹å‹ï¼Œç„¶åå†å¼€ä¸€ä¸ªä½¿ç”¨3dæ‰“å°æœºçš„è¯¾ç¨‹ã€‚æˆ‘è¡¨ç¤ºæš‘å‡åº”è¯¥ä¸ç•™ï¼Œä»–è¯´åˆ°æ—¶å€™å†è¯´å§\n\n5æœˆ7æ—¥hè€å¸ˆé—®æˆ‘äº”æœˆæ˜¯ä¸æ˜¯å†åšä¸€äº›ï¼Œæˆ‘ç­”åº”äº†ï¼Œåé¢çœ‹æ¥å…¶å®éå¸¸ä¸åº”è¯¥ï¼Œåšå®Œæ‰‹å¤´çš„å°±åº”è¯¥ç›´æ¥å‘Šè¾ï¼Œåé¢å°±æ˜¯æŠ˜ç£¨ã€‚ç„¶åæˆ‘åˆæƒ³äº†ä¸€ä¸ªï¼Œè¿˜æ˜¯ä¹°ä¸œè¥¿ç­‰å¿«é€’\n\nè¿™ä¸­é—´å‘ç”Ÿäº†å¾ˆæç¬‘çš„äº‹ï¼Œæˆ‘è¯´äº†ä¸€ä¸ªåŒäººå¯¹æˆ˜å£ç®—æœºçš„æƒ³æ³•ï¼Œä»–å…ˆæ˜¯è¯´è¿™ä¸ªå¹´å¹´æœ‰äººåšï¼Œå½“æˆ‘è¯´è¿™ä¸ªæˆ‘æœäº†æ²¡è§è¿‡å’Œç±»ä¼¼çš„ä¸œè¥¿åï¼Œä»–åˆæ”¹å£ï¼šç¡®å®ä¸å¸¸è§ï¼Œç„¶åé—®æˆ‘æ˜¯ä¸æ˜¯ â€œå¼€æºâ€ çš„ã€‚æˆ‘æ˜¯è¿™ä¸ªæ˜¯æˆ‘è‡ªå·±æƒ³çš„ï¼Œè€Œä¸”ä¹‹å‰åšçš„ä¹Ÿéƒ½æ˜¯åªæœ‰æƒ³æ³•ï¼Œæ²¡æœ‰æºç å’Œå¤–å£³æ–‡ä»¶åªèƒ½è‡ªå·±åšã€‚ä»–å›æˆ‘â€”â€”â€œğŸ‘ï¼Œäººæ‰â€\n\n5æœˆ13æ—¥ç»çº¤æ¿ç»ˆäºå›æ¥äº†ï¼Œæˆ‘è£…äº†ä¸¤ä¸ªä¸‹åˆï¼Œä¸»è¦æ˜¯æˆ‘æ²¡åŠ å…¬å·®ï¼Œæ¯”å¦‚ä¸€ä¸ªæ’ä»¶é‚£ç§å°±è¦ç•™ä¸€ç‚¹ä½™é‡ã€‚ç„¶åå’Œä»–è¯´äº†åé¢çš„å®‰æ’ï¼Œæ˜ç¡®äº†æˆ‘äº”æœˆå¹²å®Œå°±è¦èµ°ã€‚ç„¶åç»™æˆ‘ç»“äº†é’±ï¼Œå‰ä¸‰ä¸ªå„150ï¼Œç¬¬å››ä¸ª200ã€‚ç»“å®Œé’±å’Œæˆ‘è¯´ä¸‹æ¬¡æ¥åšä¸ªå°è½¦ï¼Œå…·ä½“å½“é¢å’Œæˆ‘è¯´\n5æœˆ19æ—¥å’Œhè€å¸ˆè§äº†ä¸€é¢ï¼Œæˆ‘è¡¨ç¤ºå¦‚æœå°è½¦å¤ªéš¾ææˆ‘å¯èƒ½æ²¡æ—¶é—´åšäº†ï¼Œä»–è¡¨ç¤ºç†è§£ç„¶åæ™šä¸Šç»™æˆ‘å‘äº†ä¸€ä¸ªé“¾æ¥æˆ‘å½“æ—¶çœ‹å®Œéƒ½å‚»çœ¼äº†ï¼Œå‘Šè¯‰ä»–æˆ‘åšä¸äº†\n5æœˆ20æ—¥æœ€åä¸€ä¸ªä¹Ÿåšå®Œäº†ã€‚æŠŠæºç ï¼Œå¤–å£³æ¨¡å‹æ–‡ä»¶ï¼Œæ‰‹å†Œå•¥çš„éƒ½æ•´ç†å¥½äº†ã€‚éªŒæ”¶äº†ä¸€ä¸‹ï¼Œç»™æˆ‘ç»“å®Œæœ€åä¸€ä¸ª150ï¼Œæˆ‘å°±èµ°äº†ã€‚èµ°çš„æ—¶å€™è¿˜å’Œæ¥¼ä¸‹ä¿å®‰èŠäº†å‡ å¥ï¼Œæ€»ç»“å°±æ˜¯è¿™é‡ŒæŒ£ä¸åˆ°ä»€ä¹ˆé’±è¿˜æµªè´¹æ—¶é—´\nå›é¡¾ä¸æ€»ç»“å†æ—¶å·®ä¸å¤šä¸‰ä¸ªæœˆï¼Œæˆ‘å»æ¯æ¬¡å»æœºæ„éƒ½æ˜¯å…¬äº¤é€šå‹¤ï¼Œè·¯ä¸Šè¦å€’è½¦ï¼Œæ¥å›ä¸€æ¬¡4å—ã€‚ä¸¤ç‚¹å¤šä»å­¦æ ¡èµ°ï¼Œä¸‰ç‚¹åˆ°æœºæ„ï¼Œä¸€èˆ¬éƒ½æ˜¯åšåˆ°å…­ç‚¹å¤šæ‰èµ°ï¼Œç­‰å›å­¦æ ¡æ—¶éƒ½ä¸ƒå…«ç‚¹äº†ï¼Œæœ‰å‡ æ¬¡æå¿˜æ—¶é—´ï¼Œç­‰å›å­¦æ ¡å·²ç»ä¹ç‚¹äº†ã€‚åœ¨é‚£é‡Œä¸èƒ½è¯´å•¥ä¹Ÿæ²¡å­¦åˆ°ï¼Œä¸ºäº†åšä¸œè¥¿è¿˜æ˜¯è‡ªå­¦äº†ä¸€ç‚¹æŠ€èƒ½ï¼Œä¸è¿‡å’Œæˆ‘æµªè´¹æ‰çš„æ—¶é—´æ¯”çœŸä¸ç®—ä»€ä¹ˆã€‚ä¸ºäº†åšæœºæ„çš„é¡¹ç›®ï¼Œæœ‰æ—¶å€™é—²ç€è¿˜æƒ³æƒ³é¢˜ç›®ï¼Œè¿˜æ˜¯æœ‰ç‚¹æŠ˜ç£¨çš„ã€‚äº”æœˆä¸­æˆ‘è¿˜å‡†å¤‡æš‘å‡å®ä¹ ï¼Œå…¶å®å·²ç»æœ‰ç‚¹æ™šäº†ï¼Œè€Œä¸”æˆ‘ä¹Ÿæ²¡æœ‰è‡ªå·±çš„é¡¹ç›®ï¼Œç®€å†ä¸Šç©ºç©ºè¡è¡çš„å“ˆå“ˆå“ˆï¼Œå¦‚æœä½ è¦å‡†å¤‡å®ä¹ çš„è¯è¿˜æ˜¯ä¸è¦æµªè´¹æ—¶é—´ï¼Œåšä¸€äº›èƒ½å±•ç°æ°´å¹³çš„ä¸œè¥¿ï¼Œç»™å°å­¦ç”Ÿåšçš„å°ä¸œè¥¿æ²¡å•¥ç”¨ã€‚\næœ€åï¼Œé’±ä¹Ÿæ²¡æŒ£åˆ°ï¼Œæ—¶é—´æµªè´¹è®¸å¤šï¼Œè™½ç„¶æœ‰ä¸€ç‚¹æ”¶è·ï¼Œä½†æ€»ä½“æ˜¯äºçš„\næ–‡ç« æ ‡é¢˜å…¶å®æ˜¯æš´è®ºï¼Œäº‹å®ä¹Ÿå¯èƒ½æ²¡é‚£ä¹ˆç³Ÿã€‚\n","categories":["æ—¥å¸¸ç”Ÿæ´»"],"tags":["æ—¥å¸¸ç”Ÿæ´»","å…¼èŒ","å¤§å­¦ç”Ÿ","éšæƒ³"]},{"title":"ARMGCCå·¥å…·é“¾ä¸‹DMAæ¥æ”¶ä¸åˆ°æ•°æ®çš„åŸå› ä¸è§£å†³æ–¹æ³•","url":"/2025/08/03/ARMGCC%E5%B7%A5%E5%85%B7%E9%93%BE%E4%B8%8BDMA%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%88%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8E%9F%E5%9B%A0%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"&#x524D;&#x8A00;&#x5E73;&#x53F0;&#xFF1A;STM32H750vbt6&#x5C06;&#x539F;&#x6765;&#x5728;keil&#x4E0B;&#x914D;&#x7F6E;&#x7684;DCMI&#x6444;&#x50CF;&#x5934;&#x4F8B;&#x7A0B;&#xFF08;DMA1&#x642C;&#x6570;&#x636E;&#xFF0C;SPI&#x9A71;&#x52A8;&#x5C4F;&#x5E55;&#x5237;&#x65B0;&#xFF09;&#x8FC1;&#x79FB;&#x5230;arm-gnu-toolchain&#x540E;&#xFF0C;&#x51FA;&#x73B0;&#x4E86;DCMI&#x65E0;&#x6CD5;&#x4F20;&#x8F93;&#x6570;&#x636E;&#x7684;&#x95EE;&#x9898;&#x3002;&#x4E00;&#x5F00;&#x59CB;&#x4EE5;&#x4E3A;&#x662F;&#x5DE5;&#x5177;&#x94FE;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x4E00;&#x756A;&#x6392;&#x67E5;&#x540E;&#x53D1;&#x73B0;&#x662F;DCMI&#x914D;&#x7F6E;&#x7684;DMA&#x4F20;&#x8F93;&#x5931;&#x8D25;&#x3002;&#x7F51;&#x4E0A;&#x641C;&#x7D22;&#x540E;&#x53D1;&#x73B0;&#x6709;&#x7C7B;&#x4F3C;&#x95EE;&#x9898;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x56E0;&#x4E3A;DMA&#x65E0;&#x6CD5;&#x8BBF;&#x95EE;DTCM&#x533A;&#xFF0C;&#x800C;ST&#x7684;cubemx&#x81EA;&#x52A8;&#x751F;&#x6210;&#x7684;makefile&#x5DE5;&#x7A0B;&#x91CC;&#x81EA;&#x5E26;&#x7684; .ld &#x94FE;&#x63A5;&#x6587;&#x4EF6;&#x9ED8;&#x8BA4;&#x5C06;&#x7533;&#x8BF7;&#x7684;&#x9759;&#x6001;&#x6570;&#x7EC4;&#x90FD;&#x653E;&#x5728;DTCM&#x533A;&#x3002;\n/* Initialized data sections goes into RAM, load LMA copy after code */.data : {  . = ALIGN(4);  _sdata = .;        /* create a global symbol at data start */  *(.data)           /* .data sections */  *(.data*)          /* .data* sections */  . = ALIGN(4);  _edata = .;        /* define a global symbol at data end */} &gt;DTCMRAM AT&gt; FLASH/* Uninitialized data section */. = ALIGN(4);.bss :{  /* This is used by the startup in order to initialize the .bss secion */  _sbss = .;         /* define a global symbol at bss start */  __bss_start__ = _sbss;  *(.bss)  *(.bss*)  *(COMMON)  . = ALIGN(4);  _ebss = .;         /* define a global symbol at bss end */  __bss_end__ = _ebss;} &gt;DTCMRAM/* User_heap_stack section, used to check that there is enough RAM left */._user_heap_stack :{  . = ALIGN(8);  PROVIDE ( end = . );  PROVIDE ( _end = . );  . = . + _Min_Heap_Size;  . = . + _Min_Stack_Size;  . = ALIGN(8);} &gt;DTCMRAM\n\n&#x89E3;&#x51B3;&#x529E;&#x6CD5;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x5F00;cache&#xFF0C;&#x5C31;&#x76F4;&#x63A5;&#x4FEE;&#x6539; .ld &#x6587;&#x4EF6;&#xFF0C;&#x52A0;&#x5165;&#x81EA;&#x5B9A;&#x4E49;&#x6BB5;.AXI_RAM_D1 &#x6BB5;&#x540D;&#xFF0C; RAM_D1 &#x5728; .ld &#x6587;&#x4EF6;&#x5F00;&#x5934;\n/* &#x6307;&#x5411;RAM&#xFF0C;RAM_D1 (xrw)      : ORIGIN = 0x24000000, LENGTH = 512K *//* &#x9002;&#x7528;&#x4E8E;dma&#x8BBF;&#x95EE;&#x6570;&#x636E;&#xFF0C;dma1 2&#x90FD;&#x53EA;&#x80FD;&#x8BBF;&#x95EE;AXI SRAM&#xFF0C;&#x6240;&#x4EE5;&#x5B9A;&#x4E49;&#x7684;&#x6570;&#x7EC4;&#x4E4B;&#x7C7B;&#x7684;&#x6587;&#x4EF6;&#x5FC5;&#x987B;&#x6307;&#x5B9A;&#x5230;&#x6B64;&#x533A;&#x57DF; *//* (NOLOAD)&#x6307;&#x5B9A;&#x6B64;&#x6BB5;&#x4E0D;&#x9700;&#x8981;&#x521D;&#x59CB;&#x5316; */.AXI_RAM_D1(NOLOAD) :{  /* &#x56DB;&#x5B57;&#x8282;&#x5BF9;&#x9F50; */  /*. = ALIGN(4);  . = ALIGN(4);*/  *(.AXI_RAM_D1)} &gt;RAM_D1\n\n&#x5728;&#x4E00;&#x4E2A;&#x5408;&#x9002;&#x7684;&#x4F4D;&#x7F6E;&#x7F16;&#x5199;&#x4E00;&#x4E0B;&#x7684;&#x5185;&#x5BB9;&#x4F7F;&#x7528;&#x65B9;&#x5F0F;&#x5982;&#x4E0B;&#xFF0C;&#x8FD9;&#x91CC;&#x7684; .AXI_RAM_D1 &#x4E0E;&#x4E0A;&#x9762;&#x81EA;&#x5B9A;&#x4E49;&#x7684;&#x6BB5;&#x5FC5;&#x987B;&#x8981;&#x4E00;&#x6837;&#xFF0C; __attribute__ &#x548C;&#x4E4B;&#x540E;&#x7684;&#x4E1C;&#x897F;&#x53EA;&#x8981;&#x653E;&#x5728; &#x4EE3;&#x7801;&#x7ED3;&#x675F;&#x7B26;&#x53F7;**; ** &#x4E4B;&#x524D;&#x5C31;&#x884C; __attribute__((section(&quot;.AXI_RAM_D1&quot;))) uint16_t pic0[160 * 120];\n&#x4E3A;&#x4EC0;&#x4E48;keil&#x4E0B;&#x5C31;&#x4E0D;&#x4F1A;&#x6709;&#x8FD9;&#x95EE;&#x9898;&#x5982;&#x56FE;&#x6240;&#x793A; IRAM1 &#x7684;&#x5730;&#x65B9;&#x6253;&#x52FE;&#x4E86;&#xFF0C;&#x5982;&#x679C;&#x53D6;&#x6D88;&#x52FE;&#x9009;&#xFF0C;&#x90A3;&#x4E48;keil&#x4E0B;&#x4E5F;&#x4E00;&#x6837;&#x65E0;&#x6CD5;&#x5411;&#x5206;&#x914D;&#x7684;&#x5728;DTCM&#x533A;&#x7684;&#x6570;&#x7EC4;&#x5199;&#x6570;&#x636E;\n\n&#x63A8;&#x8350;&#x4E00;&#x4E2A;&#x5B9E;&#x7528;&#x6587;&#x6863;LAT0816_STM32CubeIDE&#x5B9E;&#x7528;&#x6280;&#x5DE7;&#x4E4B;ld&#x94FE;&#x63A5;&#x6587;&#x4EF6;_v1.0\n","categories":["STM32"],"tags":["STM32","ARMGCC"]},{"title":"ESP32å­¦ä¹ è®°å½•","url":"/2025/08/13/esp32%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"&#x524D;&#x8A00;&#x4E3B;&#x8981;&#x8BB0;&#x5F55;&#x5728;&#x5B66;&#x4E60;esp32&#x4E2D;&#x9047;&#x5230;&#x7684;&#x95EE;&#x9898;&#x548C;&#x5916;&#x8BBE;&#x6A21;&#x5757;&#x9A71;&#x52A8;&#x5982;&#x4F55;&#x7F16;&#x5199;&#x5F3A;&#x70C8;&#x5EFA;&#x8BAE;&#x5728;&#x9605;&#x8BFB;&#x672C;&#x6587;&#x6863;&#x524D;&#x5148;&#x6253;&#x5F00;&#x5B98;&#x65B9;&#x624B;&#x518C;&#x5F88;&#x591A;&#x4EE3;&#x7801;&#x548C;&#x914D;&#x7F6E;&#x90FD;&#x662F;&#x53C2;&#x8003;&#x4E86;DuRuofu&#x5927;&#x4F6C;&#x7684;ESP32-Guide&#xFF0C;&#x53EF;&#x4EE5;&#x4F5C;&#x4E3A;&#x8865;&#x5145;&#x9605;&#x8BFB;\nnote:&#x7B14;&#x8005;&#x5BF9;esp32&#x7684;&#x529F;&#x80FD;&#x4E5F;&#x4EC5;&#x4EC5;&#x662F;&#x5904;&#x5728;&#x4F1A;&#x8C03;&#x7528;api&#x800C;&#x5DF2;&#xFF0C;&#x5B9E;&#x529B;&#x6709;&#x9650;&#x3002;&#x5BF9;&#x4E8E;&#x672C;&#x6587;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x9519;&#x8BEF;&#x8FD8;&#x8BF7;&#x89C1;&#x8C05;&#xFF0C;&#x5982;&#x679C;&#x60F3;&#x4EA4;&#x6D41;&#x53EF;&#x4EE5;&#x53D1;&#x90AE;&#x4EF6;(rzjzwd@outlook.com)&#x6216;&#x8005;&#x8BC4;&#x8BBA;&#x533A;&#x7559;&#x8A00;&#xFF08;&#x53EF;&#x80FD;&#x6CA1;&#x6709;&#x8BC4;&#x8BBA;&#x533A;&#xFF09;\n\n&#x5916;&#x8BBE;LEDPWM&#x8FD9;&#x4E2A;&#x5916;&#x8BBE;&#x53EF;&#x4EE5;&#x7528;&#x4E8E;&#x63A7;&#x5236;LED&#x547C;&#x5438;&#x706F;&#xFF0C;&#x4F46;&#x662F;&#x672C;&#x6587;&#x6863;&#x4E2D;&#x4E3B;&#x8981;&#x7528;&#x6765;&#x5BF9;&#x8235;&#x673A;&#x8FDB;&#x884C;&#x7B80;&#x5355;&#x7684;&#x63A7;&#x5236;&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;&#x5728;&quot;driver/ledc.h&quot;&#x4E2D;\n&#x53C2;&#x6570;&#x914D;&#x7F6E;\n&#x521D;&#x59CB;&#x5316;&#x5B9A;&#x65F6;&#x5668;ledc_timer_config_t timerCig = {    .speed_mode = LEDC_LOW_SPEED_MODE,      //&#x8BBE;&#x7F6E;&#x901F;&#x5EA6;    .duty_resolution = LEDC_TIMER_13_BIT,   //&#x7CBE;&#x5EA6;    .timer_num = LEDC_TIMER_0,              //&#x5B9A;&#x65F6;&#x5668;0    .freq_hz = 50,                          //&#x9891;&#x7387;50hz    .clk_cfg = LEDC_AUTO_CLK                //&#x65F6;&#x949F;&#x6E90;&#x8BBE;&#x7F6E;};ledc_timer_config(&amp;timerCig);          //&#x8BBE;&#x7F6E;\n&#x914D;&#x7F6E;&#x901A;&#x9053;ledc_channel_config_t channelCfg = {                        .gpio_num = gpioPin,                //gpio&#x53E3;            .speed_mode = LEDC_LOW_SPEED_MODE,  //&#x901F;&#x5EA6;            //&#x901A;&#x9053;&#x8BBE;&#x7F6E;&#xFF0C;&#x4E00;&#x4E2A;&#x5B9A;&#x65F6;&#x5668;&#x6709;&#x516B;&#x4E2A;&#x9AD8;&#x901F;&#x901A;&#x9053;&#x548C;&#x516B;&#x4E2A;&#x4F4E;&#x901F;&#x901A;&#x9053;            .channel = i,                                   .timer_sel = LEDC_TIMER_0,          //&#x8BBE;&#x7F6E;&#x5B9A;&#x65F6;&#x5668;            .duty = 0        };ledc_channel_config(&amp;channelCfg);       //&#x8BBE;&#x7F6E;\n&#x8BBE;&#x7F6E;&#x5360;&#x7A7A;&#x6BD4;&#x51FD;&#x6570;ledc_set_duty(LEDC_LOW_SPEED_MODE, ch, duty);ledc_update_duty(LEDC_LOW_SPEED_MODE, ch);\nch&#x662F;&#x901A;&#x9053;&#xFF0C;&#x6BCF;&#x4E2A;&#x901A;&#x9053;&#x5BF9;&#x5E94;&#x4E00;&#x4E2A;pwm&#x8F93;&#x51FA;io,duty&#x5C31;&#x662F;&#x5360;&#x7A7A;&#x6BD4;\n\n&#x8235;&#x673A;&#x63A7;&#x5236;&#x5B9E;&#x6218;//servo_driver.h#ifndef _SERVO_DRIVER_H_#define _SERVO_DRIVER_H_#include &lt;stdint.h&gt;#define SERVO_NUMS (8)#ifdef __cplusplusextern &quot;C&quot; {#endif typedef struct{    uint8_t gpioPin;     float minAngleDeg;            float maxAngleDeg;            uint16_t minPulseOfUs;    uint16_t maxPulseOfUs;} servoConfig_t;//&#x9519;&#x8BEF;&#x7801;typedef enum {    SERVO_OK = 0,    SERVO_ERR_INVALID_ID,   //&#x4E0D;&#x5B58;&#x5728;&#x7684;&#x8235;&#x673A;&#x53F7;    SERVO_ERR_ANGLE_OUT_OF_RANGE    //&#x89D2;&#x5EA6;&#x8D85;&#x8FC7;&#x9608;&#x503C;} servoErrorCode_t;/** * @brief &#x521D;&#x59CB;&#x5316;&#x8235;&#x673A; * @param servoConfig &#x8235;&#x673A;&#x53C2;&#x6570; * @param servoNums &#x8235;&#x673A;&#x6570;&#x91CF; */void servo_init(const servoConfig_t *Config, uint8_t servoNums);/** * @brief &#x8BBE;&#x7F6E;&#x5355;&#x4E2A;&#x8235;&#x673A;&#x89D2;&#x5EA6; * @param servoId &#x8235;&#x673A;&#x53F7; * @param angleDeg &#x89D2;&#x5EA6; */int servo_set_angle(uint8_t servoId, float angleDeg);/** * @brief &#x6279;&#x91CF;&#x8BBE;&#x7F6E;&#x8235;&#x673A;&#x89D2;&#x5EA6; * @param angles &#x89D2;&#x5EA6; * @param servoNums &#x8235;&#x673A;&#x6570; */void servo_set_all_angles(const float* angles, uint8_t servoNums);#ifdef __cplusplus}#endif #endif\n\n//servo_driver.c#include &quot;servo_driver.h&quot;#include &quot;driver/ledc.h&quot;#include &quot;esp_log.h&quot;#define TAG &quot;SERVO_DRIVE&quot;typedef struct {    const servoConfig_t *servoConfigs;    uint8_t servoNums;    ledc_channel_config_t *servoChannels;} servoDriverCtx_t;static servoDriverCtx_t servoDriverCtx;/** * @brief &#x89D2;&#x5EA6;&#x8F6C;&#x5360;&#x7A7A;&#x6BD4; * @param servoId &#x8235;&#x673A;&#x53F7; * @param angleDeg &#x89D2;&#x5EA6; * @return &#x5360;&#x7A7A;&#x6BD4; */static uint32_t angle2duty(uint8_t servoId, float angleDeg){    //&#x53D6;&#x8235;&#x673A;&#x53F7;&#x5BF9;&#x5E94;&#x53C2;&#x6570;&#x7684;&#x6307;&#x9488;&#x7ED9;a2dConfig    const servoConfig_t *a2dConfig = &amp;servoDriverCtx.servoConfigs[servoId];    //&#x89D2;&#x5EA6;&#x9650;&#x5236;    if(angleDeg &lt; a2dConfig-&gt;minAngleDeg){        angleDeg = a2dConfig-&gt;minAngleDeg;    }else if(angleDeg &gt;a2dConfig-&gt;maxAngleDeg){        angleDeg = a2dConfig-&gt;maxAngleDeg;    }else        angleDeg = angleDeg;    //&#x8BA1;&#x7B97;&#x8109;&#x51B2;    float pluseOfUs = a2dConfig-&gt;minPulseOfUs +                      (angleDeg - a2dConfig-&gt;minAngleDeg) *                          (a2dConfig-&gt;maxPulseOfUs - a2dConfig-&gt;minPulseOfUs) /                          (a2dConfig-&gt;maxAngleDeg - a2dConfig-&gt;minAngleDeg);    //pluseOfUs * 1e-6,&#x628A;us&#x8F6C;&#x6362;&#x4E3A;s    //&#x5B9A;&#x65F6;&#x5668;&#x603B;&#x8BA1;&#x6570;&#x503C;(2^13) * &#x4FE1;&#x53F7;&#x9891;&#x7387;&#xFF08;50hz&#xFF09;    //&#x4EE5;&#x4E0A;&#x4E24;&#x4E2A;&#x76F8;&#x4E58;&#x5F97;&#x5360;&#x7A7A;&#x6BD4;    return (uint32_t)((pluseOfUs * 1e-6) * ((1 &lt;&lt; LEDC_TIMER_13_BIT) - 1) * 50);}void servo_init (const servoConfig_t *Config, uint8_t servoNums){    servoDriverCtx.servoConfigs = Config;    servoDriverCtx.servoNums = servoNums;    //&#x521D;&#x59CB;&#x5316;LEDC&#x5B9A;&#x65F6;&#x5668;    ledc_timer_config_t servoTimerCig = {        .speed_mode = LEDC_LOW_SPEED_MODE,        .duty_resolution = LEDC_TIMER_13_BIT,        .timer_num = LEDC_TIMER_0,        .freq_hz = 50,        .clk_cfg = LEDC_AUTO_CLK    };    ledc_timer_config(&amp;servoTimerCig);    //&#x914D;&#x7F6E;&#x901A;&#x9053;    servoDriverCtx.servoChannels = malloc(servoNums * sizeof(ledc_channel_config_t));    //&#x6309;&#x8235;&#x673A;&#x6570;&#x91CF;&#xFF0C;&#x901A;&#x9053;&#x7ED3;&#x6784;&#x4F53;&#x5927;&#x5C0F;&#x7533;&#x8BF7;&#x5185;&#x5B58;    for (int i = 0; i &lt; servoNums; i++){        //&#x6309;&#x6570;&#x7EC4;&#x8BBF;&#x95EE;&#x65B9;&#x5F0F;&#x5199;&#x5165;        servoDriverCtx.servoChannels[i] = (ledc_channel_config_t){            .gpio_num = Config[i].gpioPin,            .speed_mode = LEDC_LOW_SPEED_MODE,            .channel = i,            .timer_sel = LEDC_TIMER_0,            .duty = 0        };        ledc_channel_config(&amp;servoDriverCtx.servoChannels[i]);    }}int servo_set_angle (uint8_t servoId, float angleDeg){    static servoErrorCode_t servoErrorCode;        //&#x68C0;&#x67E5;&#x8235;&#x673A;&#x53F7;&#x5408;&#x6CD5;&#x6027;    if(servoId &gt;=servoDriverCtx.servoNums){        ESP_LOGE(TAG, &quot;Invalid servo ID: %d&quot;, servoId);        servoErrorCode = SERVO_ERR_INVALID_ID;        return servoErrorCode;    }    //&#x68C0;&#x67E5;&#x89D2;&#x5EA6;&#x5408;&#x6CD5;&#x6027;    const servoConfig_t *Config = &amp;servoDriverCtx.servoConfigs[servoId];    if(angleDeg &lt; Config-&gt;minAngleDeg || angleDeg &gt; Config-&gt;maxAngleDeg){        ESP_LOGE(TAG, &quot;Servo %d angle %.1f out of range [%.1f, %.1f]&quot;,                 servoId, angleDeg, Config-&gt;minAngleDeg, Config-&gt;maxAngleDeg);        servoErrorCode = SERVO_ERR_ANGLE_OUT_OF_RANGE;        return servoErrorCode;    }    uint32_t duty = angle2duty(servoId, angleDeg);    ledc_set_duty(LEDC_LOW_SPEED_MODE, servoId, duty);    ledc_update_duty(LEDC_LOW_SPEED_MODE, servoId);    servoErrorCode = SERVO_OK;    return servoErrorCode;}void servo_set_all_angles(const float* angles, uint8_t servoNums){    for (int i = 0; i &lt; servoNums; i++){        servo_set_angle(i, angles[i]);    }    }\n&#x5B9E;&#x9645;&#x5E94;&#x7528;&#xFF0C;&#x4EE5;&#x540C;&#x65F6;&#x63A7;&#x5236;&#x516B;&#x4E2A;&#x8235;&#x673A;&#x4E3A;&#x4F8B;\n//&#x6570;&#x7EC4;&#x7ED3;&#x6784;&#x4F53;&#x6210;&#x5458;&#xFF0C;gpio&#xFF0C;&#x6700;&#x5C0F;&#x89D2;&#x5EA6;&#xFF0C;&#x6700;&#x5927;&#x89D2;&#x5EA6;&#xFF0C;&#x6700;&#x5C0F;&#x8109;&#x51B2;&#xFF0C;&#x6700;&#x5927;&#x8109;&#x51B2;servoConfig_t servoConfigse[SERVO_NUMS] = {    {18, 0, 90, 500, 2500},    {19, 0, 180, 500, 2500},    {16, 90, 180, 500, 2500},    {17, 0, 180, 500, 2500},    {26, 0, 90, 500, 2500},    {27, 0, 180, 500, 2500},    {33, 90, 180, 500, 2500},    {32, 0, 180, 500, 2500},};servo_init(servoConfigse, SERVO_NUMS);\n\nUART esp32&#x4E2D;&#x7684;&#x4E32;&#x53E3;&#x6709;&#x4E09;&#x4E2A;&#xFF0C;UART0&#x662F;&#x4F5C;&#x4E3A;&#x4E0B;&#x8F7D;&#xFF0C;&#x8C03;&#x8BD5;&#x4E32;&#x53E3;&#x4F7F;&#x7528;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x6B21;&#x7528;&#x7684;&#x662F;&#x4E32;&#x53E3;2&#x3002;&#x76F8;&#x5173;&#x914D;&#x7F6E;&#x51FD;&#x6570;ESP&#x5B98;&#x65B9;&#x5DF2;&#x7ECF;&#x63D0;&#x4F9B;&#x4E86;&#xFF0C;&#x4E0B;&#x9762;&#x7684;&#x6587;&#x4EF6;&#x5F53;&#x4E2D;\n#include &quot;driver/uart.h&quot;\n\n&#x53C2;&#x6570;&#x8BBE;&#x7F6E;&#x9A71;&#x52A8;&#x5206;&#x4E3A;&#x4E09;&#x6B65;\n\nUART&#x9A71;&#x52A8;&#x6CE8;&#x518C;uart_driver_install(uart_port_t uart_num,   //&#x4E32;&#x53E3;&#x53F7;                    int rx_buffer_size,     //&#x63A5;&#x6536;&#x7AEF;&#x7F13;&#x51B2;&#x533A;                    int tx_buffer_size,     //&#x53D1;&#x9001;&#x7AEF;&#x7F13;&#x51B2;&#x533A;                    int event_queue_size,   //&#x961F;&#x5217;&#x5927;&#x5C0F;&#xFF0C;&#x6CA1;&#x6709;&#x5199;0                    QueueHandle_t *uart_queue, //&#x961F;&#x5217;&#x53E5;&#x67C4;&#xFF0C;&#x6CA1;&#x6709;&#x5199;NULL                    int intr_alloc_flags    //&#x4E2D;&#x65AD;&#x6807;&#x5FD7;&#xFF0C;&#x4E0D;&#x9700;&#x8981;&#x5C31;0                    )   \n&#x793A;&#x4F8B;&#xFF1A;uart_driver_install(2, 1024*2, 0, 0, NULL, 0)\nUART&#x53C2;&#x6570;&#x8BBE;&#x7F6E;uart_param_config(uart_port_t uart_num,         //&#x4E32;&#x53E3;&#x53F7;                const uart_config_t *uart_config//&#x53C2;&#x6570;&#x7ED3;&#x6784;&#x4F53;&#x6307;&#x9488;                )\n\n&#x53C2;&#x6570;&#x7ED3;&#x6784;&#x4F53;&#xFF1A;\nuart_config_t uartConfig = {    .baud_rate = 115200,                    //&#x6CE2;&#x7279;&#x7387;    .data_bits = UART_DATA_8_BITS,          //&#x516B;&#x4F4D;&#x6570;&#x636E;&#x4F4D;    .parity = UART_PARITY_DISABLE,          //&#x6821;&#x9A8C;&#x4F4D;    .stop_bits = UART_STOP_BITS_1,          //&#x505C;&#x6B62;&#x4F4D;    .flow_ctrl = UART_HW_FLOWCTRL_DISABLE   //&#x786C;&#x4EF6;&#x6D41;&#x63A7;&#x5236;};\n\n\nUART&#x5F15;&#x811A;&#x8BBE;&#x7F6E;uart_set_pin(uart_port_t uart_num,      //&#x4E32;&#x53E3;&#x53F7;            int tx_io_num,              //tx&#x5F15;&#x811A;&#xFF08;17&#xFF09;            int rx_io_num,              //rx&#x5F15;&#x811A;&#xFF08;16&#xFF09;            int rts_io_num,             //rts&#x5F15;&#x811A; &#x786C;&#x4EF6;&#x6D41;&#x63A7;&#x811A;            int cts_io_num              //cts&#x5F15;&#x811A; &#x786C;&#x4EF6;&#x6D41;&#x63A7;&#x811A;            )\n&#x793A;&#x4F8B;:&#x5982;&#x679C;&#x4E0D;&#x542F;&#x7528;&#x786C;&#x4EF6;&#x6D41;&#x63A7;&#xFF0C;rts cts&#x53C2;&#x6570;&#x53EF;&#x4EE5;&#x4F20;&#x5165;UART_PIN_NO_CHANGEuart_set_pin(2, 17, 16, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE)\n\n\n&#x5B9E;&#x6218;\n&#x521B;&#x5EFA;&#x7EC4;&#x4EF6;&#x8FD9;&#x91CC;&#x91C7;&#x7528;&#x81EA;&#x5B9A;&#x4E49;&#x7EC4;&#x4EF6;&#x7684;&#x65B9;&#x5F0F;&#xFF0C;&#x5728;ESP_IDF&#x4E2D;&#x4F7F;&#x7528;&#x547D;&#x4EE4;idf.py -C components create-component uart_driver\nuart_driver&#x90E8;&#x5206;&#x53EF;&#x4EE5;&#x81EA;&#x5B9A;&#x4E49;&#x540D;&#x79F0;\n\n&#x5728;components/uart_driver&#x6587;&#x4EF6;&#x5939;&#x4E0B;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x81EA;&#x52A8;&#x521B;&#x5EFA;&#x7684;.c .h&#x6587;&#x4EF6;\n\n&#x5F15;&#x5165;&quot;driver/uart.h&quot;&#x53CA;&#x4FEE;&#x6539;CMakeLists.txt&#x6587;&#x4EF6;components/uart_driver/CMakeLists.txt&#xFF0C;&#x6253;&#x5F00;&#x8FD9;&#x4E2A;txt&#x6587;&#x4EF6;,&#x5199;&#x5165;&#x4EE5;&#x4E0B;&#x5185;&#x5BB9;\nidf_component_register(SRCS &quot;uart_driver.c&quot;                    INCLUDE_DIRS &quot;include&quot;                    REQUIRES &quot;driver&quot;)\nREQUIRES &quot;driver&quot;&#x90E8;&#x5206;&#x5C31;&#x662F;&#x5728;&#x544A;&#x8BC9;cmake&#x5305;&#x542B;&#x4E86;driver&#x6587;&#x4EF6;&#x5939;&#x7684;&#x5185;&#x5BB9;&#xFF08;&#x6211;&#x731C;&#x7684;&#xFF09;\n\n&#x521D;&#x59CB;&#x5316;&#x51FD;&#x6570;&#x4EE5;&#x4E0B;&#x7684;&#x5185;&#x5BB9;&#x53EA;&#x662F;&#x6458;&#x53D6;&#x4E86;&#x6587;&#x4EF6;&#x90E8;&#x5206;&#x5185;&#x5BB9;&#xFF0C;&#x5177;&#x4F53;&#x60C5;&#x51B5;&#x6309;&#x6240;&#x9700;&#x914D;&#x7F6E;\n\n\n//uart_driver.htypedef struct {    int bandRate;   //&#x6CE2;&#x7279;&#x7387;    int uartNum;    //&#x4E32;&#x53E3;&#x53F7;    int txPin;    int rxPin;}uartPin_t;         //&#x8FD9;&#x91CC;&#x6211;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x7BA1;&#x7406;&#x81EA;&#x5B9A;&#x4E49;&#x6570;&#x636E;&#xFF0C;                    //&#x5176;&#x4ED6;&#x53C2;&#x6570;&#x4E00;&#x822C;&#x4E0D;&#x7528;&#x6539;&#x53D8;/** * @brief &#x521D;&#x59CB;&#x5316;&#x4E32;&#x53E3; * @param uartInitConfig &#x521D;&#x59CB;&#x5316;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x4F53;&#xFF0C;&#x6CE2;&#x7279;&#x7387;&#xFF0C;&#x4E32;&#x53E3;&#x53F7;&#xFF0C;tx&#xFF0C;rx&#x5F15;&#x811A; */void uart_Init(uartPin_t *uartInitConfig);\n&#x51FD;&#x6570;&#x5B9E;&#x73B0;\n//uart_driver.cconst int uartBufferSize = (1024 * 2);void uart_Init(uartPin_t *uartInitConfig){    uartPin_t *uartInitPin = uartInitConfig;    uart_config_t uartConfig = {        .baud_rate = uartInitPin-&gt;bandRate,        .data_bits = UART_DATA_8_BITS,        .parity = UART_PARITY_DISABLE,        .stop_bits = UART_STOP_BITS_1,        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE    };    ESP_ERROR_CHECK(uart_driver_install(uartInitPin-&gt;uartNum, uartBufferSize, 0, 0, NULL, 0));    ESP_ERROR_CHECK(uart_param_config(uartInitPin-&gt;uartNum, &amp;uartConfig));    ESP_ERROR_CHECK(uart_set_pin(uartInitPin-&gt;uartNum, uartInitPin-&gt;txPin, uartInitPin-&gt;rxPin, UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));}\nESP_ERROR_CHECK()&#x51FD;&#x6570;&#x8981;&#x5305;&#x542B;#include &quot;esp_err.h&quot;&#xFF0C;&#x7528;&#x4E8E;&#x68C0;&#x67E5;&#x51FD;&#x6570;&#x8FD4;&#x56DE;&#x503C;&#xFF0C;&#x5982;&#x679C;&#x51FA;&#x9519;&#x7A0B;&#x5E8F;&#x4F1A;&#x76F4;&#x63A5;&#x505C;&#x6B62;\n\n&#x6D4B;&#x8BD5;&#x51FD;&#x6570;&#x4E3B;&#x673A;&#x53D1;&#x4EC0;&#x4E48;&#xFF0C;esp&#x518D;&#x53D1;&#x56DE;&#x6765;void uart_send_recive_test(void *pvParameters){    const char *testLen = &quot;Please send massage\\n&quot;;    uint8_t rxData[10];                             //&#x63A5;&#x6536;&#x6570;&#x7EC4;&#x5927;&#x5C0F;    uart_write_bytes(2, testLen, strlen(testLen));    while(1){        int length = 0;        ESP_ERROR_CHECK(uart_get_buffered_data_len(2, (size_t*)&amp;length));        if(length &gt; 0){            int readLength = uart_read_bytes(2, &amp;rxData, length, pdMS_TO_TICKS(100));            if(readLength &gt; 0){                uart_write_bytes(2, rxData, 10);            }        }        vTaskDelay(10);    }}\n\n&#x7247;&#x5185;&#x529F;&#x80FD;WIFI&#x8FD9;&#x8282;&#x53EA;&#x4ECB;&#x7ECD;WiFi&#x914D;&#x7F6E;&#xFF0C;&#x5982;&#x679C;&#x9700;&#x8981;&#x4F7F;&#x7528;WiFi&#x914D;&#x7F51;&#xFF0C;&#x8BF7;&#x8F6C;&#x5230;&#x914D;&#x7F51;&#x7684;&#x7AE0;&#x8282;\n&#x53C2;&#x6570;&#x8BBE;&#x7F6E;\n&#x521D;&#x59CB;&#x5316;TCP/IP&#x534F;&#x8BAE;&#x6808;ESP_ERROR_CHECK(esp_netif_init());ESP_ERROR_CHECK&#x7528;&#x4E8E;&#x68C0;&#x67E5;\n&#x914D;&#x7F6E;WIFI&#x53C2;&#x6570;&#x6A21;&#x5F0F;&#x53C2;&#x6570;esp_netif_create_default_wifi_sta();&#x7528;&#x4E8E;&#x8BBE;&#x7F6E;sta&#x6A21;&#x5F0F;&#x7684;&#x9ED8;&#x8BA4;&#x53C2;&#x6570;&#x53C2;&#x6570;&#x914D;&#x7F6E;:&#x9ED8;&#x8BA4;&#x53C2;&#x6570;wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();wifi_init_config_t&#x7ED3;&#x6784;&#x4F53;&#x7C7B;&#x578B;WIFI_INIT_CONFIG_DEFAULT()&#x8FD4;&#x56DE;&#x9ED8;&#x8BA4;&#x53C2;&#x6570;&#x53C2;&#x6570;&#x914D;&#x7F6E;&#xFF1A;&#x81EA;&#x5B9A;&#x4E49;&#x53C2;&#x6570;wifi_config_t wifi_config = {        .sta = {            .ssid = &quot;yourssid&quot;,            .password = &quot;yourpassword&quot;,        },}\n&#x8BBE;&#x7F6E;&#x53C2;&#x6570;ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));//&#x8BBE;&#x7F6E;sta&#x6A21;&#x5F0F;//&#x8BBE;&#x7F6E;&#x53C2;&#x6570;ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, wifi_config));\nwifi_&#x542F;&#x52A8;ESP_ERROR_CHECK(esp_wifi_start());\n\nwifi&#x4E8B;&#x4EF6;\n&#x8BBE;&#x7F6E;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;ESP_ERROR_CHECK(esp_event_loop_create_default());\n&#x58F0;&#x660E;&#x4E8B;&#x4EF6;&#x53E5;&#x67C4;&#x793A;&#x4F8B;&#xFF1A;esp_event_handler_instance_t instance_any_id;idesp_event_handler_instance_t instance_got_ip;&#x83B7;&#x53D6;ip\n&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,//&#x4E8B;&#x4EF6;&#x7C7B;&#x578B;                                        ESP_EVENT_ANY_ID,//&#x4E8B;&#x4EF6;id                                        &amp;wifi_event_handler,//&#x5904;&#x7406;&#x51FD;&#x6570;                                        NULL,//&#x5904;&#x7406;&#x51FD;&#x6570;&#x53C2;&#x6570;                                        &amp;instance_any_id//&#x5B9E;&#x4F8B;&#x5316;&#x53C2;&#x6570;                                        ));ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,                                        IP_EVENT_STA_GOT_IP,                                        &amp;wifi_event_handler,                                        NULL,                                        &amp;instance_got_ip                                        ));\n&#x6CE8;&#x518C;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;&#x540E;&#x8981;&#x5B9A;&#x4E49;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;\n&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;&#x8BF4;&#x660E;&#x5982;&#x679C;&#x4E8B;&#x4EF6;&#x5904;&#x7406;&#x51FD;&#x6570;&#x662F;&#x4E00;&#x4E2A;&#xFF0C;&#x90A3;&#x8981;&#x6839;&#x636E;&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x60C5;&#x51B5;&#x6765;&#x901A;&#x77E5;&#x54EA;&#x4E00;&#x4E2A;&#x4E8B;&#x4EF6;&#x54CD;&#x5E94;&#xFF0C;&#x53EF;&#x4EE5;&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;&#x6765;&#x7BA1;&#x7406;&#x4E0D;&#x540C;&#x7684;&#x4E8B;&#x4EF6;&#x3002;&#x5177;&#x4F53;&#x5982;&#x4F55;&#x505A;&#x5728;&#x4E0B;&#x8FF0;&#x7684;&#x5185;&#x5BB9;&#x4E2D;\n\n&#x5B9E;&#x6218;//wifi_driver.h#ifndef _WIFI_DRIVER_H#define _WIFI_DRIVER_H#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/semphr.h&quot;typedef struct {    char ssid[32];    char password[64];    // char ip[16];    // char gw[16];    // char netmask[16];} wifi_info_config_t;extern char sta_ip[16];extern bool sta_connected;extern bool ap_active;extern SemaphoreHandle_t wifiStaConnectedHandle;#ifdef __cplusplusextern &quot;C&quot; {#endif    void wifi_init(void);    void wifi_config_ap(void);    void wifi_config_sta(wifi_info_config_t *config);    bool wifi_has_saved_config(void);    void wifi_save_config(wifi_info_config_t *config);    void wifi_load_config(wifi_info_config_t *config);    void wifi_clear_config(void);    void wifi_close_ap(void);#ifdef _cplusplus}#endif#endif\n//wifi_driver.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;wifi_driver.h&quot;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/event_groups.h&quot;#include &quot;esp_wifi.h&quot;#include &quot;esp_event.h&quot;#include &quot;esp_log.h&quot;#include &quot;esp_err.h&quot;#define WIFI_CONNECTED_BIT BIT0 //&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x4E8B;&#x4EF6;&#x8BBE;&#x7F6E;&#x5728;&#x4E8B;&#x4EF6;&#x7EC4;0&#x4F4D;&#xFF0C;esp32&#x4E2D;&#x5BF9;&#x6240;&#x6709;&#x4F4D;&#x90FD;&#x6709;&#x5B9A;&#x4E49;#define WIFI_FAIL_BIT      BIT1 //&#x8FDE;&#x63A5;&#x5931;&#x8D25;#define EXAMPLE_ESP_MAXIMUM_RETRY 5 //&#x6700;&#x591A;&#x91CD;&#x8BD5;&#x6B21;&#x6570;static const char *TAG = &quot;wifi station&quot;;static int s_retry_num = 0;static EventGroupHandle_t s_wifi_event_group;   //&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;&#x53E5;&#x67C4;static void wifi_event_handler(void* arg, esp_event_base_t event_base,                                int32_t event_id, void* event_data){    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START) {//wifi&#x4E8B;&#x4EF6;        esp_wifi_connect();    } else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED) {        if (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) {//&#x5C1D;&#x8BD5;5&#x6B21;&#x8FDE;&#x63A5;&#x4E0D;&#x4E0A;&#x5C31;&#x6253;&#x5370;&#x9519;&#x8BEF;&#x4FE1;&#x606F;            esp_wifi_connect();            s_retry_num++;            ESP_LOGI(TAG, &quot;retry to connect to the AP&quot;);        } else {            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);//&#x7ED9;wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x5931;&#x8D25;&#x4F4D;&#x7F6E;&#x4F4D;        }        ESP_LOGI(TAG,&quot;connect to the AP fail&quot;);    } else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP) {//ip&#x4E8B;&#x4EF6;        ip_event_got_ip_t* event = (ip_event_got_ip_t*) event_data;        ESP_LOGI(TAG, &quot;got ip:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));        s_retry_num = 0;        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);//&#x7ED9;wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x5DF2;&#x8FDE;&#x63A5;&#x4F4D;&#x7F6E;&#x4F4D;    }}void wifi_init_sta(const char *ssid, const char *password){    s_wifi_event_group = xEventGroupCreate();       //&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;        //&#x521D;&#x59CB;&#x5316;TCP/IP&#x534F;&#x8BAE;&#x6808;    ESP_ERROR_CHECK(esp_netif_init());    //&#x521B;&#x5EFA;&#x9ED8;&#x8BA4;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;    ESP_ERROR_CHECK(esp_event_loop_create_default());     esp_netif_t *sta_netif = esp_netif_create_default_wifi_sta();    assert(sta_netif);    // WiFi&#x914D;&#x7F6E;    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));      esp_event_handler_instance_t instance_any_id;    esp_event_handler_instance_t instance_got_ip;    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,                                                        ESP_EVENT_ANY_ID,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_any_id));    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,                                                        IP_EVENT_STA_GOT_IP,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_got_ip));    wifi_config_t wifi_config = {        .sta = {            .ssid = &quot;&quot;,            .password = &quot;&quot;,            /* Authmode threshold resets to WPA2 as default if password matches WPA2 standards (password len =&gt; 8).             * If you want to connect the device to deprecated WEP/WPA networks, Please set the threshold value             * to WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK and set the password with length and format matching to             * WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK standards.             */            // .threshold.authmode = ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD,            // .sae_pwe_h2e = ESP_WIFI_SAE_MODE,            // .sae_h2e_identifier = EXAMPLE_H2E_IDENTIFIER,        },    };    strncpy((char*)wifi_config.sta.ssid, ssid, sizeof(wifi_config.sta.ssid));    strncpy((char*)wifi_config.sta.password, password, sizeof(wifi_config.sta.password));    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));    ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &amp;wifi_config));    ESP_ERROR_CHECK(esp_wifi_start());          ESP_LOGI(TAG, &quot;wifi_init_sta finished.&quot;);    /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum     * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */    //&#x7B49;&#x5F85;&#x8FDE;&#x63A5;&#x4E8B;&#x4EF6;&#x5EFA;&#x7ACB;&#x8D77;&#x6765;&#xFF0C;&#x6216;&#x8005;&#x5C1D;&#x8BD5;&#x6700;&#x5927;&#x8FDE;&#x63A5;&#x6570;&#x540E;&#x5931;&#x8D25;&#xFF0C;&#x7531;wifi_event_handler()&#x8BBE;&#x7F6E;&#xFF0C;    //&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x6CE8;&#x91CA;    EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,            WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,            pdFALSE,            pdFALSE,            portMAX_DELAY);    /* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually     * happened. */    //&#x6839;&#x636E;&#x4E8B;&#x4EF6;&#x4F4D;&#x6765;&#x6D4B;&#x8BD5;&#x4E8B;&#x4EF6;&#x662F;&#x5426;&#x53D1;&#x751F;    if (bits &amp; WIFI_CONNECTED_BIT) {        ESP_LOGI(TAG, &quot;connected to ap SSID:%s password:%s&quot;,ssid, password);    } else if (bits &amp; WIFI_FAIL_BIT) {        ESP_LOGI(TAG, &quot;Failed to connect to SSID:%s, password:%s&quot;,ssid, password);    } else {        ESP_LOGE(TAG, &quot;UNEXPECTED EVENT&quot;);    }}\n\n\n\nAP+STA&#x6A21;&#x5F0F;&#x914D;&#x7F51;&#x672C;&#x8282;&#x4E3B;&#x8981;&#x7528;&#x4E8E;&#x63D0;&#x4F9B;&#x4E00;&#x79CD;AP+STA&#x6A21;&#x5F0F;&#x7684;&#x7B80;&#x5355;&#x914D;&#x7F51;&#x65B9;&#x6CD5;&#xFF0C;&#x8FD8;&#x5904;&#x4E8E;&#x6D4B;&#x8BD5;&#x9636;&#x6BB5;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x4E86;&#x89E3;http&#x670D;&#x52A1;&#x5668;&#xFF0C;&#x8BF7;&#x5728;&#x9605;&#x8BFB;&#x672C;&#x8282;&#x524D;&#x9605;&#x8BFB;HTTP&#x670D;&#x52A1;&#x5668;&#x7684;&#x90E8;&#x5206;&#x539F;&#x7406;&#xFF1A;\n\nesp32&#x5F00;&#x542F;STA+AP&#x6A21;&#x5F0F;&#xFF0C;&#x624B;&#x673A;&#x8FDE;&#x63A5;esp32&#x70ED;&#x70B9;&#xFF0C;&#x70ED;&#x70B9;&#x540D;&#x79F0;&#x548C;&#x5BC6;&#x7801;&#x81EA;&#x5B9A;&#x4E49;&#xFF0C;esp32&#x7684;ap&#x6A21;&#x5F0F;&#x9ED8;&#x8BA4;&#x7684;ip(192.168.4.1)&#xFF0C;\n&#x7528;&#x8FD9;&#x4E2A;ip&#x8BBF;&#x95EE;http&#x8D44;&#x6E90;&#xFF0C;&#x8BF7;&#x6C42;&#x4E00;&#x4E2A;&#x9875;&#x9762;&#x7528;&#x4E8E;&#x586B;&#x5199;WiFi&#x540D;&#x79F0;&#x548C;&#x5BC6;&#x7801;&#xFF0C;&#x5185;&#x90E8;&#x8FD4;&#x56DE;&#x5E76;&#x5B58;&#x5165;esp32&#x7684;NVS&#xFF0C;&#x4E0D;&#x4E86;&#x89E3;&#x7684;&#x540C;&#x5B66;&#x770B;&#x8FD9;&#x4E2A;\n&#x70B9;&#x51FB;&#x8FDE;&#x63A5;&#x540E;&#xFF0C;esp32&#x4F7F;&#x7528;&#x7528;&#x6237;&#x586B;&#x5199;&#x7684;WiFi&#x4FE1;&#x606F;&#x8FDE;&#x63A5;WiFi\n\n\n\n\n&#x6210;&#x529F;\n&#x5931;&#x8D25;\n\n\n\n&#x663E;&#x793A;&#x914D;&#x7F6E;&#x6210;&#x529F;&#xFF0C;&#x624B;&#x52A8;&#x5237;&#x65B0;&#x4E00;&#x4E0B;&#x9875;&#x9762;&#xFF0C;&#x70B9;&#x51FB;&#x4E0B;&#x4E00;&#x6B65;\n&#x663E;&#x793A;&#x914D;&#x7F6E;&#x9519;&#x8BEF;&#xFF0C;&#x8FD4;&#x56DE;&#x914D;&#x7F6E;&#x9875;&#x9762;\n\n\n\n&#x8FD9;&#x91CC;&#x4E00;&#x822C;&#x8FD8;&#x8FDE;&#x63A5;&#x7684;&#x662F;esp32&#x7684;&#x70ED;&#x70B9;&#xFF0C;&#x663E;&#x793A;&#x5206;&#x914D;&#x7684;ip&#x5730;&#x5740;&#x548C;&#x5173;&#x95ED;ap&#x6A21;&#x5F0F;&#x529F;&#x80FD;&#x3002;&#x63A8;&#x8350;&#x914D;&#x7F51;&#x6210;&#x529F;&#x540E;&#x5173;&#x95ED;ap&#xFF0C;&#x6BD4;&#x8F83;&#x8017;&#x7535;&#x3002;\n&#x70B9;&#x51FB;&#x8FDE;&#x63A5;&#x540E;&#x4F1A;&#x8DF3;&#x8F6C;&#x5230;&#x8DEF;&#x7531;&#x5668;&#x4E3A;esp32&#x5206;&#x914D;&#x7684;&#x7F51;&#x5740;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x6CA1;&#x6709;&#x53CD;&#x5E94;&#xFF0C;&#x56E0;&#x4E3A;esp32&#x4E0D;&#x54CD;&#x5E94;&#x8DEF;&#x7531;&#x5206;&#x914D;&#x7684;ip&#xFF1B;&#x8FD9;&#x65F6;&#x5019;&#x4E0D;&#x8981;&#x5173;&#x95ED;&#x7F51;&#x9875;&#x5C06;&#x8FDE;&#x63A5;esp32&#x7684;&#x8BBE;&#x5907;&#x5207;&#x6362;&#x5230;&#x914D;&#x7F6E;&#x7684;&#x5C40;&#x57DF;&#x7F51;&#xFF0C;&#x518D;&#x5237;&#x65B0;&#x4E00;&#x4E0B;&#x3002;\n&#x70B9;&#x51FB;&#x8BBF;&#x95EE;&#x8BBE;&#x5907;&#xFF0C;&#x81EA;&#x52A8;&#x8DF3;&#x8F6C;&#x5230;&#x6307;&#x5B9A;&#x7684;&#x63A7;&#x5236;&#x7F51;&#x9875;\n&#x76EE;&#x524D;&#x8FD8;&#x6CA1;&#x6709;&#x5B9E;&#x73B0;&#x56FA;&#x5B9A;ip&#xFF0C;&#x53EF;&#x4EE5;&#x5728;&#x8FDE;&#x63A5;&#x9636;&#x6BB5;&#x7528;&#x4E32;&#x53E3;&#x67E5;&#x770B;&#x5206;&#x914D;&#x7684;ip&#x5730;&#x5740;&#xFF0C;&#x5982;&#x679C;&#x60F3;&#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x7684;wifi&#x4FE1;&#x606F;&#xFF0C;&#x8BF7;&#x4F7F;&#x7528;esp-idf&#x7684;&#x6E05;&#x7406;flash&#x7684;&#x5DE5;&#x5177;&#x5E76;&#x91CD;&#x65B0;&#x70E7;&#x5F55;&#x4EE3;&#x7801;&#x3002;&#x6E90;&#x7801;&#x5904;&#x4E8E;debug&#x9636;&#x6BB5;&#xFF0C;&#x521D;&#x59CB;&#x5316;&#x9636;&#x6BB5;&#x4F1A;&#x81EA;&#x52A8;&#x6E05;&#x7406;nvs&#x7684;&#x6570;&#x636E;&#xFF0C;&#x4F46;&#x662F;&#x4E0D;&#x77E5;&#x9053;&#x4E3A;&#x4EC0;&#x4E48;&#x6E05;&#x7406;&#x4E0D;&#x4E86;wifi&#x4FE1;&#x606F;&#xFF0C;&#x540E;&#x7EED;&#x4F18;&#x5316;\n\n&#x5B9E;&#x6218;//wifi_driver.h#ifndef _WIFI_DRIVER_H#define _WIFI_DRIVER_H#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;#include &quot;freertos/FreeRTOS.h&quot;#include &quot;freertos/semphr.h&quot;typedef struct {    char ssid[32];    char password[64];    // char ip[16];    // char gw[16];    // char netmask[16];} wifi_info_config_t;extern char sta_ip[16];extern bool sta_connected;extern bool ap_active;extern SemaphoreHandle_t wifiStaConnectedHandle;#ifdef __cplusplusextern &quot;C&quot; {#endif    void wifi_init(void);       //&#x521D;&#x59CB;&#x5316;    void wifi_config_ap(void);  //&#x8BBE;&#x7F6E;ap&#x6A21;&#x5F0F;    void wifi_config_sta(wifi_info_config_t *config);   //&#x8BBE;&#x7F6E;sta&#x6A21;&#x5F0F;    bool wifi_has_saved_config(void);                   //&#x67E5;&#x770B;&#x662F;&#x5426;&#x6709;&#x4FDD;&#x5B58;&#x7684;&#x914D;&#x7F6E;    void wifi_save_config(wifi_info_config_t *config);  //&#x4FDD;&#x5B58;wifi&#x914D;&#x7F6E;    void wifi_load_config(wifi_info_config_t *config);  //&#x52A0;&#x8F7D;&#x914D;&#x7F6E;    void wifi_clear_config(void);                       //&#x6E05;&#x9664;&#x914D;&#x7F6E;    void wifi_close_ap(void);                           //&#x5173;&#x95ED;ap&#x6A21;&#x5F0F;#ifdef _cplusplus}#endif#endif```c//wifi_driver.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &quot;wifi_driver.h&quot;#include &quot;esp_wifi.h&quot;#include &quot;esp_event.h&quot;#include &quot;esp_check.h&quot;#include &quot;esp_netif.h&quot;#include &quot;lwip/ip_addr.h&quot;#include &quot;nvs_flash.h&quot;#include &quot;nvs.h&quot;//wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x4F4D;#define WIFI_CONNECTED_BIT BIT0#define WIFI_FAIL_BIT      BIT1#define EXAMPLE_ESP_MAXIMUM_RETRY 5//AP&#x6A21;&#x5F0F;&#x4FE1;&#x606F;#define EXAMPLE_ESP_WIFI_AP_SSID            &quot;ESP_WIFI_AP&quot;#define EXAMPLE_ESP_WIFI_AP_PASSWD          &quot;12345678&quot;#define EXAMPLE_ESP_WIFI_CHANNEL            6#define EXAMPLE_MAX_STA_CONN                4//nvs&#x4FDD;&#x5B58;wifi&#x914D;&#x7F6E;static const char *NVS_NAMESPACE = &quot;wifi_config&quot;;static const char *NVS_KEY = &quot;sta_config&quot;;//&#x8FDE;&#x63A5;&#x6A21;&#x5F0F;&#x4FE1;&#x606F;char sta_ip[16] = &quot;0.0.0.0&quot;;bool sta_connected = false;bool ap_active = true;//&#x65E5;&#x5FD7;&#x4FE1;&#x606F;static const char *TAG_AP = &quot;WiFi SoftAP&quot;;static const char *TAG_STA = &quot;WiFi Sta&quot;;static int s_retry_num = 0;// &#x58F0;&#x660E;&#x7F51;&#x7EDC;&#x63A5;&#x53E3;&#x6307;&#x9488;static esp_netif_t *sta_netif = NULL;static esp_netif_t *ap_netif = NULL;//&#x521B;&#x5EFA;&#x4E8B;&#x4EF6;&#x7EC4;&#x53E5;&#x67C4;static EventGroupHandle_t s_wifi_event_group;   //&#x521B;&#x5EFA;sta&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x4FE1;&#x53F7;&#x91CF;SemaphoreHandle_t wifiStaConnectedHandle = NULL;static void wifi_event_handler(void* arg, esp_event_base_t event_base,                                int32_t event_id, void* event_data){    if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_AP_STACONNECTED)     {        //wifi_event_ap_staconnected_t *event = (wifi_event_ap_staconnected_t *) event_data;        ESP_LOGI(TAG_AP, &quot;Station connected to AP&quot;);    }     else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_AP_STADISCONNECTED)     {        //wifi_event_ap_stadisconnected_t *event = (wifi_event_ap_stadisconnected_t *) event_data;        ESP_LOGI(TAG_AP, &quot;Station disconnected to AP&quot;);    }     else if (event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_START)     {        esp_wifi_connect();        s_retry_num = 0;        ESP_LOGI(TAG_STA, &quot;Station started&quot;);    }    else if(event_base == WIFI_EVENT &amp;&amp; event_id == WIFI_EVENT_STA_DISCONNECTED)     {        if (s_retry_num &lt; EXAMPLE_ESP_MAXIMUM_RETRY) {//&#x5C1D;&#x8BD5;5&#x6B21;&#x8FDE;&#x63A5;&#x4E0D;&#x4E0A;&#x5C31;&#x6253;&#x5370;&#x9519;&#x8BEF;&#x4FE1;&#x606F;            esp_wifi_connect();            s_retry_num++;            ESP_LOGI(TAG_STA, &quot;retry to connect to the AP&quot;);        } else {            //sta&#x8FDE;&#x63A5;&#x5931;&#x8D25;            xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT);//&#x7ED9;wifi&#x4E8B;&#x4EF6;&#x7EC4;&#x7684;&#x5931;&#x8D25;&#x4F4D;&#x7F6E;&#x4F4D;            sta_connected = false;            xSemaphoreGive(wifiStaConnectedHandle);            ESP_LOGE(TAG_STA, &quot;&#x8D85;&#x8FC7;&#x6700;&#x5927;&#x91CD;&#x8FDE;&#x6B21;&#x6570;,&#x8FDE;&#x63A5;&#x5931;&#x8D25;&quot;);            // &#x542F;&#x7528; AP &#x6A21;&#x5F0F;&#x5141;&#x8BB8;&#x91CD;&#x65B0;&#x914D;&#x7F6E;            if (!ap_active) {                wifi_config_ap();             }        }    }    else if (event_base == IP_EVENT &amp;&amp; event_id == IP_EVENT_STA_GOT_IP)     {//ip&#x4E8B;&#x4EF6;        ip_event_got_ip_t *event = (ip_event_got_ip_t *) event_data;        ESP_LOGI(TAG_STA, &quot;Got IP:&quot; IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));        sprintf(sta_ip, IPSTR, IP2STR(&amp;event-&gt;ip_info.ip));        s_retry_num = 0;        //&#x8FDE;&#x63A5;&#x6210;&#x529F;        sta_connected = true;        xSemaphoreGive(wifiStaConnectedHandle);        xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT);    }}void wifi_init(void){    //&#x521B;&#x5EFA;&#x4E8C;&#x503C;&#x4FE1;&#x53F7;&#x91CF;&#xFF0C;wifi&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x4FE1;&#x53F7;&#x91CF;    wifiStaConnectedHandle = xSemaphoreCreateBinary();    //&#x521D;&#x59CB;&#x5316;&#x65F6;&#x95F4;&#x7EC4;    s_wifi_event_group = xEventGroupCreate();    //&#x521D;&#x59CB;&#x5316;TCP/IP&#x534F;&#x8BAE;&#x6808;    ESP_ERROR_CHECK(esp_netif_init());    //&#x521B;&#x5EFA;&#x9ED8;&#x8BA4;&#x4E8B;&#x4EF6;&#x5FAA;&#x73AF;    ESP_ERROR_CHECK(esp_event_loop_create_default());     // &#x521B;&#x5EFA;&#x9ED8;&#x8BA4;&#x7F51;&#x7EDC;&#x63A5;&#x53E3;    if (sta_netif == NULL) {        sta_netif = esp_netif_create_default_wifi_sta();        assert(sta_netif != NULL);    }    // WiFi&#x9ED8;&#x8BA4;&#x914D;&#x7F6E;    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();    ESP_ERROR_CHECK(esp_wifi_init(&amp;cfg));     //wifi_config_sta(const char *ssid, const char *password);    esp_event_handler_instance_t instance_any_id;    esp_event_handler_instance_t instance_got_ip;    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,                                                        ESP_EVENT_ANY_ID,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_any_id));    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,                                                        IP_EVENT_STA_GOT_IP,                                                        &amp;wifi_event_handler,                                                        NULL,                                                        &amp;instance_got_ip));    // &#x68C0;&#x67E5;&#x662F;&#x5426;&#x6709;&#x4FDD;&#x5B58;&#x7684;&#x914D;&#x7F6E;    if (wifi_has_saved_config()) {        wifi_info_config_t config;        wifi_load_config(&amp;config);                // &#x53EA;&#x5F00;&#x542F;STA&#x6A21;&#x5F0F;        ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));        wifi_config_sta(&amp;config);        ap_active = false;        ESP_LOGI(TAG_STA, &quot;&#x4F7F;&#x7528;&#x4FDD;&#x5B58;&#x7684;&#x914D;&#x7F6E;&#x8FDE;&#x63A5;WiFi: %s&quot;, config.ssid);    } else {        // &#x5F00;&#x542F;AP+STA&#x6A21;&#x5F0F;        wifi_config_ap();     }        // &#x542F;&#x52A8;WiFi    ESP_ERROR_CHECK(esp_wifi_start());}void wifi_config_ap(void){    ESP_LOGI(TAG_AP, &quot;Starting AP mode...&quot;);    // &#x521B;&#x5EFA;AP&#x7F51;&#x7EDC;&#x63A5;&#x53E3;    if (ap_netif == NULL) {        ap_netif = esp_netif_create_default_wifi_ap();        assert(ap_netif != NULL);    }        wifi_config_t wifi_ap_config = {        .ap = {            .ssid = EXAMPLE_ESP_WIFI_AP_SSID,            .ssid_len = strlen(EXAMPLE_ESP_WIFI_AP_SSID),            .channel = EXAMPLE_ESP_WIFI_CHANNEL,            .password = EXAMPLE_ESP_WIFI_AP_PASSWD,            .max_connection = EXAMPLE_MAX_STA_CONN,            .authmode = WIFI_AUTH_WPA2_PSK,            .pmf_cfg = {                .required = false,            },        },    };    if (strlen(EXAMPLE_ESP_WIFI_AP_PASSWD) == 0) {        wifi_ap_config.ap.authmode = WIFI_AUTH_OPEN;    }    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_APSTA));    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_AP, &amp;wifi_ap_config));    ap_active = true;    ESP_LOGI(TAG_AP, &quot;AP+STA&#x6A21;&#x5F0F;&#x542F;&#x52A8;. AP SSID: %s&quot;, EXAMPLE_ESP_WIFI_AP_SSID);    // ESP_LOGI(TAG_AP, &quot;wifi_init_softap finished. SSID:%s password:%s channel:%d&quot;,    //          EXAMPLE_ESP_WIFI_AP_SSID, EXAMPLE_ESP_WIFI_AP_PASSWD, EXAMPLE_ESP_WIFI_CHANNEL);}void wifi_config_sta(wifi_info_config_t *config){    ESP_LOGI(TAG_STA, &quot;Connecting to WiFi: %s&quot;, config-&gt;ssid);    // &#x521B;&#x5EFA;STA&#x7F51;&#x7EDC;&#x63A5;&#x53E3;    if (sta_netif == NULL) {        sta_netif = esp_netif_create_default_wifi_sta();        assert(sta_netif != NULL);    }    wifi_config_t wifi_sta_config = {        .sta = {            .ssid = &quot;NULL&quot;,            .password = &quot;NULL&quot;,            /* Authmode threshold resets to WPA2 as default if password matches WPA2 standards (password len =&gt; 8).             * If you want to connect the device to deprecated WEP/WPA networks, Please set the threshold value             * to WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK and set the password with length and format matching to             * WIFI_AUTH_WEP/WIFI_AUTH_WPA_PSK standards.             */            .threshold.authmode = WIFI_AUTH_WPA2_PSK,            // .sae_pwe_h2e = ESP_WIFI_SAE_MODE,            // .sae_h2e_identifier = EXAMPLE_H2E_IDENTIFIER,        },    };    strncpy((char*)wifi_sta_config.sta.ssid, config-&gt;ssid, sizeof(wifi_sta_config.sta.ssid));    strncpy((char*)wifi_sta_config.sta.password, config-&gt;password, sizeof(wifi_sta_config.sta.password));    //ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &amp;wifi_sta_config));    // // &#x8BBE;&#x7F6E;&#x9759;&#x6001;IP    // if (strlen(config-&gt;ip) &gt; 0 &amp;&amp; strlen(config-&gt;gw) &gt; 0 &amp;&amp; strlen(config-&gt;netmask) &gt; 0) {    //     esp_netif_ip_info_t ip_info;    //     memset(&amp;ip_info, 0, sizeof(ip_info));            //     ip_info.ip.addr = ipaddr_addr(config-&gt;ip);    //     ip_info.gw.addr = ipaddr_addr(config-&gt;gw);    //     ip_info.netmask.addr = ipaddr_addr(config-&gt;netmask);            //     esp_netif_dhcp_status_t dhcp_status;    //     esp_netif_t* netif = esp_netif_get_handle_from_ifkey(&quot;WIFI_STA_DEF&quot;);            //     if (esp_netif_dhcpc_get_status(netif, &amp;dhcp_status) == ESP_OK) {    //         if (dhcp_status == ESP_NETIF_DHCP_STARTED) {    //             ESP_ERROR_CHECK(esp_netif_dhcpc_stop(netif));    //         }    //         ESP_ERROR_CHECK(esp_netif_set_ip_info(netif, &amp;ip_info));    //     }    // }    ESP_LOGI(TAG_STA, &quot;wifi_init_sta finished.&quot;);    // &#x91CD;&#x7F6E;&#x91CD;&#x8FDE;&#x8BA1;&#x6570;&#x5668;    s_retry_num = 0;    ESP_ERROR_CHECK(esp_wifi_connect());            // /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum    //  * number of re-tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */    // //&#x7B49;&#x5F85;&#x8FDE;&#x63A5;&#x4E8B;&#x4EF6;&#x5EFA;&#x7ACB;&#x8D77;&#x6765;&#xFF0C;&#x6216;&#x8005;&#x5C1D;&#x8BD5;&#x6700;&#x5927;&#x8FDE;&#x63A5;&#x6570;&#x540E;&#x5931;&#x8D25;&#xFF0C;&#x7531;wifi_event_handler()&#x8BBE;&#x7F6E;&#xFF0C;&#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x53EF;&#x4EE5;&#x6CE8;&#x91CA;    // EventBits_t bits = xEventGroupWaitBits(s_wifi_event_group,    //         WIFI_CONNECTED_BIT | WIFI_FAIL_BIT,    //         pdFALSE,    //         pdFALSE,    //         portMAX_DELAY);    // /* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually    //  * happened. */    // //&#x6839;&#x636E;&#x4E8B;&#x4EF6;&#x4F4D;&#x6765;&#x6D4B;&#x8BD5;&#x4E8B;&#x4EF6;&#x662F;&#x5426;&#x53D1;&#x751F;    // if (bits &amp; WIFI_CONNECTED_BIT) {    //     ESP_LOGI(TAG_STA, &quot;connected to ap SSID:%s password:%s&quot;,ssid, password);    // } else if (bits &amp; WIFI_FAIL_BIT) {    //     ESP_LOGI(TAG_STA, &quot;Failed to connect to SSID:%s, password:%s&quot;,ssid, password);    // } else {    //     ESP_LOGE(TAG_STA, &quot;UNEXPECTED EVENT&quot;);    // }}bool wifi_has_saved_config(){    nvs_handle_t nvs;    //&#x8BFB;&#x547D;&#x540D;&#x7A7A;&#x95F4;    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &amp;nvs);    if (err != ESP_OK) {        return false;    }        wifi_info_config_t config;    size_t required_size = sizeof(config);    //&#x8BFB;&#x53D6;&#x5BF9;&#x5E94;&#x7684;&#x6570;&#x636E;    err = nvs_get_blob(nvs, NVS_KEY, &amp;config, &amp;required_size);    nvs_close(nvs);    //&#x4EFB;&#x610F;&#x4E3A;false&#x5219;&#x8FD4;&#x56DE;false    return (err == ESP_OK &amp;&amp; required_size == sizeof(config) &amp;&amp; strlen(config.ssid) &gt; 0);}void wifi_save_config(wifi_info_config_t *config){    nvs_handle_t nvs;    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READWRITE, &amp;nvs);    if (err != ESP_OK) {        ESP_LOGE(&quot;WIFI&quot;, &quot;&#x65E0;&#x6CD5;&#x6253;&#x5F00;NVS&#x547D;&#x540D;&#x7A7A;&#x95F4;&quot;);        return;    }        err = nvs_set_blob(nvs, NVS_KEY, config, sizeof(wifi_info_config_t));    if (err != ESP_OK) {        ESP_LOGE(&quot;WIFI&quot;, &quot;&#x4FDD;&#x5B58;&#x914D;&#x7F6E;&#x5931;&#x8D25;&quot;);        nvs_close(nvs);        return;    }        nvs_commit(nvs);    nvs_close(nvs);    ESP_LOGI(&quot;WIFI&quot;, &quot;WiFi&#x914D;&#x7F6E;&#x5DF2;&#x4FDD;&#x5B58;&quot;);}void wifi_load_config(wifi_info_config_t *config){    nvs_handle_t nvs;    esp_err_t err = nvs_open(NVS_NAMESPACE, NVS_READONLY, &amp;nvs);    if (err != ESP_OK) {        return;    }        size_t required_size = sizeof(wifi_info_config_t);    err = nvs_get_blob(nvs, NVS_KEY, config, &amp;required_size);    nvs_close(nvs);        if (err != ESP_OK || required_size != sizeof(wifi_info_config_t)) {        memset(config, 0, sizeof(wifi_info_config_t));    }}void wifi_clear_config(void){    // &#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x7684;WiFi&#x914D;&#x7F6E;    nvs_handle_t nvs;    if (nvs_open(NVS_NAMESPACE, NVS_READWRITE, &amp;nvs) == ESP_OK) {        nvs_erase_key(nvs, NVS_KEY);        nvs_commit(nvs);        nvs_close(nvs);        ESP_LOGI(TAG_STA, &quot;&#x5DF2;&#x6E05;&#x9664;&#x4FDD;&#x5B58;&#x7684;WiFi&#x914D;&#x7F6E;&quot;);    }    }void wifi_close_ap(){    if (ap_active &amp;&amp; sta_connected) {        ap_active = false;        esp_wifi_set_mode(WIFI_MODE_STA);        ESP_LOGI(TAG_AP, &quot;AP&#x6A21;&#x5F0F;&#x5DF2;&#x5173;&#x95ED;&quot;);                // &#x9500;&#x6BC1;AP&#x7F51;&#x7EDC;&#x63A5;&#x53E3;        if (ap_netif != NULL) {            esp_netif_destroy(ap_netif);            ap_netif = NULL;        }    }}\n\n//http_server.h#ifndef _HTTP_SERVER_H#define _HTTP_SERVER_H#include &lt;stdint.h&gt;#include &quot;esp_http_server.h&quot;#ifdef __cplusplusextern &quot;C&quot; {#endifhttpd_handle_t start_webserver(void);void stop_webserver(void);#ifdef _cplusplus}#endif#endif\n\n//http_server.c#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;#include &quot;esp_check.h&quot;#include &quot;http_server.h&quot;#include &quot;cmd_parser.h&quot;#include &quot;wifi_driver.h&quot;#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))#define EXAMPLE_HTTP_QUERY_KEY_MAX_LEN  (64)static const char *TAG = &quot;HTTP&quot;;static httpd_handle_t server = NULL;        //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;// &#x7B80;&#x5355;&#x7684;HTML&#x5934;&#x90E8;static const char* html_header =     &quot;&lt;!DOCTYPE html&gt;&quot;    &quot;&lt;html&gt;&lt;head&gt;&quot;    &quot;&lt;meta charset=\\&quot;UTF-8\\&quot;&gt;&quot;    &quot;&lt;meta name=\\&quot;viewport\\&quot; content=\\&quot;width=device-width, initial-scale=1\\&quot;&gt;&quot;    &quot;&lt;title&gt;ESP32&#x63A7;&#x5236;&lt;/title&gt;&quot;    &quot;&lt;style&gt;&quot;    &quot;body { font-family: Arial, sans-serif; max-width: 500px; margin: 0 auto; padding: 20px; }&quot;    &quot;h1 { color: #333; }&quot;    &quot;form { margin: 20px 0; }&quot;    &quot;input[type=text], input[type=password] { width: 100%; padding: 10px; margin: 5px 0; }&quot;    &quot;input[type=submit] { padding: 10px 20px; background: #4CAF50; color: white; border: none; cursor: pointer; }&quot;    &quot;input[type=submit]:hover { background: #45a049; }&quot;    &quot;.status { padding: 10px; background: #f0f0f0; margin: 10px 0; }&quot;    &quot;&lt;/style&gt;&quot;    &quot;&lt;/head&gt;&lt;body&gt;&quot;;// &#x7B80;&#x5355;&#x7684;HTML&#x5C3E;&#x90E8;static const char* html_footer = &quot;&lt;/body&gt;&lt;/html&gt;&quot;;// &#x914D;&#x7F51;&#x9875;&#x9762;static const char* html_form =     &quot;&lt;h1&gt;WiFi&#x914D;&#x7F6E;&lt;/h1&gt;&quot;    &quot;&lt;form action=&apos;/config&apos;&gt;&quot;    &quot;&lt;label for=&apos;ssid&apos;&gt;WiFi&#x540D;&#x79F0;:&lt;/label&gt;&quot;    &quot;&lt;input type=&apos;text&apos; id=&apos;ssid&apos; name=&apos;ssid&apos; required&gt;&lt;br&gt;&quot;    &quot;&lt;label for=&apos;password&apos;&gt;&#x5BC6;&#x7801;:&lt;/label&gt;&quot;    &quot;&lt;input type=&apos;password&apos; id=&apos;password&apos; name=&apos;password&apos;&gt;&lt;br&gt;&quot;    // &quot;&lt;h3&gt;&#x9759;&#x6001;IP (&#x53EF;&#x9009;)&lt;/h3&gt;&quot;    // &quot;&lt;label for=&apos;ip&apos;&gt;IP&#x5730;&#x5740;:&lt;/label&gt;&quot;    // &quot;&lt;input type=&apos;text&apos; id=&apos;ip&apos; name=&apos;ip&apos;&gt;&lt;br&gt;&quot;    // &quot;&lt;label for=&apos;gw&apos;&gt;&#x7F51;&#x5173;:&lt;/label&gt;&quot;    // &quot;&lt;input type=&apos;text&apos; id=&apos;gw&apos; name=&apos;gw&apos;&gt;&lt;br&gt;&quot;    // &quot;&lt;label for=&apos;netmask&apos;&gt;&#x5B50;&#x7F51;&#x63A9;&#x7801;:&lt;/label&gt;&quot;    // &quot;&lt;input type=&apos;text&apos; id=&apos;netmask&apos; name=&apos;netmask&apos;&gt;&lt;br&gt;&quot;    &quot;&lt;input type=&apos;submit&apos; value=&apos;&#x8FDE;&#x63A5;&apos;&gt;&quot;    &quot;&lt;/form&gt;&quot;;// &#x914D;&#x7F6E;&#x6210;&#x529F;&#x9875;&#x9762;static const char* html_success =     &quot;&lt;h1&gt;&#x914D;&#x7F6E;&#x6210;&#x529F;!&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x6B63;&#x5728;&#x8FDE;&#x63A5;&#x7F51;&#x7EDC;...&lt;/p&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;/device&apos;&gt;&#x4E0B;&#x4E00;&#x6B65;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;;//&#x914D;&#x7F6E;&#x9519;&#x8BEF;static const char* html_error =     &quot;&lt;h1&gt;&#x914D;&#x7F6E;&#x9519;&#x8BEF;&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x8BF7;&#x8F93;&#x5165;&#x6709;&#x6548;&#x7684;WiFi&#x540D;&#x79F0;&lt;/p&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;/&apos;&gt;&#x8FD4;&#x56DE;&#x914D;&#x7F6E;&#x9875;&#x9762;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;;// &#x8FDE;&#x63A5;&#x9875;&#x9762;static const char* html_device =     &quot;&lt;h1&gt;&#x8BBE;&#x5907;&#x63A7;&#x5236;&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x8BBE;&#x5907;&#x5DF2;&#x8FDE;&#x63A5;&lt;/p&gt;&quot;    &quot;&lt;p&gt;IP&#x5730;&#x5740;: %s&lt;/p&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;http://%s/command&apos;&gt;&#x8BBF;&#x95EE;&#x8BBE;&#x5907;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;p&gt;&lt;a href=&apos;http://%s/closeap&apos;&gt;&#x5173;&#x95ED;AP&#x6A21;&#x5F0F;&lt;/a&gt;&lt;/p&gt;&quot;;// AP&#x5173;&#x95ED;&#x9875;&#x9762;static const char* html_ap_off =     &quot;&lt;h1&gt;AP&#x6A21;&#x5F0F;&#x5DF2;&#x5173;&#x95ED;&lt;/h1&gt;&quot;    &quot;&lt;div class=&apos;status&apos;&gt;&quot;    &quot;&lt;p&gt;&#x4F7F;&#x7528;ip&#x5730;&#x5740;&lt;a href=http://%s/command&gt;&#x8BBF;&#x95EE;&#x8BBE;&#x5907;&lt;/a&gt;&lt;/p&gt;&quot;    &quot;&lt;/div&gt;&quot;;static const char* html_control =     &quot;&lt;h1 style=&apos;text-align:center&apos;&gt;&#x673A;&#x5668;&#x4EBA;&#x63A7;&#x5236;&lt;/h1&gt;&quot;    &quot;&lt;div style=&apos;margin:20px auto;text-align:center&apos;&gt;&quot;    &quot;&lt;label&gt;&#x901F;&#x5EA6;&#x503C;&#xFF1A;&lt;input type=&apos;number&apos; id=&apos;speed&apos; min=&apos;1&apos; max=&apos;100&apos; value=&apos;70&apos; style=&apos;width:80px&apos;&gt;&lt;/label&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;div style=&apos;display:flex;flex-direction:column;align-items:center;gap:12px&apos;&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;forward\\&quot;)&apos;&gt;&#x2191;&lt;/button&gt;&quot;    &quot;&lt;div style=&apos;display:flex;gap:8px&apos;&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;left\\&quot;)&apos;&gt;&#x2190;&lt;/button&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;right\\&quot;)&apos;&gt;&#x2192;&lt;/button&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;min-width:60px&apos; onclick=&apos;sendCmd(\\&quot;backward\\&quot;)&apos;&gt;&#x2193;&lt;/button&gt;&quot;    &quot;&lt;button style=&apos;padding:12px 24px;font-size:18px;background:#ff4444&apos; onclick=&apos;sendCmd(\\&quot;stop\\&quot;)&apos;&gt;&#x7D27;&#x6025;&#x505C;&#x6B62;&lt;/button&gt;&quot;    &quot;&lt;/div&gt;&quot;    &quot;&lt;script&gt;&quot;    &quot;function sendCmd(cmd){&quot;    &quot;  let speed=document.getElementById(&apos;speed&apos;).value;&quot;    &quot;  fetch(`http://%s/command?cmd=${cmd}&amp;speed=${speed}`);&quot;    &quot;}&quot;    &quot;&lt;/script&gt;&quot;;/* URI &#x5904;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x5728;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x8D77; GET /helloworld &#x8BF7;&#x6C42;&#x65F6;&#x88AB;&#x8C03;&#x7528; *//* An HTTP GET handler */static esp_err_t hello_world_handler(httpd_req_t *req){\tchar *buf;\tsize_t buf_len;\t/* Get header value string length and allocate memory for length + 1,\t * extra byte for null termination */\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Host&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\t/* Copy null terminated value string into buffer */\t\tif (httpd_req_get_hdr_value_str(req, &quot;Host&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Host: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-2&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-2&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-2: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-1&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-1&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-1: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\t/* Set some custom headers */\t//&#x8BBE;&#x7F6E;&#x81EA;&#x5B9A;&#x4E49;&#x5934;\thttpd_resp_set_hdr(req, &quot;Custom-Header-1&quot;, &quot;Custom-Value-1&quot;);\thttpd_resp_set_hdr(req, &quot;Custom-Header-2&quot;, &quot;Custom-Value-2&quot;);\t/* Send response with custom headers and body set as the\t * string passed in user context*/\tconst char *resp_str = (const char *)req-&gt;user_ctx;\t\t\thttpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);\t//&#x53D1;&#x9001;resp_str&#x5B57;&#x7B26;&#x4E32;&#x5185;&#x5BB9;\t/* After sending the HTTP response the old HTTP request\t * headers are lost. Check if HTTP request headers can be read now. */\t//&#x54CD;&#x5E94;http&#x65E7;&#x8BF7;&#x6C42;&#x540E;&#x68C0;&#x67E5;\tif (httpd_req_get_hdr_value_len(req, &quot;Host&quot;) == 0)\t{\t\tESP_LOGI(TAG, &quot;Request headers lost&quot;);\t}\treturn ESP_OK;}static const httpd_uri_t hello_world = {    .uri = &quot;/helloworld&quot;,    .method = HTTP_GET,    .handler = hello_world_handler,    .user_ctx = &quot;Hello World!&quot;,};// static esp_err_t get_status_handler(httpd_req_t *req){// \tcommand_params_t get_status_handler;// \tif(command_get_current_command(&amp;get_status_handler)!=0){// \t\thttpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, &quot;Invalid command&quot;);//         return ESP_OK;// \t}// \tchar statusString[100];// \tsprintf(statusString,&quot;Command set: %s, Speed: %d%%, Continuous: %d&quot;,// \t\t\tcmd_strings[get_status_handler.type], get_status_handler.speed, get_status_handler.is_continuous);// \thttpd_resp_send(req, statusString, HTTPD_RESP_USE_STRLEN);// \treturn ESP_OK;// }// static const httpd_uri_t uri_get_status = {//     .uri = &quot;/status&quot;,//     .method = HTTP_GET,//     .handler = get_status_handler,//     .user_ctx = NULL,// };// HTTP&#x8BF7;&#x6C42;&#x5904;&#x7406;&#x51FD;&#x6570;static esp_err_t root_handler(httpd_req_t *req){    char *html_content = NULL;        if (ap_active &amp;&amp; !sta_connected) {        // &#x663E;&#x793A;&#x914D;&#x7F51;&#x9875;&#x9762;        size_t len = strlen(html_header) + strlen(html_form) + strlen(html_footer) + 1;        html_content = malloc(len);        if (html_content) {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_form, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }    } else if (sta_connected) {        // &#x663E;&#x793A;&#x6210;&#x529F;&#x9875;&#x9762;        size_t len = strlen(html_header) + strlen(html_success) + strlen(html_footer) + 1;        html_content = malloc(len);        if (html_content) {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_success, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }    }        // &#x9ED8;&#x8BA4;&#x54CD;&#x5E94;    httpd_resp_send(req, &quot;&#x8BBE;&#x5907;&#x72B6;&#x6001;&#x672A;&#x77E5;&quot;, HTTPD_RESP_USE_STRLEN);    return ESP_OK;}static httpd_uri_t root_uri = {            .uri = &quot;/&quot;,            .method = HTTP_GET,            .handler = root_handler};//&#x914D;&#x7F6E;&#x51FD;&#x6570;static esp_err_t config_handler(httpd_req_t *req){    char query[200];    if (httpd_req_get_url_query_str(req, query, sizeof(query)) != ESP_OK) {        httpd_resp_send(req, &quot;&#x65E0;&#x6548;&#x8BF7;&#x6C42;&quot;, HTTPD_RESP_USE_STRLEN);        return ESP_FAIL;    }        wifi_info_config_t config = {0};        httpd_query_key_value(query, &quot;ssid&quot;, config.ssid, sizeof(config.ssid));    httpd_query_key_value(query, &quot;password&quot;, config.password, sizeof(config.password));        ESP_LOGI(&quot;HTTP&quot;, &quot;&#x6536;&#x5230;&#x914D;&#x7F6E;: SSID=%s, PASSWORD=%s&quot;, config.ssid, config.password);    // &#x4FDD;&#x5B58;&#x914D;&#x7F6E;&#x5230;NVS    wifi_save_config(&amp;config);        // &#x8BBE;&#x7F6E;STA&#x914D;&#x7F6E;    wifi_config_sta(&amp;config);    xSemaphoreTake(wifiStaConnectedHandle, pdTICKS_TO_MS(500));    // &#x663E;&#x793A;&#x6210;&#x529F;&#x9875;&#x9762;    if(sta_connected == true){        size_t len = strlen(html_header) + strlen(html_success) + strlen(html_footer) + 1;        char *html_content = malloc(len);        if (html_content)        {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_success, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }        httpd_resp_send(req, &quot;&#x914D;&#x7F6E;&#x5DF2;&#x4FDD;&#x5B58;&quot;, HTTPD_RESP_USE_STRLEN);    }    else if(sta_connected == false){        wifi_clear_config();        // &#x663E;&#x793A;&#x9519;&#x8BEF;&#x9875;&#x9762;        size_t len = strlen(html_header) + strlen(html_error) + strlen(html_footer) + 1;        char *html_content = malloc(len);        if (html_content) {            snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_error, html_footer);            httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);            free(html_content);            return ESP_OK;        }        httpd_resp_send(req, &quot;&#x914D;&#x7F6E;&#x5DF2;&#x5220;&#x9664;&quot;, HTTPD_RESP_USE_STRLEN);    }        return ESP_OK;}static httpd_uri_t config_uri = {            .uri = &quot;/config&quot;,            .method = HTTP_GET,            .handler = config_handler};//&#x8BBE;&#x5907;&#x63A7;&#x5236;static esp_err_t device_handler(httpd_req_t *req){    char html_device_temp[256];    snprintf(html_device_temp, sizeof(html_device_temp), html_device, sta_ip, sta_ip, sta_ip);    size_t len = strlen(html_header) + strlen(html_device_temp) + strlen(html_footer) + 1;    char *html_content = malloc(len);    if (html_content) {        snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_device_temp, html_footer);        httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);        free(html_content);        return ESP_OK;    }    // &#x91CD;&#x5B9A;&#x5411;&#x56DE;&#x6839;&#x9875;&#x9762;    httpd_resp_set_status(req, &quot;303 See Other&quot;);    httpd_resp_set_hdr(req, &quot;Location&quot;, &quot;/&quot;);    httpd_resp_send(req, NULL, 0);        return ESP_OK;}static httpd_uri_t device_uri = {            .uri = &quot;/device&quot;,            .method = HTTP_GET,            .handler = device_handler};//&#x5173;&#x95ED;apstatic esp_err_t closeap_handler(httpd_req_t *req){    wifi_close_ap();        // &#x663E;&#x793A;AP&#x5173;&#x95ED;&#x9875;&#x9762;    char html_ap_off_temp[256];    snprintf(html_ap_off_temp, sizeof(html_ap_off_temp), html_ap_off, sta_ip);        size_t len = strlen(html_header) + strlen(html_ap_off_temp) + strlen(html_footer) + 1;    char *html_content = malloc(len);    if (html_content) {        snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_ap_off_temp, html_footer);        httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);        free(html_content);        return ESP_OK;    }        httpd_resp_send(req, &quot;AP&#x6A21;&#x5F0F;&#x5DF2;&#x5173;&#x95ED;&quot;, HTTPD_RESP_USE_STRLEN);    return ESP_OK;}static httpd_uri_t closeap_uri = {            .uri = &quot;/closeap&quot;,            .method = HTTP_GET,            .handler = closeap_handler};// favicon.ico &#x5904;&#x7406;&#x51FD;&#x6570;static esp_err_t favicon_handler(httpd_req_t *req){    // &#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x7A7A;&#x54CD;&#x5E94;    httpd_resp_set_status(req, &quot;204 No Content&quot;);    httpd_resp_send(req, NULL, 0);    return ESP_OK;}// &#x6DFB;&#x52A0; favicon.ico &#x5904;&#x7406;static httpd_uri_t favicon_uri = {            .uri = &quot;/favicon.ico&quot;,            .method = HTTP_GET,            .handler = favicon_handler};//&#x6307;&#x4EE4;&#x89E3;&#x6790;&#x51FD;&#x6570;&#xFF0C;&#x8FD9;&#x91CC;&#x53EF;&#x4EE5;&#x6362;&#x6210;&#x4F60;&#x9700;&#x8981;&#x7684;&#x529F;&#x80FD;&#xFF0C;&#x6307;&#x4EE4;&#x89E3;&#x6790;&#x53EA;&#x662F;&#x4E00;&#x4E2A;&#x793A;&#x4F8B;static esp_err_t set_cmd_handler(httpd_req_t *req){    char html_control_temp[1024];    snprintf(html_control_temp, sizeof(html_control_temp), html_control, sta_ip);    size_t len = strlen(html_header) + strlen(html_control_temp) + strlen(html_footer) + 1;    char *html_content = malloc(len);    if (html_content) {        snprintf(html_content, len, &quot;%s%s%s&quot;, html_header, html_control_temp, html_footer);        httpd_resp_send(req, html_content, HTTPD_RESP_USE_STRLEN);        free(html_content);    }\tif(command_parse_http_get(req-&gt;uri)!=0){\t\thttpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, &quot;Invalid command&quot;);        return ESP_OK;\t}\thttpd_resp_send(req, &quot;OK&quot;, HTTPD_RESP_USE_STRLEN);    return ESP_OK;}static const httpd_uri_t cmdControl_uri = {    .uri = &quot;/command&quot;,    .method = HTTP_GET,    .handler = set_cmd_handler,    .user_ctx = NULL,};httpd_handle_t start_webserver(void){    //&#x751F;&#x6210;&#x9ED8;&#x8BA4;http&#x914D;&#x7F6E;&#x53C2;&#x6570;    httpd_config_t http_config = HTTPD_DEFAULT_CONFIG();    http_config.max_uri_handlers = 8;       //&#x6700;&#x5927;uri&#x6570;    if (httpd_start(&amp;server, &amp;http_config) == ESP_OK) {        /* &#x6CE8;&#x518C; URI &#x5904;&#x7406;&#x7A0B;&#x5E8F; */        // httpd_register_uri_handler(server, &amp;uri_get_status);        httpd_register_uri_handler(server, &amp;cmdControl_uri);        httpd_register_uri_handler(server, &amp;hello_world);        httpd_register_uri_handler(server, &amp;root_uri);        httpd_register_uri_handler(server, &amp;config_uri);        httpd_register_uri_handler(server, &amp;device_uri);        httpd_register_uri_handler(server, &amp;closeap_uri);        httpd_register_uri_handler(server, &amp;favicon_uri);        ESP_LOGI(TAG, &quot;Success starting server!&quot;);        return server;            }    /* &#x5982;&#x679C;&#x670D;&#x52A1;&#x5668;&#x542F;&#x52A8;&#x5931;&#x8D25;&#xFF0C;&#x8FD4;&#x56DE;&#x7684;&#x53E5;&#x67C4;&#x662F; NULL */    ESP_LOGI(TAG, &quot;Error starting server!&quot;);    return NULL;}void stop_webserver(void){    if (server) {        httpd_stop(server);        server = NULL;        ESP_LOGI(TAG, &quot;server stop&quot;);    }}\n&#x7F51;&#x7EDC;&#x534F;&#x8BAE;&#x8FD9;&#x5757;&#x7B14;&#x8005;&#x53EA;&#x662F;&#x7167;&#x732B;&#x753B;&#x864E;&#x52C9;&#x5F3A;&#x80FD;&#x7528;\n\nHTTP_ServerHTTP &#x5DE5;&#x4F5C;&#x539F;&#x7406;HTTP &#x534F;&#x8BAE;&#x5DE5;&#x4F5C;&#x4E8E;&#x5BA2;&#x6237;&#x7AEF;-&#x670D;&#x52A1;&#x7AEF;&#x67B6;&#x6784;&#x4E0A;&#x3002;\nHTTP &#x5DE5;&#x4F5C;&#x8FC7;&#x7A0B;&#x901A;&#x5E38;&#x5982;&#x4E0B;&#xFF1A;\n\n&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x8D77;&#x8BF7;&#x6C42;&#xFF1A;&#x7528;&#x6237;&#x901A;&#x8FC7;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;&#x5982;&#x6D4F;&#x89C8;&#x5668;&#xFF09;&#x8F93;&#x5165; URL&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x8D77;&#x4E00;&#x4E2A; HTTP &#x8BF7;&#x6C42;&#x3002;\n&#x670D;&#x52A1;&#x5668;&#x5904;&#x7406;&#x8BF7;&#x6C42;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x63A5;&#x6536;&#x5230;&#x8BF7;&#x6C42;&#x540E;&#xFF0C;&#x6839;&#x636E;&#x8BF7;&#x6C42;&#x7684;&#x7C7B;&#x578B;&#xFF08;&#x5982;GET&#x3001;POST&#x7B49;&#xFF09;&#x548C;&#x8BF7;&#x6C42;&#x7684;&#x8D44;&#x6E90;&#xFF0C;&#x8FDB;&#x884C;&#x76F8;&#x5E94;&#x7684;&#x5904;&#x7406;&#x3002;\n&#x670D;&#x52A1;&#x5668;&#x8FD4;&#x56DE;&#x54CD;&#x5E94;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x5C06;&#x5904;&#x7406;&#x7ED3;&#x679C;&#x5305;&#x88C5;&#x6210;HTTP&#x54CD;&#x5E94;&#x6D88;&#x606F;&#xFF0C;&#x53D1;&#x9001;&#x56DE;&#x5BA2;&#x6237;&#x7AEF;&#x3002;4.&#x5BA2;&#x6237;&#x7AEF;&#x6E32;&#x67D3;&#x9875;&#x9762;&#xFF1A;&#x5BA2;&#x6237;&#x7AEF;&#x63A5;&#x6536;&#x5230;&#x54CD;&#x5E94;&#x540E;&#xFF0C;&#x6839;&#x636E;&#x54CD;&#x5E94;&#x5185;&#x5BB9;&#xFF08;&#x5982;HTML&#x3001;&#x56FE;&#x7247;&#x7B49;&#xFF09;&#x6E32;&#x67D3;&#x9875;&#x9762;&#xFF0C;&#x5C55;&#x793A;&#x7ED9;&#x7528;&#x6237;&#x3002;Web &#x670D;&#x52A1;&#x5668;&#x6709;&#xFF1A;Nginx &#x670D;&#x52A1;&#x5668;&#xFF0C;Apache &#x670D;&#x52A1;&#x5668;&#xFF0C;IIS &#x670D;&#x52A1;&#x5668;&#xFF08;Internet Information Services&#xFF09;&#x7B49;&#x3002;\n\nHTTP &#x9ED8;&#x8BA4;&#x7AEF;&#x53E3;&#x53F7;&#x4E3A; 80&#xFF0C;&#x4F46;&#x662F;&#x4F60;&#x4E5F;&#x53EF;&#x4EE5;&#x6539;&#x4E3A; 8080 &#x6216;&#x8005;&#x5176;&#x4ED6;&#x7AEF;&#x53E3;&#x3002;\nHTTP &#x4E09;&#x70B9;&#x6CE8;&#x610F;&#x4E8B;&#x9879;&#xFF1A;\n\nHTTP &#x662F;&#x65E0;&#x8FDE;&#x63A5;&#xFF1A;&#x65E0;&#x8FDE;&#x63A5;&#x7684;&#x542B;&#x4E49;&#x662F;&#x9650;&#x5236;&#x6BCF;&#x6B21;&#x8FDE;&#x63A5;&#x53EA;&#x5904;&#x7406;&#x4E00;&#x4E2A;&#x8BF7;&#x6C42;&#xFF0C;&#x670D;&#x52A1;&#x5668;&#x5904;&#x7406;&#x5B8C;&#x5BA2;&#x6237;&#x7684;&#x8BF7;&#x6C42;&#xFF0C;&#x5E76;&#x6536;&#x5230;&#x5BA2;&#x6237;&#x7684;&#x5E94;&#x7B54;&#x540E;&#xFF0C;&#x5373;&#x65AD;&#x5F00;&#x8FDE;&#x63A5;&#xFF0C;&#x91C7;&#x7528;&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x53EF;&#x4EE5;&#x8282;&#x7701;&#x4F20;&#x8F93;&#x65F6;&#x95F4;&#x3002;\n\nHTTP &#x662F;&#x5A92;&#x4F53;&#x72EC;&#x7ACB;&#x7684;&#xFF1A;&#x8FD9;&#x610F;&#x5473;&#x7740;&#xFF0C;&#x53EA;&#x8981;&#x5BA2;&#x6237;&#x7AEF;&#x548C;&#x670D;&#x52A1;&#x5668;&#x77E5;&#x9053;&#x5982;&#x4F55;&#x5904;&#x7406;&#x7684;&#x6570;&#x636E;&#x5185;&#x5BB9;&#xFF0C;&#x4EFB;&#x4F55;&#x7C7B;&#x578B;&#x7684;&#x6570;&#x636E;&#x90FD;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;HTTP&#x53D1;&#x9001;&#xFF0C;&#x5BA2;&#x6237;&#x7AEF;&#x4EE5;&#x53CA;&#x670D;&#x52A1;&#x5668;&#x6307;&#x5B9A;&#x4F7F;&#x7528;&#x9002;&#x5408;&#x7684; MIME-type &#x5185;&#x5BB9;&#x7C7B;&#x578B;&#x3002;\n\nHTTP &#x662F;&#x65E0;&#x72B6;&#x6001;&#xFF1A;HTTP &#x534F;&#x8BAE;&#x662F;&#x65E0;&#x72B6;&#x6001;&#x534F;&#x8BAE;&#xFF0C;&#x65E0;&#x72B6;&#x6001;&#x662F;&#x6307;&#x534F;&#x8BAE;&#x5BF9;&#x4E8E;&#x4E8B;&#x52A1;&#x5904;&#x7406;&#x6CA1;&#x6709;&#x8BB0;&#x5FC6;&#x80FD;&#x529B;&#xFF0C;&#x7F3A;&#x5C11;&#x72B6;&#x6001;&#x610F;&#x5473;&#x7740;&#x5982;&#x679C;&#x540E;&#x7EED;&#x5904;&#x7406;&#x9700;&#x8981;&#x524D;&#x9762;&#x7684;&#x4FE1;&#x606F;&#xFF0C;&#x5219;&#x5B83;&#x5FC5;&#x987B;&#x91CD;&#x4F20;&#xFF0C;&#x8FD9;&#x6837;&#x53EF;&#x80FD;&#x5BFC;&#x81F4;&#x6BCF;&#x6B21;&#x8FDE;&#x63A5;&#x4F20;&#x9001;&#x7684;&#x6570;&#x636E;&#x91CF;&#x589E;&#x5927;&#xFF0C;&#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF0C;&#x5728;&#x670D;&#x52A1;&#x5668;&#x4E0D;&#x9700;&#x8981;&#x5148;&#x524D;&#x4FE1;&#x606F;&#x65F6;&#x5B83;&#x7684;&#x5E94;&#x7B54;&#x5C31;&#x8F83;&#x5FEB;&#x3002;\n\n&#x4EE5;&#x4E0A;&#x5185;&#x5BB9;&#x6458;&#x81EA;&#x83DC;&#x9E1F;&#x6559;&#x7A0B;\n\n\n\n&#x53C2;&#x6570;&#x8BBE;&#x7F6E;\n&#x542F;&#x52A8;http&#x670D;&#x52A1;&#x5668;httpd_start(httpd_handle_t *handle, const httpd_config_t *config)  httpd_start(&amp;server, &amp;http_config)\nhttpd_config_t http_config = HTTPD_DEFAULT_CONFIG();    //&#x9ED8;&#x8BA4;&#x914D;&#x7F6E;\nhttp_config.max_uri_handlers = 8;       //&#x6700;&#x5927;uri&#x6570;\nstatic httpd_handle_t server = NULL;    //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;&#xFF0C;&#x9632;&#x6B62;&#x91CD;&#x590D;&#x542F;&#x52A8;HTTP&#x670D;&#x52A1;\n\n\n&#x5F53;http&#x670D;&#x52A1;&#x542F;&#x52A8;&#x6210;&#x529F;&#x540E;&#x9700;&#x8981;&#x6CE8;&#x518C;uri&#x5904;&#x7406;&#x51FD;&#x6570;httpd_register_uri_handler(httpd_handle_t handle,const httpd_uri_t *uri_handler) httpd_register_uri_handler(server, &amp;hello_world);\nstatic httpd_handle_t server = NULL;    //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;&#xFF0C;&#x9632;&#x6B62;&#x91CD;&#x590D;&#x542F;&#x52A8;HTTP&#x670D;&#x52A1;\n&amp;hello_world &#x6307;&#x5411;uri&#x5904;&#x7406;&#x51FD;&#x6570;&#x4E2D;&#x9700;&#x8981;&#x7684;&#x4FE1;&#x606F;&#x7ED3;&#x6784;&#x4F53;&#xFF1A;     static const httpd_uri_t hello_world = {    .uri = &quot;/helloworld&quot;,           //uri    .method = HTTP_GET,             //&#x65B9;&#x6CD5;    .handler = hello_world_handler, //&#x4E0A;&#x4E0B;&#x6587;&#x6570;&#x636E;    .user_ctx = &quot;Hello World!&quot;,     //&#x7528;&#x6237;&#x7684;&#x4E0A;&#x4E0B;&#x6587;};\n\n\n&#x505C;&#x6B62;http&#x670D;&#x52A1;&#x5668;httpd_stop(httpd_handle_t handle)  httpd_stop(server);\nstatic httpd_handle_t server = NULL;    //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;&#xFF0C;&#x9632;&#x6B62;&#x91CD;&#x590D;&#x542F;&#x52A8;HTTP&#x670D;&#x52A1;\n\n\n\n&#x5B9E;&#x6218;&#x4EE5;&#x8BF7;&#x6C42;hello world&#x4E3A;&#x4F8B;\n//http_server.h#ifndef _HTTP_SERVER_H#define _HTTP_SERVER_H#include &lt;stdint.h&gt;#include &quot;esp_http_server.h&quot;#ifdef __cplusplusextern &quot;C&quot; {#endifhttpd_handle_t start_webserver(void);void stop_webserver(void);#ifdef _cplusplus}#endif#endif\n//http_server.c#include &lt;stdio.h&gt;#include &quot;esp_log.h&quot;#include &quot;esp_check.h&quot;#include &quot;http_server.h&quot;#include &quot;cmd_parser.h&quot;#include &quot;wifi_driver.h&quot;#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))#define EXAMPLE_HTTP_QUERY_KEY_MAX_LEN  (64)static const char *TAG = &quot;HTTP&quot;;static httpd_handle_t server = NULL;        //&#x7F6E;&#x7A7A;esp_http_server&#x5B9E;&#x4F8B;&#x7684;&#x53E5;&#x67C4;/* URI &#x5904;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x5728;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x8D77; GET /helloworld &#x8BF7;&#x6C42;&#x65F6;&#x88AB;&#x8C03;&#x7528; *//* An HTTP GET handler */static esp_err_t hello_world_handler(httpd_req_t *req){\tchar *buf;\tsize_t buf_len;\t/* Get header value string length and allocate memory for length + 1,\t * extra byte for null termination */\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Host&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\t/* Copy null terminated value string into buffer */\t\tif (httpd_req_get_hdr_value_str(req, &quot;Host&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Host: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-2&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-2&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-2: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\tbuf_len = httpd_req_get_hdr_value_len(req, &quot;Test-Header-1&quot;) + 1;\tif (buf_len &gt; 1)\t{\t\tbuf = malloc(buf_len);\t\tESP_RETURN_ON_FALSE(buf, ESP_ERR_NO_MEM, TAG, &quot;buffer alloc failed&quot;);\t\tif (httpd_req_get_hdr_value_str(req, &quot;Test-Header-1&quot;, buf, buf_len) == ESP_OK)\t\t{\t\t\tESP_LOGI(TAG, &quot;Found header =&gt; Test-Header-1: %s&quot;, buf);\t\t}\t\tfree(buf);\t}\t/* Set some custom headers */\t//&#x8BBE;&#x7F6E;&#x81EA;&#x5B9A;&#x4E49;&#x5934;\thttpd_resp_set_hdr(req, &quot;Custom-Header-1&quot;, &quot;Custom-Value-1&quot;);\thttpd_resp_set_hdr(req, &quot;Custom-Header-2&quot;, &quot;Custom-Value-2&quot;);\t/* Send response with custom headers and body set as the\t * string passed in user context*/\tconst char *resp_str = (const char *)req-&gt;user_ctx;\t\t\thttpd_resp_send(req, resp_str, HTTPD_RESP_USE_STRLEN);\t//&#x53D1;&#x9001;resp_str&#x5B57;&#x7B26;&#x4E32;&#x5185;&#x5BB9;\t/* After sending the HTTP response the old HTTP request\t * headers are lost. Check if HTTP request headers can be read now. */\t//&#x54CD;&#x5E94;http&#x65E7;&#x8BF7;&#x6C42;&#x540E;&#x68C0;&#x67E5;\tif (httpd_req_get_hdr_value_len(req, &quot;Host&quot;) == 0)\t{\t\tESP_LOGI(TAG, &quot;Request headers lost&quot;);\t}\treturn ESP_OK;}//uri&#x914D;&#x7F6E;&#x4FE1;&#x606F;static const httpd_uri_t hello_world = {    .uri = &quot;/helloworld&quot;,    .method = HTTP_GET,    .handler = hello_world_handler,    .user_ctx = &quot;Hello World!&quot;,};//&#x542F;&#x52A8;http&#x670D;&#x52A1;httpd_handle_t start_webserver(void){    //&#x751F;&#x6210;&#x9ED8;&#x8BA4;http&#x914D;&#x7F6E;&#x53C2;&#x6570;    httpd_config_t http_config = HTTPD_DEFAULT_CONFIG();    http_config.max_uri_handlers = 8;       //&#x6700;&#x5927;uri&#x6570;    if (httpd_start(&amp;server, &amp;http_config) == ESP_OK) {        /* &#x6CE8;&#x518C; URI &#x5904;&#x7406;&#x7A0B;&#x5E8F; */        httpd_register_uri_handler(server, &amp;hello_world);        ESP_LOGI(TAG, &quot;Success starting server!&quot;);        return server;            }    /* &#x5982;&#x679C;&#x670D;&#x52A1;&#x5668;&#x542F;&#x52A8;&#x5931;&#x8D25;&#xFF0C;&#x8FD4;&#x56DE;&#x7684;&#x53E5;&#x67C4;&#x662F; NULL */    ESP_LOGI(TAG, &quot;Error starting server!&quot;);    return NULL;}//&#x505C;&#x6B62;http&#x670D;&#x52A1;void stop_webserver(void){    if (server) {        httpd_stop(server);        server = NULL;        ESP_LOGI(TAG, &quot;server stop&quot;);    }}","categories":["ESP32"],"tags":["ç¬”è®°","ESP32"]},{"title":"stm32h750æ·»åŠ QRencodeåº“ï¼Œä»¥zabrå’Œquircä¸ºä¾‹","url":"/2025/08/13/stm32h750%E6%B7%BB%E5%8A%A0QRencode%E5%BA%93%EF%BC%8C%E4%BB%A5zabr%E5%92%8Cquirc%E4%B8%BA%E4%BE%8B/","content":"&#x524D;&#x8A00;&#x5F00;&#x53D1;&#x677F; STM32H750VET6&#x5148;&#x8BF4;&#x7ED3;&#x8BBA;&#xFF1A;zbar 0.10&#x7F16;&#x8BD1;&#x51FA;&#x7684;&#x6587;&#x4EF6;&#x592A;&#x5927;&#x4E14;&#x6211;&#x7684;boot&#x8DF3;&#x8F6C;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x65E0;&#x6CD5;&#x5728;&#x5F00;&#x53D1;&#x677F;&#x4E0A;&#x8FD0;&#x884C;&#xFF0C;&#x4F46;&#x662F;&#x5728;pc&#x4E0A;&#x8FD0;&#x884C;&#x6CA1;&#x95EE;&#x9898;&#xFF0C;&#x9664;&#x4E86;&#x4E0D;&#x80FD;&#x8BC6;&#x522B;&#x6761;&#x5F62;&#x7801;&#x8FD9;&#x4E00;&#x70B9;&#x3002;&#x4E8E;&#x662F;&#x4F7F;&#x7528;&#x4E86;&#x66F4;&#x8F7B;&#x91CF;&#x7684;quirc&#xFF0C;&#x7136;&#x540E;&#x5C31;&#x80FD;&#x5728;&#x5F00;&#x53D1;&#x677F;&#x4E0A;&#x5B9E;&#x65F6;&#x8BC6;&#x522B;QR&#x7801;&#x4E86;&#x1F606;&#x6240;&#x4EE5;&#x540E;&#x9762;&#x4E3B;&#x8981;&#x662F;&#x4ECB;&#x7ECD;quric\n\n\n&#x4E4B;&#x524D;&#x5728; stm32h750 &#x4E0A;&#x5B9E;&#x73B0;DCMI&#x9A71;&#x52A8;&#x6444;&#x50CF;&#x5934;&#x540E;&#xFF0C;&#x60F3;&#x52A0;&#x5165;&#x4E8C;&#x7EF4;&#x7801;&#x89E3;&#x7801;&#x529F;&#x80FD;&#x3002;&#x672C;&#x6765;&#x662F;&#x79FB;&#x690D;zbar&#xFF0C;&#x4E2D;&#x95F4;&#x51E0;&#x756A;&#x6298;&#x78E8;&#x5728;&#x732B;&#x54AA;&#x5927;&#x4F6C;&#x7684;&#x5D4C;&#x5165;&#x5F0F;&#x673A;&#x5668;&#x89C6;&#x89C9;&#x5E93;&#x4E2D;&#x53D1;&#x73B0;&#x4E86;zbar&#x7684;&#x5B8C;&#x6574;&#x79FB;&#x690D;&#xFF0C;&#x518D;&#x52A0;&#x4E0A;&#x4E4B;&#x524D;&#x975E;&#x6B63;&#x5F0F;&#x7801;&#x519C;&#x6709;&#x5173;&#x4E8E;&#x5728;F4&#x5E73;&#x53F0;&#x7684;&#x79FB;&#x690D;&#xFF0C;&#x5728;&#x6B64;&#x611F;&#x8C22;&#x4E24;&#x4F4D;&#x5927;&#x4F6C;&#x3002;\nquirc&#x79FB;&#x690D;&#x94FE;&#x63A5; &#xFF1A;https://github.com/dlbeer/quirc&#x4E0B;&#x8F7D;&#x540E;&#x6253;&#x5F00;quirc&#x6587;&#x4EF6;&#x5939;&#xFF0C; lib &#x6587;&#x4EF6;&#x5939;&#x662F;&#x4E8C;&#x7EF4;&#x7801;&#x8BC6;&#x522B;&#x7684;&#x6838;&#x5FC3;&#x6E90;&#x7801;&#xFF0C;&#x79FB;&#x690D;&#x65F6;&#x52A1;&#x5FC5; &#x5168;&#x62F7;&#x8D1D;&#x3002;&#x5176;&#x4ED6;&#x6587;&#x4EF6;&#x5939;&#x662F;&#x5728;&#x4E0D;&#x540C;&#x5E73;&#x53F0;&#x7684;&#x793A;&#x4F8B;&#x548C;&#x6D4B;&#x8BD5;&#x6837;&#x4F8B;&#xFF0C;&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x662F;&#x53C2;&#x8003; tests/qrtest.c\n&#x53EF;&#x4EE5;&#x8BA9;AI&#x53C2;&#x8003;&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x6539;&#x6210;&#x4F60;&#x7684;&#x5E73;&#x53F0;&#xFF0C;&#x6216;&#x8005;&#x662F;&#x53C2;&#x8003;:QR_img.h &#x91CC;&#x9762;&#x662F;&#x4EE5;&#x6570;&#x7EC4;&#x65B9;&#x5F0F;&#x5B58;&#x50A8;&#x7684;qr&#x7801;&#x56FE;&#x7247;&#xFF0C;RGB565&#x683C;&#x5F0F;&#xFF0C;quirc.h quirc&#x89E3;&#x7801;&#x7684;&#x6838;&#x5FC3;&#x5934;&#x6587;&#x4EF6;\n#include &quot;QR_img.h&quot;#include &quot;quirc.h&quot;#include &quot;quirctest.h&quot;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;// RGB565&#x8F6C;&#x7070;&#x5EA6;&#x56FE;&#x51FD;&#x6570;unsigned char *rgb565_to_grayscale(const unsigned char *rgb565, int width,                                   int height) {    size_t gray_size = width * height;    unsigned char *gray = (unsigned char *)malloc(gray_size);    if (!gray)        return NULL;    for (int i = 0; i &lt; width * height; i++) {        // &#x4ECE;RGB565&#x63D0;&#x53D6;RGB&#x5206;&#x91CF;        unsigned short pixel =            ((unsigned short)rgb565[i * 2] &lt;&lt; 8) | rgb565[i * 2 + 1];        unsigned char r = (pixel &gt;&gt; 11) &amp; 0x1F;        unsigned char g = (pixel &gt;&gt; 5) &amp; 0x3F;        unsigned char b = pixel &amp; 0x1F;        // &#x8F6C;&#x6362;&#x4E3A;8&#x4F4D;&#x503C;        r = (r * 255) / 31;        g = (g * 255) / 63;        b = (b * 255) / 31;        // &#x8BA1;&#x7B97;&#x7070;&#x5EA6;&#x503C; (&#x6807;&#x51C6;&#x516C;&#x5F0F;: Y = 0.299R + 0.587G + 0.114B)        gray[i] = (unsigned char)((r * 299 + g * 587 + b * 114) / 1000);    }    return gray;}int quirctest(const unsigned char *image_data, int width, int height) {    // &#x8C03;&#x7528;&#x7070;&#x5EA6;&#x8F6C;&#x6362;&#x51FD;&#x6570;    unsigned char *gray_image = rgb565_to_grayscale(image_data, width, height);    if (!gray_image) {        printf(&quot;Failed to convert image to grayscale.\\n&quot;);        return 1;    }    // &#x521D;&#x59CB;&#x5316;&#x89E3;&#x7801;&#x5668;    struct quirc *qr = quirc_new();    if (!qr) {        printf(&quot;Failed to initialize QR decoder.\\n&quot;);        free(gray_image);        return 1;    }    // &#x5C06;&#x7070;&#x5EA6;&#x56FE;&#x50CF;&#x6570;&#x636E;&#x52A0;&#x8F7D;&#x5230;&#x89E3;&#x7801;&#x5668;    if (quirc_resize(qr, width, height) &lt; 0) {        printf(&quot;Failed to resize QR decoder.\\n&quot;);        quirc_destroy(qr);        free(gray_image);        return 1;    }    unsigned char *qr_image = quirc_begin(qr, NULL, NULL);    memcpy(qr_image, gray_image, width * height);    quirc_end(qr);    // &#x8BC6;&#x522B;&#x548C;&#x89E3;&#x7801;&#x4E8C;&#x7EF4;&#x7801;    int count = quirc_count(qr);    if (count &lt;= 0) {        printf(&quot;No QR codes found.\\n&quot;);    } else {        printf(&quot;Found %d QR code(s).\\n&quot;, count);        for (int i = 0; i &lt; count; i++) {            struct quirc_code code;            struct quirc_data data;            quirc_extract(qr, i, &amp;code);            quirc_decode_error_t err = quirc_decode(&amp;code, &amp;data);            if (err == QUIRC_ERROR_DATA_ECC) {                quirc_flip(&amp;code);                err = quirc_decode(&amp;code, &amp;data);            }            if (err) {                printf(&quot;  Decode failed: %s\\n&quot;, quirc_strerror(err));            } else {                printf(&quot;  Decoded data: %s\\n&quot;, data.payload);            }        }    }    // &#x91CA;&#x653E;&#x89E3;&#x7801;&#x5668;    quirc_destroy(qr);    printf(&quot;QR code decoding completed.\\n&quot;);    // &#x91CA;&#x653E;&#x5185;&#x5B58;    free(gray_image);    return 0;}int main() {    // &#x5047;&#x8BBE;&#x56FE;&#x50CF;&#x5BBD;&#x5EA6;&#x548C;&#x9AD8;&#x5EA6;&#x4E3A;150x150    int width = 150;    int height = 150;    // &#x8C03;&#x7528;quirctest&#x51FD;&#x6570;    return quirctest(gImage_QR_img, width, height);}\n\n&#x76EE;&#x524D;&#x6CA1;&#x6709;&#x8BD5;&#x8FC7;&#x4E2D;&#x6587;&#x89E3;&#x7801;\nzbar&#x79FB;&#x690D;&#x6211;&#x6700;&#x5F00;&#x59CB;&#x79FB;&#x690D;zbar&#x5230;pc&#x60F3;&#x76F4;&#x63A5;&#x7528;&#x8BFB;&#x6570;&#x7EC4;&#x56FE;&#x50CF;&#x7684;&#x65B9;&#x5F0F;&#x6765;&#x6D4B;&#x8BD5;&#x89E3;&#x7801;&#x529F;&#x80FD;&#xFF0C;&#x4F46;&#x662F;&#xFF0C;&#x5982;&#x679C;&#x4F60;&#x548C;&#x6211;&#x4E00;&#x6837;&#x662F;win&#x4E0B;&#x7684;mingw&#xFF0C;&#x4E00;&#x5B9A;&#x4F1A;&#x5728; iconv &#x94FE;&#x63A5;&#x5E93;&#x4E0A;&#x5361;&#x4F4F;&#x90A3;&#x4E48;iconv&#x662F;&#x4EC0;&#x4E48;&#x5462;&#xFF0C;&#x8BF7;bing&#x4E00;&#x4E0B;&#x56E0;&#x4E3A;&#x7F51;&#x4E0A;&#x7684;incov&#x94FE;&#x63A5;&#x5E93;&#x5728;mingw&#x4E0B;&#x90FD;&#x4E0D;&#x80FD;&#x7528;&#xFF0C;&#x8981;&#x4E48;&#x6362;&#x5DE5;&#x5177;&#x94FE;&#xFF0C;&#x8981;&#x4E48;&#x5C31;&#x81EA;&#x5DF1;&#x60F3;&#x529E;&#x6CD5;&#x4E0D;&#x4F7F;&#x7528;incov&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x624B;&#x52A8;&#x7F16;&#x7801;&#x800C;&#x4E0D;&#x4F7F;&#x7528;&#x5E93;\n&#x5F00;&#x59CB;&#x79FB;&#x690D;&#x7F51;&#x4E0A;&#x627E;&#x4E00;&#x4EFD;zbar0.10&#x7248;&#x672C;&#x7684;&#xFF0C;&#x7528;&#x4E8E;&#x5D4C;&#x5165;&#x5F0F;&#x7684;&#x57FA;&#x672C;&#x4E0A;&#x90FD;&#x662F;&#x57FA;&#x4E8E;&#x6B64;&#x7248;&#x79FB;&#x690D;&#x7684;&#x6253;&#x5F00;&#x5176;&#x4E2D;&#x7684; zbar &#x6587;&#x4EF6;&#x5939;&#xFF0C;&#x7136;&#x540E;&#x6839;&#x636E;&#x5F00;&#x5934;&#x6211;&#x63A8;&#x8350;&#x7684;&#x4E24;&#x4F4D;&#x5927;&#x4F6C;&#x7684;&#x8FDB;&#x884C;&#x79FB;&#x690D;&#x548C;&#x88C1;&#x526A;&#xFF0C;&#x5176;&#x4E2D;&#x6700;&#x91CD;&#x8981;&#x7684; config.h &#x6587;&#x4EF6;&#xFF0C;&#x56E0;&#x4E3A;&#x9664;&#x4E86;linux&#x4E0B;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;autoconf&#x751F;&#x6210;&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#xFF0C;&#x5176;&#x4ED6;&#x5E73;&#x53F0;&#x5C31;&#x53EA;&#x80FD;&#x62F7;&#x8D1D;&#xFF0C;&#x5F53;&#x7136;&#xFF0C;&#x8FD9;&#x4E24;&#x4F4D;&#x5927;&#x4F6C;&#x7684;&#x6587;&#x7AE0;&#x548C;&#x6E90;&#x7801;&#x4E2D;&#x90FD;&#x6709;&#x5BF9;&#x5E94;&#x7684;&#x90E8;&#x5206;&#xFF0C; &#x8FD8;&#x6709; include/zbar.h &#x4E5F;&#x8981;&#x6DFB;&#x52A0;&#x8FDB;&#x6765;\n&#x4FEE;&#x6539;&#x6E90;&#x7801;&#x505A;&#x5B8C;&#x524D;&#x9762;&#x7684;&#x5C31;&#x53EF;&#x4EE5;&#x5F00;&#x59CB;&#x624B;&#x52A8;&#x7F16;&#x7801;&#xFF0C;&#x8FD9;&#x91CC;&#x6211;&#x63A8;&#x8350;&#x732B;&#x54AA;&#x5927;&#x4F6C;&#x7684;zbar&#x79FB;&#x690D;&#xFF0C;&#x4F60;&#x751A;&#x81F3;&#x53EF;&#x4EE5;&#x76F4;&#x63A5;copy&#x3002;&#x4F46;&#x662F;&#x91CC;&#x9762;&#x6709;&#x4E00;&#x4E9B;&#x5B8F;&#x5B9A;&#x4E49;&#x9700;&#x8981;&#x4FEE;&#x6539;&#xFF0C;&#x4E3B;&#x8981;&#x662F;malloc&#x7B49;&#x7533;&#x8BF7;&#x5185;&#x5B58;&#x7684;&#xFF0C;&#x8FD9;&#x91CC;&#x90FD;&#x968F;&#x4FBF;&#xFF0C;&#x6211;&#x662F;&#x6539;&#x6210;&#x4E86;&#x6807;&#x51C6;c&#x7684;&#x540D;&#x79F0;\n&#x6211;&#x5728;pc&#x4E0A;&#x6D4B;&#x8BD5;&#x65F6;&#xFF0C;&#x53D1;&#x73B0;&#x53EF;&#x4EE5;&#x8BC6;&#x522B;QR&#x4F46;&#x662F;&#x4E0D;&#x80FD;&#x8BC6;&#x522B;code128&#x7B49;&#x6761;&#x7801;&#xFF0C;&#x6211;&#x4E5F;&#x4E0D;&#x77E5;&#x9053;&#x4E3A;&#x4EC0;&#x4E48;&#x3002;&#x4EA4;&#x53C9;&#x7F16;&#x8BD1;&#x540E;&#x80FD;&#x5360;&#x7528;&#x8FD1;80kb&#x7684;flash&#xFF0C;h750&#x7247;&#x5185;&#x53EA;&#x6709;128kb&#xFF0C;&#x7247;&#x5916;&#x8FD0;&#x884C;&#x53C8;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x8FD9;&#x4E5F;&#x662F;&#x6211;&#x6362;&#x6210;quirc&#x7684;&#x539F;&#x56E0;&#xFF0C;&#x53CD;&#x6B63;&#x53EA;&#x8BC6;&#x522B;QR&#x7801;\n&#x4FEE;&#x6539;&#x7684;&#x6587;&#x4EF6;&#x4E3B;&#x8981;&#x662F;&#x96C6;&#x4E2D;&#x5728; qrcode/qrdectxt.c &#xFF0C;&#x4E0D;&#x518D;&#x4F7F;&#x7528;iconv&#x6765;&#x8FDB;&#x884C;&#x5B57;&#x7B26;&#x7F16;&#x7801;&#x4E4B;&#x95F4;&#x8F6C;&#x6362;&#xFF0C;&#x800C;&#x662F;&#x624B;&#x52A8;&#x6307;&#x5B9A;unicode&#x8F6C;gb2312&#x5177;&#x4F53;&#x4FEE;&#x6539;&#x5728;&#x732B;&#x54AA;&#x5927;&#x4F6C;&#x7684;&#x5E93;&#x4E2D;\n&#x5B8C;\n","categories":["STM32"],"tags":["STM32","QRencode"]},{"title":"åµŒå…¥å¼bootå¼€å‘ï¼ˆä¸€ï¼‰","url":"/2025/09/18/%E5%B5%8C%E5%85%A5%E5%BC%8Fboot%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89/","content":"&#x524D;&#x8A00;&#x5728;&#x5D4C;&#x5165;&#x5F0F;&#x5F00;&#x53D1;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x80FD;&#x9700;&#x8981;&#x5C06;&#x7A0B;&#x5E8F;&#x653E;&#x5728;&#x5916;&#x90E8;flash&#xFF0C;&#x8FDC;&#x7A0B;&#x5347;&#x7EA7;&#xFF0C;&#x79BB;&#x7EBF;&#x70E7;&#x5F55;&#x7B49;&#x7B49;&#xFF0C;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#x5C31;&#x9700;&#x8981;&#x4E00;&#x4E2A;bootloader&#x7A0B;&#x5E8F;&#x6765;&#x5F15;&#x5BFC;&#x7A0B;&#x5E8F;&#x7684;&#x52A0;&#x8F7D;&#x3002;boot&#x8BD1;&#x4E3A;&#x5F15;&#x5BFC;&#xFF0C;loader&#x8BD1;&#x4E3A;&#x52A0;&#x8F7D;&#x3002;&#x672C;&#x7CFB;&#x5217;&#x6587;&#x7AE0;&#x65E8;&#x5728;&#x8BB0;&#x5F55;&#x5B66;&#x4E60;&#x7F16;&#x5199;boot&#x7A0B;&#x5E8F;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5E73;&#x53F0;&#x4E3A;STM32H750VBT6&#xFF0C;HAL&#x5E93;&#x3002;&#x5176;&#x4ED6;&#x5E73;&#x53F0;&#x80AF;&#x7565;&#x6709;&#x4E0D;&#x540C;&#xFF0C;&#x4F46;&#x662F;&#x60F3;&#x6CD5;&#x662F;&#x4E00;&#x81F4;&#x7684;\nbootloader&#x7528;&#x6765;&#x505A;&#x4EC0;&#x4E48;boot&#x52A0;&#x8F7D;&#x7A0B;&#x5E8F;&#xFF0C;&#x81EA;&#x7136;&#x5C31;&#x9700;&#x8981;&#x77E5;&#x9053;&#x7A0B;&#x5E8F;&#x5728;&#x54EA;&#x91CC;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#x6765;&#x68C0;&#x6D4B;app&#x662F;&#x5426;&#x88AB;&#x5199;&#x5165;&#x5230;&#x6307;&#x5B9A;&#x5730;&#x70B9; is_application_valid() ,&#x5982;&#x679C;app&#x5730;&#x5740;&#x6709;&#x7A0B;&#x5E8F;&#xFF0C;&#x5219; jump_to_application() &#xFF0C;&#x5426;&#x5219;&#x5C31;&#x8FDB;&#x5165; bootloader_mode() &#x3002;\nboot&#x662F;&#x4E0A;&#x7535;&#x540E;&#x6267;&#x884C;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x7A0B;&#x5E8F;&#xFF0C;&#x6240;&#x4EE5;&#x5B83;&#x7684;&#x5730;&#x5740;&#x662F;&#x56FA;&#x5B9A;&#x7684;&#xFF0C;&#x4F46;&#x662F;app&#x7A0B;&#x5E8F;&#x9700;&#x8981;&#x6211;&#x4EEC;&#x624B;&#x52A8;&#x6307;&#x5B9A;&#x4E00;&#x4E2A;&#x5730;&#x5740; APP_ADDRESS &#xFF0C;&#x6211;&#x6682;&#x65F6;&#x5C06;app&#x653E;&#x5728;0x08010000&#x3002;\nboot&#x90E8;&#x5206;&#x5927;&#x6982;&#x770B;&#x8D77;&#x6765;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF1A;\n//bootloaderint main(void) {    HAL_Init();    SystemClock_Config();    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    LED_On(&amp;LED);    if (is_application_valid()) {        jump_to_application();    } else {        bootloader_mode();    }    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {    }    /* USER CODE END 3 */}\n\n&#x68C0;&#x6D4B;app&#xFF0C;&#x8DF3;&#x8F6C;&#xFF0C;boot&#x6A21;&#x5F0F;&#x4E09;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x5B9E;&#x73B0;\n&#x68C0;&#x6D4B;app&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x68C0;&#x6D4B;&#x6808;&#x9876;&#x6307;&#x9488;&#x4F7F;&#x5176;&#x4E0D;&#x8981;&#x8D8A;&#x754C;&#x3002; &#x68C0;&#x6D4B; Reset_Handler &#x7A0B;&#x5E8F;&#x6307;&#x9488;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x56E0;&#x4E3A;&#x7A0B;&#x5E8F;&#x9ED8;&#x8BA4;&#x5165;&#x53E3;&#x70B9;&#x662F;&#x5B83;&#x3002;\n&#x8DF3;&#x8F6C;app&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x5173;&#x95ED;&#x4E2D;&#x65AD;&#xFF0C;&#x8BBE;&#x7F6E;&#x6808;&#x9876;&#x6307;&#x9488;&#xFF0C;&#x91CD;&#x8BBE;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x7684;&#x504F;&#x79FB;&#x503C;&#xFF0C;&#x8DF3;&#x8F6C;&#x5230; Reset_Handler &#xFF0C; Reset_Handler &#x7684;&#x5185;&#x5BB9;&#x5728;&#x542F;&#x52A8;&#x6587;&#x4EF6; startup_stm32h750xx.s&#x4E2D;&#xFF0C;&#x5176;&#x529F;&#x80FD;&#x4E3B;&#x8981;&#x662F;&#x521D;&#x59CB;&#x5316;&#x3002;\n\n&#x6808;&#x9876;&#x6307;&#x9488;&#x548C; Reset_Handler &#x5728;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x7684;&#x5F00;&#x5934;&#x548C;&#x504F;&#x79FB;4&#x5B57;&#x8282;&#x7684;&#x5730;&#x65B9;&#x800C;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x5728;&#x7A0B;&#x5E8F;&#x7684;&#x5F00;&#x5934;&#xFF0C;&#x56E0;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x7ED3;&#x6784;&#x4F53;&#x6765;&#x8BBF;&#x95EE;&#x8FD9;&#x4E24;&#x4E2A;&#x5730;&#x5740;\n// &#x8FD9;&#x4E0D;&#x662F;&#x5904;&#x7406;&#x5668;&#x8981;&#x6C42;&#x7684;&#xFF0C;&#x800C;&#x662F;&#x6211;&#x4EEC;&#x4E3A;&#x4E86;&#x65B9;&#x4FBF;&#x8BBF;&#x95EE;&#x800C;&#x5B9A;&#x4E49;&#x7684;typedef struct {    uint32_t stack_ptr;      // &#x504F;&#x79FB;0x00: &#x521D;&#x59CB;&#x6808;&#x6307;&#x9488;    pFunction reset_handler; // &#x504F;&#x79FB;0x04: &#x590D;&#x4F4D;&#x5904;&#x7406;&#x7A0B;&#x5E8F;    // &#x540E;&#x7EED;&#x8FD8;&#x6709;&#x5176;&#x4ED6;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#xFF0C;&#x4F46;Bootloader&#x901A;&#x5E38;&#x53EA;&#x9700;&#x8981;&#x524D;&#x4E24;&#x4E2A;} VectorTable_t;\n\nis_application_valid()\n&#x8FD9;&#x91CC;&#x6211;&#x7684;ram&#x5927;&#x5C0F;&#x662F;0x20000&#x4E5F;&#x5C31;&#x662F;128kb\nreset_handler&#x5730;&#x5740;&#x53D8;&#x91CF;&#x7EDD;&#x5BF9;&#x5927;&#x4E8E;app&#x8D77;&#x59CB;&#x5730;&#x5740;&#xFF0C;&#x4F46;&#x662F;&#x5C0F;&#x4E8E;flash&#x6700;&#x5927;&#x503C;\n&#x5982;&#x679C;flash&#x88AB;&#x64E6;&#x9664;&#x5219;&#x5176;&#x503C;&#x4E3A;&#x5168;F/0&#xFF0C;&#x901A;&#x8FC7;&#x68C0;&#x6D4B;app&#x5730;&#x5740;&#x540E;16&#x4E2A;&#x5B57;&#x6765;&#x5224;&#x65AD;app&#x5730;&#x5740;&#x662F;&#x5426;&#x6709;&#x7A0B;&#x5E8F;\n\nuint8_t is_application_valid(void) {    //&#x5C06;app&#x5730;&#x5740;&#x5F3A;&#x884C;&#x8F6C;&#x6362;&#x4E3A;&#x6307;&#x9488;&#xFF0C;&#x7136;&#x540E;&#x901A;&#x8FC7;&#x6307;&#x9488;&#x8BBF;&#x95EE;    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // check stack ptr is in valid addr scoop    // stm32 RAM usually start 0x2000 0000    if ((app_vector_table-&gt;stack_ptr &lt; 0x20000000) ||        (app_vector_table-&gt;stack_ptr &gt; 0x20020000)) {        return 0;    }    // check reset handle ptr is in valid addr scoop    uint32_t reset_handler = (uint32_t)app_vector_table-&gt;reset_handler;    if (reset_handler &lt; APP_ADDRESS ||        reset_handler &gt; FLASH_END) { /* &#x5FC5;&#x987B;&#x5728;&#x5E94;&#x7528;&#x7A0B;&#x5E8F; Flash &#x533A;&#x57DF;&#x5185; */        return 0;    }    // check irq table is 0 or 1 (esare state)    uint32_t *app_start = (uint32_t *)APP_ADDRESS;    for (int i = 0; i &lt; 16; i++) // check the first 16 word    {        if (app_start[i] != 0xFFFFFFFF &amp;&amp; app_start[i] != 0x00000000) {            // not empty data, app exit            // printf(&quot;Application validation passed\\r\\n&quot;);            return 1;        }    }    return 0;}\n\njump_to_application()&#x8DF3;&#x8F6C;app&#x65F6;&#x9700;&#x8981;&#x5148;&#x5173;&#x95ED;&#x4E2D;&#x65AD;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x8FD9;&#x91CC;&#x5DF2;&#x7ECF;&#x5173;&#x95ED;&#x4E2D;&#x65AD;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;app&#x51FD;&#x6570;&#x6267;&#x884C;&#x65F6;&#x4E00;&#x5B9A;&#x8981;&#x6253;&#x5F00;\nvoid jump_to_application(void) {    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // disabel irq    __disable_irq();    // set top stack pointer    __set_MSP(app_vector_table-&gt;stack_ptr);    // set irq table offset    SCB-&gt;VTOR = APP_ADDRESS;    // jump to app reset handle programe    app_vector_table-&gt;reset_handler();    // if jump defeated, programe don&apos;t run to here    while (1)        ;}\n\nbootloader_mode()&#x56E0;&#x4E3A;&#x53EA;&#x662F;&#x5B9E;&#x73B0;&#x7B80;&#x5355;&#x7684;&#x7A0B;&#x5E8F;&#x8DF3;&#x8F6C;&#xFF0C;&#x6240;&#x4EE5;boot&#x6A21;&#x5F0F;&#x53EA;&#x6709;&#x4E00;&#x4E2A;1s&#x7684;&#x706F;&#x540E;&#x7EED;&#x53EF;&#x4EE5;&#x6539;&#x4E3A;&#x624B;&#x52A8;&#x8FDB;&#x5165;boot&#x6A21;&#x5F0F;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x5176;&#x4E2D;&#x5B9E;&#x73B0;&#x56FA;&#x4EF6;&#x66F4;&#x65B0;&#x7B49;&#x529F;&#x80FD;\nvoid bootloader_mode(void) {    // app addr is no programe    while (1) {        LED_Blink(&amp;LED, 1000);    }}\n\n&#x7F16;&#x8BD1;boot&#x76F4;&#x63A5;&#x7F16;&#x8BD1;&#xFF0C;&#x4E0D;&#x8981;&#x4FEE;&#x6539;&#x4EFB;&#x4F55;&#x8BBE;&#x7F6E;&#xFF0C;&#x5C31;&#x548C;&#x5E73;&#x5E38;&#x7F16;&#x8BD1;&#x88F8;&#x673A;&#x7A0B;&#x5E8F;&#x90A3;&#x6837;\napp&#x8BE5;&#x505A;&#x4EC0;&#x4E48;?&#x9884;&#x5B9A;&#x4E49;app&#x5730;&#x5740; #define APP_ADDRESS 0x08010000\napp&#x7A0B;&#x5E8F;app&#x7A0B;&#x5E8F;&#x9700;&#x8981;&#x5728;&#x4E3B;&#x51FD;&#x6570;&#x4E00;&#x5F00;&#x59CB;&#x5C31;&#x6267;&#x884C; SCB-&gt;VTOR = APP_ADDRESS;\n&#x4E3A;&#x4EC0;&#x4E48;&#xFF0C;&#x6211;&#x4EEC;&#x4E0D;&#x662F;&#x5728; jump_to_application() &#x51FD;&#x6570;&#x4E2D;&#x6267;&#x884C;&#x8FC7;&#x4E00;&#x6B21;&#x4E86;&#x5417;&#x56E0;&#x4E3A;VTOR&#xFF08;Vector Table Offset Register&#xFF09;&#x662F;&#x4E00;&#x4E2A;&#x6613;&#x5931;&#x6027;&#x5BC4;&#x5B58;&#x5668;&#xFF0C;&#x8FD9;&#x610F;&#x5473;&#x7740;&#xFF1A;\n\n&#x590D;&#x4F4D;&#x4F1A;&#x6E05;&#x9664;VTOR&#xFF1A;&#x4EFB;&#x4F55;&#x5F62;&#x5F0F;&#x7684;&#x7CFB;&#x7EDF;&#x590D;&#x4F4D;&#xFF08;&#x5305;&#x62EC;&#x8F6F;&#x4EF6;&#x590D;&#x4F4D;&#xFF09;&#x90FD;&#x4F1A;&#x5C06;VTOR&#x91CD;&#x7F6E;&#x4E3A;&#x9ED8;&#x8BA4;&#x503C;&#xFF08;&#x901A;&#x5E38;&#x662F;0&#xFF09;\n&#x7535;&#x6E90;&#x5468;&#x671F;&#x4F1A;&#x6E05;&#x9664;VTOR&#xFF1A;&#x65AD;&#x7535;&#x518D;&#x4E0A;&#x7535;&#x4E5F;&#x4F1A;&#x91CD;&#x7F6E;VTOR\n&#x4E0D;&#x662F;&#x6C38;&#x4E45;&#x6027;&#x8BBE;&#x7F6E;&#xFF1A;VTOR&#x4E0D;&#x4F1A;&#x5728;&#x590D;&#x4F4D;&#x4E4B;&#x95F4;&#x4FDD;&#x6301;&#x5176;&#x503C;\n\nint main(void) {    /* USER CODE BEGIN 1 */    SCB-&gt;VTOR = APP_ADDRESS;    __enable_irq();    /* USER CODE END 1 *    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* Configure the system clock */    SystemClock_Config();    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    printf(&quot;test&quot;);    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        LED_Blink(&amp;LED, 100);        /* USER CODE BEGIN 3 */    }    /* USER CODE END 3 */}\n\n&#x8FDB;&#x5165;app&#x7A0B;&#x5E8F;&#x540E;&#xFF0C;led&#x706F;&#x5FEB;&#x95EA;&#xFF0C;&#x4E0E;boot&#x7684;&#x6162;&#x95EA;&#x5206;&#x5F00;\n&#x7F16;&#x8BD1;&#x94FE;&#x63A5;&#x6587;&#x4EF6;&#x4FEE;&#x6539;&#x5982;&#x679C;&#x4F60;&#x4F7F;&#x7528;&#x7684;&#x662F;armgcc&#x7F16;&#x8BD1;&#x94FE;&#xFF0C;&#x5E76;&#x4F7F;&#x7528;.ld&#x6587;&#x4EF6;&#x7EC4;&#x7EC7;&#x7F16;&#x8BD1;&#xFF0C;&#x5C31;&#x9700;&#x8981;&#x5728;cubemx&#x751F;&#x6210;&#x7684; STM32H750XX_FLASH.ld &#x6587;&#x4EF6;&#x4E2D;&#x4FEE;&#x6539;\n/* Specify the memory areas */MEMORY{DTCMRAM (xrw)      : ORIGIN = 0x20000000, LENGTH = 128KRAM (xrw)      : ORIGIN = 0x24000000, LENGTH = 512KRAM_D2 (xrw)      : ORIGIN = 0x30000000, LENGTH = 288KRAM_D3 (xrw)      : ORIGIN = 0x38000000, LENGTH = 64KITCMRAM (xrw)      : ORIGIN = 0x00000000, LENGTH = 64KFLASH (rx)      : ORIGIN = 0x08010000, LENGTH = 128K  //&#x91CD;&#x70B9;&#xFF0C;&#x4E0E;APP_ADDRESS&#x4FDD;&#x6301;&#x4E00;&#x81F4;&#xFF0C;&#x6CE8;&#x610F;ram&#x548C;flash&#x5927;&#x5C0F;}\n\nkeil&#x8BBE;&#x7F6E;&#x5982;&#x679C;&#x662F;keil&#xFF0C;&#x9B54;&#x672F;&#x68D2;-&gt;target &#x4E0B;&#x65B9;&#x6709;&#x8BBE;&#x7F6E;ROM&#x7684;&#x8D77;&#x59CB;&#x5730;&#x5740;&#xFF0C;&#x8BBE;&#x7F6E;&#x4E3A;APP_ADDRESS&#x7684;&#x503C;\n&#x70E7;&#x5F55;&#x5148;&#x70E7;&#x5F55;boot&#xFF0C;led&#x7F13;&#x6162;&#x95EA;&#x70C1;&#x5219;&#x8BF4;&#x660E;boot&#x8FD0;&#x884C;&#x6B63;&#x5E38;&#x518D;&#x70E7;&#x5F55;app&#xFF0C;led&#x5FEB;&#x95EA;&#x8BF4;&#x660E;app&#x8FD0;&#x884C;&#x6B63;&#x5E38;&#x590D;&#x4F4D;&#x4E00;&#x4E0B;&#xFF0C;led&#x5FEB;&#x95EA;\nopenocd&#x6CA1;&#x8BD5;&#x8FC7;&#xFF0C;&#x4F46;&#x662F;openocd&#x9ED8;&#x8BA4;&#x5168;&#x64E6;&#x9664;flash&#xFF0C;&#x9700;&#x8981;&#x4FEE;&#x6539;&#x8BBE;&#x7F6E;&#xFF0C;&#x4F7F;&#x4E4B;&#x53EA;&#x64E6;&#x9664;&#x5199;&#x5165;&#x7684;&#x7A7A;&#x95F4;\nSTM32Cubeprogrammer&#x5728;&#x4E0B;&#x8F7D;&#x65F6;&#xFF0C;&#x52FE;&#x9009;&#x5728;&#x7F16;&#x7A0B;&#x4E4B;&#x524D;&#x4E0D;&#x8FDB;&#x884C;&#x95EA;&#x5B58;&#x64E6;&#x9664;&#x3002;&#x70E7;&#x5F55;&#x540E;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x8BBE;&#x5907;&#x5185;&#x5B58;&#x67E5;&#x770B;&#x7684;&#x5DE5;&#x5177;&#x67E5;&#x770B;boot&#x7A0B;&#x5E8F;(&#x4F4D;&#x4E8E;0x0800 0000)&#x548C;app&#x7A0B;&#x5E8F;(0x0801 0000)&#x6709;&#x6CA1;&#x6709;&#x7A0B;&#x5E8F;&#x5199;&#x5165;\n&#x8865;&#x5145;\nled&#x9A71;&#x52A8;&#x968F;&#x4FBF;&#x5199;&#x4E00;&#x4E0B;&#x5C31;&#x884C;&#xFF0C;&#x95EA;&#x70C1;&#x7528;&#x5EF6;&#x8FDF;&#x51FD;&#x6570;\n&#x6211;&#x662F;armgcc&#x7F16;&#x8BD1;&#x94FE;&#xFF0C;&#x4F46;&#x662F;keil&#x5E94;&#x8BE5;&#x662F;&#x4E00;&#x6837;&#x7684;\n&#x4E00;&#x5B9A;&#x4E00;&#x5B9A;&#x8981;&#x8BB0;&#x4F4F;&#xFF0C;app&#x7F16;&#x8BD1;&#x65F6;&#x8981;&#x5148;&#x4FEE;&#x6539;flash&#x8D77;&#x59CB;&#x5730;&#x5740;\n\n&#x7A0B;&#x5E8F;&#x603B;&#x89C8;&#x901A;&#x8FC7;&#x7F16;&#x8BD1;&#x5F00;&#x5173;&#x6765;&#x63A7;&#x5236;&#x7F16;&#x8BD1;&#x51FA;&#x4EC0;&#x4E48;&#x7A0B;&#x5E8F;&#xFF0C;&#x65B9;&#x4FBF;&#x6D4B;&#x8BD5;\n/* USER CODE BEGIN Header *//** ****************************************************************************** * @file           : main.c * @brief          : Main program body ****************************************************************************** * @attention * * Copyright (c) 2025 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS-IS. * ****************************************************************************** *//* USER CODE END Header *//* Includes ------------------------------------------------------------------*/#include &quot;main.h&quot;#include &quot;gpio.h&quot;#include &quot;quadspi.h&quot;/* Private includes ----------------------------------------------------------*//* USER CODE BEGIN Includes */#include &quot;key_driver.h&quot;#include &quot;led_driver.h&quot;#include &lt;stdio.h&gt;/* USER CODE END Includes *//* Private typedef -----------------------------------------------------------*//* USER CODE BEGIN PTD *//* USER CODE END PTD *//* Private define ------------------------------------------------------------*//* USER CODE BEGIN PD */#define BOOT// #define APP#define APP_ADDRESS 0x08010000/* USER CODE END PD *//* Private macro -------------------------------------------------------------*//* USER CODE BEGIN PM */typedef void (*pFunction)(void);typedef struct {    uint32_t stack_ptr;    pFunction reset_handler;} VectorTable_t;/* USER CODE END PM *//* Private variables ---------------------------------------------------------*//* USER CODE BEGIN PV */LED_Device_t LED;KEY_Device_t K1;/* USER CODE END PV *//* Private function prototypes -----------------------------------------------*/void SystemClock_Config(void);static void MPU_Config(void);/* USER CODE BEGIN PFP */uint8_t is_application_valid(void);void jump_to_application(void);void bootloader_mode(void);/* USER CODE END PFP *//* Private user code ---------------------------------------------------------*//* USER CODE BEGIN 0 *//* USER CODE END 0 */#if defined(BOOT)// start:0x0800 0000 size:0x20000/** * @brief  The application entry point. * @retval int */int main(void) {    /* USER CODE BEGIN 1 */    /* USER CODE END 1 */    /* MPU     * Configuration--------------------------------------------------------*/    // MPU_Config();    /* MCU     * Configuration--------------------------------------------------------*/    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* USER CODE BEGIN Init */    /* USER CODE END Init */    /* Configure the system clock */    SystemClock_Config();    /* USER CODE BEGIN SysInit */    /* USER CODE END SysInit */    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    printf(&quot;test&quot;);    LED_On(&amp;LED);    if (is_application_valid()) {        jump_to_application();    } else {        bootloader_mode();    }    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        /* USER CODE BEGIN 3 */    }    /* USER CODE END 3 */}#endif#if defined(APP)// start:0x0801 0000 size:0x10000/** * @brief  The application entry point. * @retval int */int main(void) {    /* USER CODE BEGIN 1 */    SCB-&gt;VTOR = APP_ADDRESS;    __enable_irq();    /* USER CODE END 1 */    /* MPU     * Configuration--------------------------------------------------------*/    // MPU_Config();    /* MCU     * Configuration--------------------------------------------------------*/    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* USER CODE BEGIN Init */    /* USER CODE END Init */    /* Configure the system clock */    SystemClock_Config();    /* USER CODE BEGIN SysInit */    /* USER CODE END SysInit */    /* Initialize all configured peripherals */    MX_GPIO_Init();    MX_QUADSPI_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    printf(&quot;test&quot;);    /* USER CODE END 2 */    /* Infinite loop */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        LED_Blink(&amp;LED, 100);        /* USER CODE BEGIN 3 */    }    /* USER CODE END 3 */}#endif/** * @brief System Clock Configuration * @retval None */void SystemClock_Config(void) {    RCC_OscInitTypeDef RCC_OscInitStruct = {0};    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};    /** Supply configuration update enable     */    HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);    /** Configure the main internal regulator output voltage     */    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);    while (!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {    }    /** Initializes the RCC Oscillators according to the specified parameters     * in the RCC_OscInitTypeDef structure.     */    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;    RCC_OscInitStruct.HSEState = RCC_HSE_ON;    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;    RCC_OscInitStruct.PLL.PLLM = 5;    RCC_OscInitStruct.PLL.PLLN = 160;    RCC_OscInitStruct.PLL.PLLP = 2;    RCC_OscInitStruct.PLL.PLLQ = 2;    RCC_OscInitStruct.PLL.PLLR = 2;    RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;    RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;    RCC_OscInitStruct.PLL.PLLFRACN = 0;    if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) {        Error_Handler();    }    /** Initializes the CPU, AHB and APB buses clocks     */    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |                                  RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 |                                  RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1;    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;    RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;    RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;    RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;    RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;    RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;    if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) {        Error_Handler();    }}/* USER CODE BEGIN 4 */uint8_t is_application_valid(void) {    // RAM_size = 20000; // DTCMRAM    // FLASH_size = 20000;    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // check stack ptr is in valid addr scoop    // stm32 RAM usually start 0x2000 0000    if ((app_vector_table-&gt;stack_ptr &lt; 0x20000000) ||        (app_vector_table-&gt;stack_ptr &gt; 0x20020000)) {        return 0;    }    // check reset handle ptr is in valid addr scoop    uint32_t reset_handler = (uint32_t)app_vector_table-&gt;reset_handler;    if (reset_handler &lt; APP_ADDRESS ||        reset_handler &gt; FLASH_END) { /* &#x5FC5;&#x987B;&#x5728;&#x5E94;&#x7528;&#x7A0B;&#x5E8F; Flash &#x533A;&#x57DF;&#x5185; */        return 0;    }    // check irq table is 0 or 1 (esare state)    uint32_t *app_start = (uint32_t *)APP_ADDRESS;    for (int i = 0; i &lt; 16; i++) // check the first 16 word    {        if (app_start[i] != 0xFFFFFFFF &amp;&amp; app_start[i] != 0x00000000) {            // not empty data, app exit            // printf(&quot;Application validation passed\\r\\n&quot;);            return 1;        }    }    return 0;}void jump_to_application(void) {    const VectorTable_t *app_vector_table = (VectorTable_t *)APP_ADDRESS;    // disabel irq    __disable_irq();    // set top stack pointer    __set_MSP(app_vector_table-&gt;stack_ptr);    // set irq table offset    SCB-&gt;VTOR = APP_ADDRESS;    // jump to app reset handle programe    app_vector_table-&gt;reset_handler();    // if jump defeated, programe don&apos;t run to here    while (1)        ;}void bootloader_mode(void) {    // app addr is no programe    while (1) {        LED_Blink(&amp;LED, 1000);    }}/* USER CODE END 4 *//* MPU Configuration */void MPU_Config(void) {    MPU_Region_InitTypeDef MPU_InitStruct = {0};    /* Disables the MPU */    HAL_MPU_Disable();    /** Initializes and configures the Region and the memory to be protected     */    MPU_InitStruct.Enable = MPU_REGION_ENABLE;    MPU_InitStruct.Number = MPU_REGION_NUMBER0;    MPU_InitStruct.BaseAddress = 0x0;    MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;    MPU_InitStruct.SubRegionDisable = 0x87;    MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;    MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;    MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;    MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;    MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;    MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;    HAL_MPU_ConfigRegion(&amp;MPU_InitStruct);    /* Enables the MPU */    HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);}/** * @brief  This function is executed in case of error occurrence. * @retval None */void Error_Handler(void) {    /* USER CODE BEGIN Error_Handler_Debug */    /* User can add his own implementation to report the HAL error return state     */    __disable_irq();    while (1) {    }    /* USER CODE END Error_Handler_Debug */}#ifdef USE_FULL_ASSERT/** * @brief  Reports the name of the source file and the source line number *         where the assert_param error has occurred. * @param  file: pointer to the source file name * @param  line: assert_param error line source number * @retval None */void assert_failed(uint8_t *file, uint32_t line) {    /* USER CODE BEGIN 6 */    /* User can add his own implementation to report the file name and line       number, ex: printf(&quot;Wrong parameters value: file %s on line %d\\r\\n&quot;,       file, line) */    /* USER CODE END 6 */}#endif /* USE_FULL_ASSERT */\n","categories":["Bootloader"],"tags":["STM32","BootLoader"]},{"title":"åµŒå…¥å¼bootå¼€å‘ï¼ˆäºŒï¼‰","url":"/2025/10/28/%E5%B5%8C%E5%85%A5%E5%BC%8Fboot%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"&#x524D;&#x8A00;&#x5728;&#x4E0A;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;&#x5D4C;&#x5165;&#x5F0F;boot&#x5F00;&#x53D1;&#xFF08;&#x4E00;&#xFF09;&#x4E2D;&#x6211;&#x4EEC;&#x5B9E;&#x73B0;&#x4E86;&#x6700;&#x57FA;&#x7840;&#x7684;boot&#x8DF3;&#x8F6C;&#x529F;&#x80FD;&#xFF0C;&#x8FD9;&#x6B21;&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x72B6;&#x6001;&#x673A;&#x6765;&#x7BA1;&#x7406;boot&#x7684;&#x51E0;&#x79CD;&#x60C5;&#x51B5;\n&#x72B6;&#x6001;&#x673A;&#x72B6;&#x6001;&#x673A;&#x5C31;&#x662F;&#x6761;&#x4EF6;&#x8F6C;&#x79FB;&#xFF0C;&#x4E0D;&#x540C;&#x6761;&#x4EF6;&#x8FDB;&#x5165;&#x4E0D;&#x540C;&#x72B6;&#x6001;&#xFF0C;&#x6211;&#x4EEC;&#x5B9E;&#x73B0;&#x4E00;&#x4E2A;boot&#x7A0B;&#x5E8F;&#xFF1A;\n\n&#x4E0A;&#x7535;&#x65F6;&#x6309;&#x4F4F;K1&#x6309;&#x952E;&#x4E0D;&#x653E;3s&#x8FDB;&#x5165;boot&#xFF0C;&#x5426;&#x4FA7;3s&#x8D85;&#x65F6;&#x540E;&#x81EA;&#x52A8;&#x8DF3;&#x8F6C;&#x5230;app\n&#x518D;&#x6B21;&#x6309;&#x4E0B;&#x8DF3;&#x8F6C;&#x5230;app&#x601D;&#x8003;&#x4E00;&#x4E0B;&#x8FD9;&#x5176;&#x4E2D;&#x6709;&#x54EA;&#x4E9B;&#x72B6;&#x6001;&#x7684;&#x8F6C;&#x6362;&#xFF0C;&#x800C;&#x72B6;&#x6001;&#x8F6C;&#x6362;&#x53C8;&#x8981;&#x6EE1;&#x8DB3;&#x4EC0;&#x4E48;&#x6761;&#x4EF6;&#xFF0C;\n\n&#x72B6;&#x6001;&#x5236;&#x5B9A;&#x5BF9;&#x4E8E;&#x7B2C;&#x4E00;&#x4E2A;&#x529F;&#x80FD;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x7B49;&#x5F85;&#x6309;&#x952E;&#x7684;&#x72B6;&#x6001;&#xFF0C;&#x5982;&#x679C;&#x4E0A;&#x7535;3s&#x5185;(&#x53BB;&#x6296;)&#x6309;&#x4E0B;&#x5C31;&#x8FDB;&#x5165;bootloader&#x72B6;&#x6001;&#xFF0C;&#x5426;&#x4FA7;&#x8D85;&#x65F6;&#x8DF3;&#x8F6C;app&#x5BF9;&#x4E8E;&#x7B2C;&#x4E8C;&#x4E2A;&#x529F;&#x80FD;&#xFF0C;bootloader&#x72B6;&#x6001;&#x65F6;&#x6309;&#x4E0B;&#x6309;&#x952E;&#x8DF3;&#x8F6C;app&#x7531;&#x6B64;&#x53EF;&#x89C1;&#xFF0C;&#x6211;&#x4EEC;&#x6709;&#x4E09;&#x4E2A;&#x72B6;&#x6001;&#xFF1A;&#x7B49;&#x5F85;&#xFF0C;boot&#x72B6;&#x6001;&#xFF0C;&#x8DF3;&#x8F6C;app\ntypedef enum {    BOOTMODE_WAIT,          // &#x7B49;&#x5F85;    BOOTMODE_BOOTLOADER,    // bootloader&#x72B6;&#x6001;    BOOTMODE_APP_JUMP       // &#x8DF3;&#x8F6C;app} BootMode_t;\n&#x8DF3;&#x8F6C;&#x6761;&#x4EF6;&#x4E0E;&#x72B6;&#x6001;&#x673A;&#x5B9E;&#x73B0;&#x5BF9;&#x4E8E;&#x7B2C;&#x4E00;&#x4E2A;&#x529F;&#x80FD;&#xFF0C;&#x8F6C;&#x6362;&#x6761;&#x4EF6;&#x662F;&#x6309;&#x952E;&#x5728;&#x4E0A;&#x7535;&#x65F6;&#x662F;&#x5426;&#x6309;&#x4E0B;&#x5BF9;&#x4E8E;&#x7B2C;&#x4E8C;&#x4E2A;&#x529F;&#x80FD;&#xFF0C;&#x8F6C;&#x6362;&#x6761;&#x4EF6;&#x662F;&#x6309;&#x952E;&#x662F;&#x5426;&#x6309;&#x4E0B;\n&#x6240;&#x4EE5;&#x7F16;&#x5199;&#x5982;&#x4E0B;&#x4EE3;&#x7801;&#xFF0C;&#x4F7F;&#x7528;switch-case&#x8BED;&#x53E5;&#x4EE5;&#x53CA;&#x65B9;&#x4FBF;&#x68C0;&#x67E5;\n#define BOOT_WAIT_TIME 3000                         //3000msBootMode_t BootMode = BOOTMODE_WAIT;                //&#x521D;&#x59CB;&#x72B6;&#x6001;\n\nswitch (BootMode) {case BOOTMODE_WAIT:    if (HAL_GetTick() &gt; BOOT_WAIT_TIME) {           //&#x68C0;&#x67E5;&#x65F6;&#x95F4;3s        BootMode = BOOTMODE_APP_JUMP;               //&#x8D85;&#x65F6;&#x8FDB;&#x5165;&#x8DF3;&#x8F6C;app&#x72B6;&#x6001;    } else if (KEY_GetState(&amp;K1) == KEY_State_DOWN) {   //&#x6309;&#x952E;&#x6309;&#x4E0B;        BootMode = BOOTMODE_BOOTLOADER;                 //&#x8FDB;&#x5165;bootloader&#x72B6;&#x6001;    }    break;case BOOTMODE_BOOTLOADER:                           if (KEY_GetState(&amp;K1) == KEY_State_DOWN) {      //&#x6309;&#x952E;&#x6309;&#x4E0B;        BootMode = BOOTMODE_APP_JUMP;               //&#x8FDB;&#x5165;&#x8DF3;&#x8F6C;app&#x72B6;&#x6001;    } else {        bootloader_mode();    }    break;case BOOTMODE_APP_JUMP:    if (is_application_valid()) {        jump_to_application();    } else {        BootMode = BOOTMODE_BOOTLOADER;    }    break;default:    BootMode = BOOTMODE_BOOTLOADER;    break;}\n\n&#x6CE8;&#xFF1A;&#x5728;&#x4E00;&#x4E2A;&#x5FAA;&#x73AF;&#x4E2D;&#x8FD0;&#x884C;&#x6B64;&#x72B6;&#x6001;&#x673A;\n\nbootloader_mode()&#x76F8;&#x8F83;&#x4E8E;&#x4E0A;&#x4E00;&#x7BC7;&#x6709;&#x4E00;&#x70B9;&#x53D8;&#x52A8;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x4E3A;&#x4E86;&#x5C55;&#x793A;bootloader&#x72B6;&#x6001;\nvoid bootloader_mode(void) {    // app addr is no programe    LED_Blink(&amp;LED, 1000);}\njump_to_application()&#x4E5F;&#x6709;&#x6240;&#x8C03;&#x6574;&#xFF0C;&#x5728;&#x53C2;&#x8003;&#x4E86;&#x5B89;&#x5BCC;&#x83B1;&#x7684;boot&#x6559;&#x7A0B;&#x540E;\nvoid jump_to_application()(void) {    const VectorTableType *app_vector_table =        (VectorTableType *)APP_ADDRESS;    // &#x7981;&#x7528;irq&#x4E2D;&#x65AD;&#xFF0C;&#x4EC5;&#x5173;&#x95ED;IRQ&#xFF08;&#x666E;&#x901A;&#x4E2D;&#x65AD;&#xFF09;&#xFF0C;&#x4F46;&#x4E0D;&#x5173;&#x95ED;FIQ&#xFF08;&#x5FEB;&#x901F;&#x4E2D;&#x65AD;&#xFF09;    __disable_irq();    // &#x7981;&#x7528;&#x5168;&#x90E8;&#x4E2D;&#x65AD;    __set_PRIMASK(1);    // &#x590D;&#x4F4D;&#x6240;&#x6709;&#x65F6;&#x949F;&#x5230;&#x9ED8;&#x8BA4;    HAL_RCC_DeInit();    // &#x590D;&#x4F4D;&#x6240;&#x7528;&#x5230;&#x7684;&#x5916;&#x8BBE;    // HAL_XX_DeInit();    // &#x5173;&#x95ED;systick&#xFF0C;&#x590D;&#x4F4D;&#x5230;&#x9ED8;&#x8BA4;&#x503C;    SysTick-&gt;CTRL = 0;    SysTick-&gt;LOAD = 0;    SysTick-&gt;VAL = 0;    // &#x5173;&#x95ED;&#x6240;&#x6709;&#x4E2D;&#x65AD;&#xFF0C;&#x6E05;&#x9664;&#x6240;&#x6709;&#x4E2D;&#x65AD;&#x6302;&#x8D77;&#x6807;&#x5FD7;    for (uint32_t i = 0; i &lt; 8; i++) {        NVIC-&gt;ICER[i] = 0xFFFFFFFF;        NVIC-&gt;ICPR[i] = 0xFFFFFFFF;    }    // &#x8BBE;&#x7F6E;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x504F;&#x79FB;    SCB-&gt;VTOR = APP_ADDRESS;    // &#x8BBE;&#x7F6E;&#x4E3B;&#x6808;&#x6307;&#x9488;    __set_MSP(app_vector_table-&gt;stack_pointer);    // &#x4F7F;&#x7528;RTOS&#x65F6;&#xFF0C;&#x8FD9;&#x53E5;&#x5F88;&#x91CD;&#x8981;&#xFF0C;&#x8BBE;&#x7F6E;&#x4E3A;&#x7279;&#x6743;&#x7EA7;&#x6A21;&#x5F0F;&#xFF0C;&#x4F7F;&#x7528;MSP&#x6307;&#x9488;    __set_CONTROL(0);    // &#x5728;&#x8DF3;&#x8F6C;&#x524D;&#x5F00;&#x542F;&#x5168;&#x5C40;&#x4E2D;&#x65AD;&#xFF0C;&#x8BA9;APP&#x53EF;&#x4EE5;&#x54CD;&#x5E94;&#x4E2D;&#x65AD;    __set_PRIMASK(0);    __enable_irq();    // &#x8DF3;&#x8F6C;&#x5230;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x590D;&#x4F4D;&#x5904;&#x7406;&#x51FD;&#x6570;    app_vector_table-&gt;reset_handler();    // &#x5982;&#x679C;&#x8DF3;&#x8F6C;&#x6210;&#x529F;&#xFF0C;&#x7A0B;&#x5E8F;&#x4E0D;&#x4F1A;&#x8FD0;&#x884C;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x7528;&#x6237;&#x53EF;&#x4EE5;&#x5728;&#x8FD9;&#x91CC;&#x6DFB;&#x52A0;&#x5904;&#x7406;&#x4EE3;&#x7801;    while (1)        ;}\n\n&#x70E7;&#x5F55;&#x4E0A;&#x7535;app&#x7A0B;&#x5E8F;&#x4E0D;&#x53D8;&#xFF0C;&#x4E0A;&#x7535;&#x65F6;&#x6309;&#x4F4F;K1&#x6309;&#x952E;&#x5F85;LED&#x7F13;&#x6162;&#x95EA;&#x70C1;&#x65F6;&#x8BF4;&#x660E;&#x8FDB;&#x5165;&#x4E86;boot&#xFF0C;&#x6B64;&#x65F6;&#x518D;&#x6309;&#x4E0B;K1&#x8FDB;&#x5165;app(&#x5982;&#x6709;)LED&#x5FEB;&#x95EA;\n&#x540E;&#x7EED;&#x66F4;&#x65B0;&#x8DDD;&#x79BB;&#x7B2C;&#x4E00;&#x7BC7;&#x65F6;&#x9694;&#x56DB;&#x5341;&#x5929;&#xFF0C;&#x8FD9;&#x56DB;&#x5341;&#x5929;&#x4E3B;&#x8981;&#x662F;&#x5B66;&#x4E60;C#&#x548C;WPF&#x6765;&#x5F00;&#x53D1;&#x914D;&#x5957;&#x7684;boot&#x4E0A;&#x4F4D;&#x673A;boot&#x4E0A;&#x4F4D;&#x673A;&#x5305;&#x542B;&#x5E38;&#x89C1;&#x7684;&#x4E32;&#x53E3;&#x529F;&#x80FD;&#x548C;boot&#x6A21;&#x5F0F;&#x3002;&#x4E0A;&#x4F4D;&#x673A;&#x6CA1;&#x6709;&#x505A;&#x5B8C;&#x4E3B;&#x8981;&#x662F;&#x540E;&#x9762;&#x7684;&#x8981;&#x548C;MCU&#x540C;&#x6B65;&#x5F00;&#x53D1;&#x6765;&#x6D4B;&#x8BD5;&#x529F;&#x80FD;&#x4E0B;&#x4E00;&#x7BC7;&#x4F1A;&#x4ECB;&#x7ECD;boot&#x7684;&#x547D;&#x4EE4;&#x5E27;&#x7ED3;&#x6784;&#x4EE5;&#x53CA;&#x4E0B;&#x4F4D;&#x673A;&#x63A5;&#x6536;&#x76F8;&#x5173;&#x7A0B;&#x5E8F;&#x7684;&#x7F16;&#x5199;\n&#x4EE3;&#x7801;&#x4E00;&#x89C8;\nboot&#x7684;mainint main(void) {    /* USER CODE BEGIN 1 */    /* USER CODE END 1 */    /* MPU     * Configuration--------------------------------------------------------*/    MPU_Config();    /* MCU     * Configuration--------------------------------------------------------*/    /* Reset of all peripherals, Initializes the Flash interface and the     * Systick. */    HAL_Init();    /* USER CODE BEGIN Init */    /* USER CODE END Init */    /* Configure the system clock */    SystemClock_Config();    /* USER CODE BEGIN SysInit */    /* USER CODE END SysInit */    /* Initialize all configured peripherals */    MX_GPIO_Init();    // MX_QUADSPI_Init();    MX_CRC_Init();    /* USER CODE BEGIN 2 */    LED_InitDev(&amp;LED, LED_GPIO_Port, LED_Pin, 1);    KEY_InitDev(&amp;K1, K1_GPIO_Port, K1_Pin, 1);    /* USER CODE END 2 */    /* Infinite loop */    /* &#x4E3B;&#x8981;&#x4FEE;&#x6539;&#x70B9; */    /* USER CODE BEGIN WHILE */    while (1) {        /* USER CODE END WHILE */        /* USER CODE BEGIN 3 */        switch (BootMode) {        case BOOTMODE_WAIT:            if (HAL_GetTick() &gt; BOOT_WAIT_TIME) {                BootMode = BOOTMODE_APP_JUMP;            } else if (KEY_GetState(&amp;K1) == KEY_State_DOWN) {                BootMode = BOOTMODE_BOOTLOADER;            }            break;        case BOOTMODE_BOOTLOADER:            if (KEY_GetState(&amp;K1) == KEY_State_DOWN) {                BootMode = BOOTMODE_APP_JUMP;            } else {                bootloader_mode();            }            break;        case BOOTMODE_APP_JUMP:            if (is_application_valid()) {                jump_to_application();            } else {                BootMode = BOOTMODE_BOOTLOADER;            }            break;        default:            BootMode = BOOTMODE_BOOTLOADER;            break;        }    }    /* USER CODE END 3 */}\n&#x4EE5;&#x53CA;bootloader_mode()void bootloader_mode(void) {    // app addr is no programe    LED_Blink(&amp;LED, 1000);}\n\n","categories":["Bootloader"],"tags":["STM32","BootLoader"]},{"title":"åµŒå…¥å¼bootå¼€å‘ï¼ˆä¸‰ï¼‰","url":"/2025/11/08/%E5%B5%8C%E5%85%A5%E5%BC%8Fboot%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89/","content":"&#x524D;&#x8A00;&#x5728;&#x4E0A;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;&#x5D4C;&#x5165;&#x5F0F;boot&#x5F00;&#x53D1;&#xFF08;&#x4E8C;&#xFF09;&#x4E2D;&#x6211;&#x4EEC;&#x5B9E;&#x73B0;&#x4E86;boot&#x72B6;&#x6001;&#x673A;&#x5E76;&#x5BF9;&#x4E00;&#x4E9B;&#x51FD;&#x6570;&#x8FDB;&#x884C;&#x4F18;&#x5316;&#xFF0C;&#x8FD9;&#x4E2A;&#x7AE0;&#x8282;&#x5C31;&#x6765;&#x8BBE;&#x8BA1;&#x4E00;&#x4E2A;&#x4E0A;&#x4F4D;&#x673A;&#x4E0E;boot&#x901A;&#x4FE1;&#x7684;&#x901A;&#x4FE1;&#x534F;&#x8BAE;&#x3002;\n&#x60F3;&#x4E00;&#x4E0B;&#x5982;&#x679C;&#x5728;&#x6211;&#x4EEC;&#x8BBE;&#x8BA1;&#x6700;&#x7B80;&#x5355;&#x7684;boot&#x65F6;&#xFF0C;&#x4E00;&#x4E2A;boot&#x7A0B;&#x5E8F;&#x4E3B;&#x8981;&#x6709;&#x4E24;&#x4E2A;&#x529F;&#x80FD;&#xFF1A;\n\n&#x53EF;&#x7531;&#x5916;&#x90E8;&#x4FE1;&#x53F7;&#x9009;&#x62E9;&#x6765;&#x8FDB;&#x5165;bootloader&#x6A21;&#x5F0F;\n&#x8DF3;&#x8F6C;app&#x7684;&#x529F;&#x80FD;&#x5982;&#x679C;&#x60F3;&#x8981;boot&#x5177;&#x6709;&#x66F4;&#x65B0;&#x56FA;&#x4EF6;&#x7684;&#x80FD;&#x529B;&#xFF0C;&#x5219;&#x9700;&#x8981;boot&#x80FD;&#x591F;&#x8BFB;&#x53D6;&#x5E76;&#x5199;&#x5165;&#x56FA;&#x4EF6;&#xFF0C;&#x6240;&#x4EE5;&#x8FD8;&#x8981;&#x4E00;&#x4E2A;&#x529F;&#x80FD;&#x5C31;&#x662F;&#x4E0A;&#x4F20;&#x56FA;&#x4EF6;\n\n&#x901A;&#x4FE1;&#x6570;&#x636E;&#x7EA6;&#x5B9A;&#x4E3A;&#x4E86;&#x53EF;&#x9760;&#x4F20;&#x8F93;&#xFF0C;&#x6211;&#x9009;&#x62E9;&#x4F7F;&#x7528;&#x534A;&#x53CC;&#x5DE5;&#x901A;&#x4FE1;&#xFF0C;&#x4E0B;&#x4F4D;&#x673A;(MCU&#x4E00;&#x4E0B;&#x7EDF;&#x79F0;&#x4E0B;&#x4F4D;&#x673A;)&#x88AB;&#x52A8;&#x7684;&#x63A5;&#x6536;&#x4E0A;&#x4F4D;&#x673A;&#x6307;&#x4EE4;&#xFF0C;&#x540C;&#x65F6;&#x4F7F;&#x7528;&#x81EA;&#x5B9A;&#x4E49;&#x547D;&#x4EE4;&#x5E27;&#x6765;&#x589E;&#x5F3A;&#x4F20;&#x8F93;&#x53EF;&#x9760;&#x6027;\n&#x547D;&#x4EE4;&#x5E27;&#x547D;&#x4EE4;&#x5E27;&#x7ED3;&#x6784;&#x4E3A;: [0xAA] [0x55] [&#x547D;&#x4EE4;&#x5B57;(1byte)] [&#x6570;&#x636E;&#x957F;&#x5EA6;(&#x5C0F;&#x7AEF;&#x5E8F; 2byte)] [&#x6570;&#x636E;] [&#x5E27;&#x6821;&#x9A8C;&#x6570;&#x636E;(2byte)]\n\n0xAA&#x548C;0x55&#x4E3A;&#x5E27;&#x5934;\n\n&#x547D;&#x4EE4;&#x5B57;\n\n\n\n&#x547D;&#x4EE4;&#x540D;\n&#x529F;&#x80FD;\n&#x547D;&#x4EE4;&#x5B57;\n\n\n\nEnterBoot\n&#x8FDB;&#x5165;boot&#x6A21;&#x5F0F;\n0x01\n\n\nUpload\n&#x4E0A;&#x4F20;&#x56FA;&#x4EF6;\n0x02\n\n\nVerify\n&#x9A8C;&#x8BC1;&#x56FA;&#x4EF6;\n0x03\n\n\nRunApp\n&#x8FD0;&#x884C;app\n0x04\n\n\nAck\n&#x80AF;&#x5B9A;&#x5E94;&#x7B54;\n0x05\n\n\nNack\n&#x5426;&#x5B9A;&#x5E94;&#x7B54;\n0x06\n\n\nErrorResponse\n&#x9519;&#x8BEF;&#x54CD;&#x5E94;\n0x07\n\n\n\n&#x6570;&#x636E;&#x957F;&#x5EA6;&#x91C7;&#x7528;&#x5C0F;&#x7AEF;&#x5E8F;&#xFF0C;&#x65B9;&#x4FBF;&#x4E0B;&#x4F4D;&#x673A;&#x89E3;&#x6790;\n\n&#x6570;&#x636E;&#xFF0C;&#x4EFB;&#x610F;&#x957F;&#x5EA6;\n\n&#x5E27;&#x6821;&#x9A8C;&#x6570;&#x636E;&#xFF0C;&#x4ECE;&#x547D;&#x4EE4;&#x5B57;&#x5230;&#x6570;&#x636E;&#x7ED3;&#x675F;&#x7684;&#x7D2F;&#x52A0;&#x548C;&#x53D6;&#x53CD;\n\n\n\n// &#x547D;&#x4EE4;&#x5E27;&#x6570;&#x636E;&#x957F;&#x5EA6;&#x5927;&#x5C0F;#define FRAME_DATA_SIZE 2048// &#x547D;&#x4EE4;&#x5E27;&#x7ED3;&#x6784;typedef struct {    command_type_t command;    // &#x4E0A;&#x4F4D;&#x673A;&#x4F20;&#x6765;&#x7684;&#x957F;&#x5EA6;&#x4E3A;&#x5C0F;&#x7AEF;&#x5E8F;&#x7EC4;&#x6210;&#x7684;&#x4E24;&#x5B57;&#x8282;&#x6570;&#x636E;&#xFF0C;&#x6240;&#x4EE5;&#x5148;&#x6536;&#x5230;&#x4F4E;&#x5B57;&#x8282;&#xFF0C;&#x518D;&#x6536;&#x9AD8;&#x5B57;&#x8282;    uint16_t data_length;    uint8_t data[FRAME_DATA_SIZE];    uint8_t checksum;} command_frame_t;\n\n&#x56FA;&#x4EF6;&#x5305;&#x56FA;&#x4EF6;&#x901A;&#x5E38;&#x90FD;&#x662F;&#x5341;&#x51E0;&#x6216;&#x8005;&#x51E0;&#x5341;KB&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x91CC;&#x91C7;&#x53D6;&#x5206;&#x5305;&#x4F20;&#x8F93;&#x7684;&#x7B56;&#x7565;&#xFF0C;&#x5C06;&#x4E00;&#x4E2A;&#x56FA;&#x4EF6;&#x6309;&#x7167;&#x9884;&#x5148;&#x8BBE;&#x5B9A;&#x7684;&#x5305;&#x5927;&#x5C0F;&#x8FDB;&#x884C;&#x62C6;&#x5206;&#xFF1B;&#x6BD4;&#x5982;&#x4E00;&#x4E2A;19KB&#x7684;&#x56FA;&#x4EF6;&#xFF0C;&#x6309;&#x7167;1KB&#x7684;&#x5305;&#x5927;&#x5C0F;&#x62C6;&#x5206;&#x6210;19&#x4E2A;&#x5305;&#x3002;&#x5728;&#x4E0A;&#x4F4D;&#x673A;&#x5411;&#x4E0B;&#x4F4D;&#x673A;&#x4F20;&#x6570;&#x636E;&#x5305;&#x65F6;&#xFF0C;&#x4E3A;&#x4E86;&#x9632;&#x6B62;&#x6570;&#x636E;&#x5305;&#x5728;&#x4F20;&#x8F93;&#x8FC7;&#x7A0B;&#x4E2D;&#x56E0;&#x4E3A;&#x79CD;&#x79CD;&#x53EF;&#x80FD;&#x7684;&#x5E72;&#x6270;&#x5BFC;&#x81F4;&#x62A5;&#x6570;&#x636E;&#x51FA;&#x9519;&#xFF0C;&#x8FD9;&#x91CC;&#x91C7;&#x7528;CRC32&#x6821;&#x9A8C;&#x6765;&#x7528;&#x4E8E;&#x4E0B;&#x4F4D;&#x673A;&#x786E;&#x8BA4;&#x5305;&#x5B8C;&#x6574;&#x6027;&#x56E0;&#x6B64;&#x4E00;&#x4E2A;&#x5305;&#x6570;&#x636E;&#x7684;&#x6784;&#x6210;&#x4E3A;: [&#x5F53;&#x524D;&#x5305;&#x53F7;] [&#x603B;&#x5305;&#x53F7;] [&#x5305;&#x6570;&#x636E;(&#x5047;&#x8BBE;&#x4E3A;1KB)] [&#x5305;&#x6570;&#x636E;&#x7684;CRC32]\n\n&#x6CE8;&#xFF1A;&#x4E3A;&#x4E86;&#x4E0E;CRC32&#x957F;&#x5EA6;&#x76F8;&#x540C;&#xFF0C;&#x5904;&#x7406;&#x5305;&#x6570;&#x636E;&#x5176;&#x4ED6;&#x90FD;&#x662F;4byte&#x7684;&#x5927;&#x7AEF;&#x6570;&#x636E;\n\n&#x4E0A;&#x4F4D;&#x673A;&#x53D1;&#x9001;&#x4E3A;&#x4E86;&#x914D;&#x5957;&#x4F7F;&#x7528;&#xFF0C;&#x6211;&#x5199;&#x4E86;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x4E0A;&#x4F4D;&#x673A;&#x5E76;&#x5F00;&#x6E90;&#x5728;github&#xFF0C;&#x7531;&#x4E8E;&#x662F;&#x8FB9;&#x5B66;c#&#x8FB9;&#x5199;&#x7684;&#xFF0C;&#x5176;&#x4E2D;&#x8FD8;&#x5145;&#x65A5;&#x4E86;&#x5927;&#x91CF;ai&#x751F;&#x6210;&#x4EE3;&#x7801;&#xFF0C;&#x6BD4;&#x8F83;&#x4E11;&#x964B;&#xFF0C;&#x671B;&#x4E0D;&#x541D;&#x8D50;&#x6559;&#x6B64;&#x4E0A;&#x4F4D;&#x673A;&#x76EE;&#x524D;&#x5B9E;&#x73B0;&#x4E86;&#xFF1A;\n\n&#x57FA;&#x7840;&#x4E32;&#x53E3;&#x901A;&#x4FE1;:\n&#x81EA;&#x52A8;&#x53D1;&#x9001;\n&#x4FDD;&#x5B58;&#x63A5;&#x6536;&#x4E3A;txt\n&#x6536;&#x53D1;&#x65B9;&#x6807;&#x8BB0;\n\n\nboot&#x6A21;&#x5F0F;:\n&#x53D1;&#x9001;&#x547D;&#x4EE4;&#xFF0C;&#x542B;&#x4F20;&#x8F93;&#x5C42;&#x8D85;&#x65F6;&#x91CD;&#x53D1;&#x548C;&#x8C03;&#x5EA6;&#x5C42;&#x8FFD;&#x52A0;&#x91CD;&#x53D1;\n&#x8BFB;&#x53D6;&#x56FA;&#x4EF6;&#x5E76;&#x81EA;&#x52A8;&#x5206;&#x5305;&#x8BA1;&#x7B97;CRC32\n&#x6D4B;&#x8BD5;&#x6309;&#x94AE;&#xFF0C;&#x7528;&#x4E8E;&#x6D4B;&#x8BD5;&#x540E;&#x9762;&#x4F1A;&#x4E13;&#x95E8;&#x5199;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;&#x6765;&#x4ECB;&#x7ECD;&#x6B64;&#x4E0A;&#x4F4D;&#x673A;\n\n\n\n&#x4E0B;&#x4F4D;&#x673A;&#x63A5;&#x6536;&#x4E0A;&#x4F4D;&#x673A;&#x53EA;&#x662F;&#x6DFB;&#x5934;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x4E0B;&#x4F4D;&#x673A;&#x7684;&#x63A5;&#x6536;&#x8BE5;&#x600E;&#x4E48;&#x5199;&#x3002;&#x8FD9;&#x91CC;&#x8FD8;&#x662F;&#x4F7F;&#x7528;&#x72B6;&#x6001;&#x673A;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;\n&#x72B6;&#x6001;&#x5236;&#x5B9A;&#x601D;&#x8003;&#x4E00;&#x4E0B;&#x547D;&#x4EE4;&#x5E27;&#xFF0C;&#x4E00;&#x5171;&#x6709;&#x4E94;&#x4E2A;&#x90E8;&#x5206;&#x7EC4;&#x6210;: &#x5E27;&#x5934;&#xFF0C;&#x547D;&#x4EE4;&#x5B57;&#xFF0C;&#x6570;&#x636E;&#x957F;&#x5EA6;&#xFF0C;&#x6570;&#x636E;&#x548C;&#x6821;&#x9A8C;&#x3002;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#x5F53;&#x6211;&#x4EEC;&#x63A5;&#x6536;&#x5B57;&#x8282;&#x6570;&#x636E;&#x65F6;&#x5C31;&#x662F;&#x56F4;&#x7ED5;&#x7740;&#x8FD9;&#x51E0;&#x4E2A;&#x72B6;&#x6001;\n// &#x63A5;&#x6536;&#x72B6;&#x6001;&#x673A;typedef enum {    RX_STATE_IDLE,    RX_STATE_HEADER1,    RX_STATE_HEADER2,    RX_STATE_CMD,    RX_STATE_LEN_LOW,    RX_STATE_LEN_HIGH,    RX_STATE_DATA,    RX_STATE_CHECKSUM} rx_state_t;\n\n&#x4F46;&#x662F;&#x8FD9;&#x91CC;&#x6211;&#x628A;&#x5B83;&#x518D;&#x7EC6;&#x5206;&#x4E86;&#x4E00;&#x4E0B;&#xFF0C;&#x5C06;&#x5E27;&#x5934;&#x62C6;&#x4E3A;&#x4E24;&#x6B21;&#xFF0C;&#x6570;&#x636E;&#x957F;&#x5EA6;&#x4E5F;&#x62C6;&#x5F00;&#xFF0C;&#x8FD9;&#x4E3B;&#x8981;&#x662F;&#x4E3A;&#x4E86;&#x914D;&#x5408;&#x6309;&#x5B57;&#x8282;&#x63A5;&#x6536;\n&#x72B6;&#x6001;&#x8F6C;&#x6362;&#x8BA9;&#x6211;&#x4EEC;&#x4E00;&#x8D77;&#x5206;&#x6790;&#x4E00;&#x4E0B;&#x63A5;&#x6536;&#x6D41;&#x7A0B;&#xFF1A;\n\nRX_STATE_HEADER1 &#xFF1A;&#x5047;&#x8BBE;&#x5148;&#x6536;&#x5230;0xAA&#xFF0C;&#x72B6;&#x6001;&#x7531; RX_STATE_HEADER1 -&gt; RX_STATE_HEADER2 &#xFF1B;&#x5426;&#x4FA7;&#x72B6;&#x6001;&#x56DE;&#x5230; RX_STATE_HEADER1 &#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#x5E27;&#x5934;\n\nRX_STATE_HEADER2 &#xFF1A;&#x6536;&#x5230;0x55&#xFF0C;&#x8BF4;&#x660E;&#x5E27;&#x5934;&#x63A5;&#x6536;&#x5B8C;&#x4E86;&#xFF0C;&#x72B6;&#x6001;&#x7531; RX_STATE_HEADER2 -&gt; RX_STATE_CMD &#xFF1B;&#x5426;&#x4FA7;&#x72B6;&#x6001;&#x56DE;&#x5230; RX_STATE_HEADER1 &#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#x5E27;&#x5934;\n\nRX_STATE_CMD &#xFF1A; &#x68C0;&#x6D4B;&#x63A5;&#x6536;&#x7684;&#x5B57;&#x8282;&#x6570;&#x636E;&#x662F;&#x5426;&#x5728;&#x547D;&#x4EE4;&#x5B57;&#x679A;&#x4E3E;&#x8303;&#x56F4;&#x5185;&#xFF0C;&#x547D;&#x4EE4;&#x5B57;&#x5408;&#x6CD5;&#x5219;&#x8FDB;&#x5165;&#x4E0B;&#x4E00;&#x72B6;&#x6001; RX_STATE_LEN_LOW &#xFF1B;&#x5426;&#x4FA7;&#x72B6;&#x6001;&#x56DE;&#x5230; RX_STATE_HEADER1 &#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#x5E27;&#x5934;\n\nRX_STATE_LEN_LOW &#xFF1A;&#x63A5;&#x6536;&#x957F;&#x5EA6;&#x6570;&#x636E;&#x7684;&#x4F4E;&#x4F4D;&#xFF0C;&#x7136;&#x540E;&#x8FDB;&#x5165; RX_STATE_LEN_HIGH\n\nRX_STATE_LEN_HIGH &#xFF1A;&#x63A5;&#x6536;&#x957F;&#x5EA6;&#x6570;&#x636E;&#x7684;&#x9AD8;&#x4F4D;&#xFF0C;&#x8FD9;&#x65F6;&#x5019;&#x4F1A;&#x6709;&#x5206;&#x652F;&#xFF0C;&#x5982;&#x679C;&#x957F;&#x5EA6;&#x4E3A;&#x96F6;&#x5219;&#x76F4;&#x63A5;&#x8FDB;&#x5165; RX_STATE_CHECKSUM &#xFF0C;&#x4E0D;&#x4E3A;&#x96F6;&#x4E14;&#x5C0F;&#x4E8E;&#x6570;&#x636E;&#x7F13;&#x51B2;&#x533A;&#x957F;&#x5EA6;&#x5219;&#x8FDB;&#x5165; RX_STATE_DATA ; &#x5426;&#x4FA7;&#x72B6;&#x6001;&#x56DE;&#x5230; RX_STATE_HEADER1 &#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#x5E27;&#x5934;\n\nRX_STATE_DATA &#xFF1A;&#x63A5;&#x6536;&#x6570;&#x636E;&#xFF0C;&#x5185;&#x7F6E;&#x8BA1;&#x6570;&#x5668;&#xFF0C;&#x5F53;&#x63A5;&#x6536;&#x6570;&#x636E;&#x4E0D;&#x7B49;&#x4E8E;&#x957F;&#x5EA6;&#x65F6;&#x8BF4;&#x660E;&#x63A5;&#x6536;&#x6570;&#x636E;&#x672A;&#x6EE1;&#xFF0C;&#x5FAA;&#x73AF; RX_STATE_DATA &#xFF0C;&#x76F4;&#x5230;&#x63A5;&#x6536;&#x6570;&#x636E;&#x7B49;&#x4E8E;&#x957F;&#x5EA6;&#x8F6C;&#x5230; RX_STATE_CHECKSUM\n\nRX_STATE_CHECKSUM &#xFF1A;&#x6821;&#x9A8C;&#x6570;&#x636E;&#xFF0C;&#x9664;&#x4E86;&#x5E27;&#x5934;&#x4E0D;&#x52A0;&#xFF0C;&#x5176;&#x4ED6;&#x7D2F;&#x8BA1;&#x548C;&#x53D6;&#x53CD;&#x5E76;&#x4E8E;&#x63A5;&#x53D7;&#x7684;&#x6821;&#x9A8C;&#x6570;&#x636E;&#x6BD4;&#x8F83;&#xFF0C;&#x76F8;&#x5BF9;&#x8BF4;&#x660E;&#x672C;&#x6B21;&#x547D;&#x4EE4;&#x5E27;&#x63A5;&#x6536;&#x6210;&#x529F;&#xFF1B;&#x5426;&#x4FA7;&#x72B6;&#x6001;&#x56DE;&#x5230; RX_STATE_HEADER1 &#x7EE7;&#x7EED;&#x7B49;&#x5F85;&#x5E27;&#x5934;&#x5982;&#x4E0B;&#x56FE;&#x6240;&#x793A;\n\n\n\n&#x4EE5;&#x4E0B;&#x4E3A;&#x4EE3;&#x7801;&#x5B9E;&#x73B0;\nparse_result_t command_process_byte(uint8_t byte) {    parse_result_t ret;    switch (rx_state) {    case RX_STATE_HEADER1:        if (byte == FRAME_HEADER1) {            rx_state = RX_STATE_HEADER2;        } else {            rx_state = RX_STATE_HEADER1;        }        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_HEADER2:        if (byte == FRAME_HEADER2) {            rx_state = RX_STATE_CMD;        } else {            rx_state = RX_STATE_HEADER1;            return PARSE_ERROR_HEADER;        }        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_CMD:        if (is_valid_command((command_type_t)byte)) {            current_frame.command = (command_type_t)byte;            rx_state = RX_STATE_LEN_LOW;            ret = PARSE_INCOMPLETE;        } else {            rx_state = RX_STATE_HEADER1;            ret = PARSE_ERROR_INVALID_CMD;        }        break;    case RX_STATE_LEN_LOW:        current_frame.data_length = byte;        rx_state = RX_STATE_LEN_HIGH;        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_LEN_HIGH:        data_recived_size = 0;        current_frame.data_length |= (byte &lt;&lt; 8);        if (current_frame.data_length == 0) {            rx_state = RX_STATE_CHECKSUM;            ret = PARSE_INCOMPLETE;        } else if (current_frame.data_length &lt; FRAME_SIZE) {            rx_state = RX_STATE_DATA;            ret = PARSE_INCOMPLETE;        } else {            rx_state = RX_STATE_HEADER1;            ret = PARSE_ERROR_LENGTH;        }        break;    case RX_STATE_DATA:        current_frame.data[data_recived_size++] = byte;        if (data_recived_size == current_frame.data_length) {            rx_state = RX_STATE_CHECKSUM;        }        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_CHECKSUM:        current_frame.checksum = byte;        uint8_t checksum;        uint16_t header_size =            sizeof(current_frame.command) + sizeof(current_frame.data_length);        checksum = calculate_checksum((uint8_t *)&amp;current_frame.command,                                      header_size + current_frame.data_length);        if (checksum == current_frame.checksum) {            frame_ready = true;            ret = PARSE_SUCCESS;        } else {            ret = PARSE_ERROR_CHECKSUM;        }        rx_state = RX_STATE_HEADER1;        break;    default:        rx_state = RX_STATE_HEADER1;        ret = PARSE_INCOMPLETE;        break;    }    return ret;}\n\n&#x5C01;&#x88C5;&#x5E76;&#x5206;&#x5C42;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;boot&#x663E;&#x7136;&#x4E0D;&#x9002;&#x5408;&#x518D;&#x5728;main&#x4E2D;&#x7F16;&#x5199;&#x4E86;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5C06;&#x5176;&#x72EC;&#x7ACB;&#x51FA;&#x6765;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x6A21;&#x5757;&#x5B58;&#x5728;&#x3002;&#x6682;&#x65F6;&#x5C06;&#x5176;&#x5206;&#x4E3A;boot&#x5C42;&#x548C;boot_cmd&#x5C42;\n\nboot_cmd&#x5C42;&#xFF1A;&#x53EA;&#x8D1F;&#x8D23;&#x89E3;&#x6790;&#x547D;&#x4EE4;&#x5E27;&#x548C;&#x6784;&#x5EFA;&#x547D;&#x4EE4;&#x5E27;\nboot&#x5C42;&#xFF1A;&#x8D1F;&#x8D23;&#x5C01;&#x88C5;&#x5E76;&#x66B4;&#x9732; boot_cmd &#x4E2D;&#x7684;&#x63A5;&#x53E3;&#xFF0C;&#x4EE5;&#x53CA;&#x4E00;&#x4E9B;&#x4E0E;boot&#x5F3A;&#x76F8;&#x5173;&#x7684;&#x51FD;&#x6570;&#xFF0C;&#x4F8B;&#x5982;boot&#x72B6;&#x6001;&#x673A;&#xFF0C;app&#x8DF3;&#x8F6C;&#x7B49;\n\nboot&#x5C42;&#x5728;boot&#x547D;&#x4EE4;&#x5E27;&#x89E3;&#x6790;&#x7684;&#x4EE3;&#x7801;&#x5B9E;&#x73B0;&#x4E2D;&#xFF0C;&#x6BCF;&#x6B21;&#x72B6;&#x6001;&#x673A;&#x8C03;&#x7528;&#x540E;&#x90FD;&#x4F1A;&#x6709;&#x8FD4;&#x56DE;&#x503C;&#xFF0C;&#x8FD9;&#x662F;&#x4E0E;&#x547D;&#x4EE4;&#x5E27;&#x89E3;&#x6790;&#x914D;&#x5957;&#x7684;&#x89E3;&#x6790;&#x7ED3;&#x679C;\n// &#x89E3;&#x6790;&#x7ED3;&#x679C;typedef enum {    PARSE_SUCCESS,    PARSE_ERROR_HEADER,    PARSE_ERROR_INVALID_CMD,    PARSE_ERROR_LENGTH,    PARSE_ERROR_CHECKSUM,    PARSE_INCOMPLETE} parse_result_t\n\n&#x72B6;&#x6001;&#x673A;&#x5728;&#x8FD0;&#x884C;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x51FA;&#x73B0;&#x4E86;&#x89E3;&#x6790;&#x9519;&#x8BEF;&#xFF0C;&#x867D;&#x7136;&#x4F1A;&#x81EA;&#x52A8;&#x8DF3;&#x8F6C;&#x5230; RX_STATE_HEADER1 &#x7B49;&#x5F85;&#x5E27;&#x5934;&#xFF0C;&#x4F46;&#x662F;&#x8C03;&#x7528;&#x8005;&#x9700;&#x8981;&#x6301;&#x7EED;&#x8FFD;&#x8E2A;&#x89E3;&#x6790;&#x4E2D;&#x51FA;&#x73B0;&#x7684;&#x9519;&#x8BEF;&#x5E76;&#x7ED9;&#x51FA;&#x5BF9;&#x4E8E;&#x89E3;&#x51B3;&#x65B9;&#x6CD5;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x9519;&#x8BEF;&#x8FFD;&#x8E2A;&#x3002;&#x6240;&#x4EE5;&#x5728;&#x72B6;&#x6001;&#x673A;&#x4E2D;&#x5F15;&#x5165;&#x8FD4;&#x56DE;&#x503C;&#x6765;&#x8BA9;boot&#x5C42;&#x77E5;&#x9053;&#x89E3;&#x6790;&#x7684;&#x8FD0;&#x884C;&#x72B6;&#x6001;&#xFF0C;&#x5B9E;&#x73B0;&#xFF1A;\nvoid Boot_ReceiveCommand(uint8_t received_byte) {    // &#x547D;&#x4EE4;&#x63A5;&#x6536;&#x5904;&#x7406;&#x5B9E;&#x73B0;    command_parse_result = command_process_byte(received_byte);    switch (command_parse_result) {    case PARSE_SUCCESS:        if (command_get_frame(&amp;current_frame)) {            is_recived = true;            bootErrorCode = ERROR_CODE_NO_ERROR;        }        break;    case PARSE_ERROR_HEADER:        bootErrorCode = ERROR_CODE_PARSE_FAILED;        is_recived = false;        break;    case PARSE_ERROR_INVALID_CMD:        bootErrorCode = ERROR_CODE_UNKNOWN_CMD;        is_recived = false;        break;    case PARSE_ERROR_LENGTH:        bootErrorCode = ERROR_CODE_PARSE_FAILED;        is_recived = false;        break;    case PARSE_ERROR_CHECKSUM:        bootErrorCode = ERROR_CODE_PARSE_FAILED;        is_recived = false;        break;    case PARSE_INCOMPLETE:        // &#x6B63;&#x5E38;&#x72B6;&#x6001;&#xFF0C;&#x4E0D;&#x505A;&#x5904;&#x7406;        break;    default:        bootErrorCode = ERROR_CODE_NO_ERROR;        is_recived = false;        break;    }}\n\n&#x5728;boot&#x5C42;&#x4E2D;&#x6709;&#x79C1;&#x6709;&#x53D8;&#x91CF; bootErrorCode &#x6765;&#x6355;&#x83B7;&#x9519;&#x8BEF;&#x5E76;&#x5904;&#x7406;&#x3002;&#x800C; Boot_ReceiveCommand &#x51FD;&#x6570;&#x653E;&#x5728;&#x4E32;&#x53E3;&#x63A5;&#x6536;&#x4E2D;&#x65AD;&#x56DE;&#x8C03;&#x4F7F;&#x7528;&#xFF0C;&#x6216;&#x8005;&#x865A;&#x62DF;&#x4E32;&#x53E3;&#x63A5;&#x6536;&#x51FD;&#x6570;&#x4E2D;&#x81EA;&#x884C;&#x6309;&#x5B57;&#x8282;&#x62C6;&#x5305;&#x540E;&#x5FAA;&#x73AF;&#x4F20;&#x5165;&#x90FD;&#x53EF;&#x4EE5;&#x4F8B;&#x5982;&#xFF1A;\n//&#x865A;&#x62DF;&#x4E32;&#x53E3;&#x63A5;&#x6536;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#xFF0C;&#x8FD9;&#x662F;&#x6309;&#x6570;&#x636E;&#x5305;&#x63A5;&#x53D7;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x5728;&#x5176;&#x4E2D;&#x6309;&#x5B57;&#x8282;&#x62C6;&#x5206;&#x518D;&#x5FAA;&#x73AF;&#x63A5;&#x6536;static int8_t CDC_Receive_FS(uint8_t *Buf, uint32_t *Len) {    /* USER CODE BEGIN 6 */    USBD_CDC_SetRxBuffer(&amp;hUsbDeviceFS, &amp;Buf[0]);    USBD_CDC_ReceivePacket(&amp;hUsbDeviceFS);    // &#x6309;&#x5B57;&#x8282;&#x63A5;&#x6536;    for (uint32_t i = 0; i &lt; *Len; i++) {        Boot_ReceiveCommand(Buf[i]);    }    return (USBD_OK);    /* USER CODE END 6 */}\n\n&#x6E90;&#x7801;//boot.h#ifndef _BOOT_H_#define _BOOT_H_#include &quot;boot_cmd.h&quot;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#ifdef __cplusplusextern &quot;C&quot; {#endif// &#x4E0A;&#x7535;BOOT&#x7B49;&#x5F85;&#x65F6;&#x95F4;&#xFF0C;&#x8D85;&#x65F6;&#x8FDB;&#x5165;app(&#x5982;&#x6709;)#define BOOT_WAIT_TIME_MS 2000#define APPLICATION_START_ADDRESS 0x08010000#define FLASH_END_ADDRESS 0x080FFFFF// &#x51FD;&#x6570;&#x6307;&#x9488;&#xFF0C;&#x7528;&#x4E8E;&#x590D;&#x4F4D;&#x51FD;&#x6570;&#x5B9E;&#x4F8B;&#x5316;typedef void (*FunctionPointer)(void);typedef struct {    uint32_t stack_pointer;    FunctionPointer reset_handler;} VectorTableType;// boot&#x72B6;&#x6001;&#x673A;typedef enum {    BOOT_STATE_WAIT,    BOOT_STATE_BOOTLOADER,    BOOT_STATE_APPLICATION_JUMP,} BootState_t;// &#x9519;&#x8BEF;&#x7801;&#x5B9A;&#x4E49;typedef enum {    ERROR_CODE_NO_ERROR = 0x00,    ERROR_CODE_PARSE_FAILED = 0x01,    ERROR_CODE_UNKNOWN_CMD = 0x02,    ERROR_CODE_INVALID_DATA = 0x03,    ERROR_CODE_FLASH_ERROR = 0x04,    ERROR_CODE_VERIFY_FAILED = 0x05,    ERROR_CODE_NUMS} BootErrorCode_t;// typedef union {//     /* data */// };/** * @brief &#x83B7;&#x53D6;&#x9519;&#x8BEF;&#x4FE1;&#x606F; * @param errorCode &#x9519;&#x8BEF;&#x7801; * @return &#x9519;&#x8BEF;&#x4FE1;&#x606F;&#x5B57;&#x7B26;&#x4E32; */const char *GetErrorMessage(BootErrorCode_t errorCode);// &#x6570;&#x636E;&#x53D1;&#x9001;&#x51FD;&#x6570;&#x6307;&#x9488;&#x7C7B;&#x578B;typedef bool (*Boot_SendData_Func)(uint8_t *data, uint16_t length);/** * @brief Boot&#x6A21;&#x5757;&#x521D;&#x59CB;&#x5316; * @param send_func &#x6570;&#x636E;&#x53D1;&#x9001;&#x51FD;&#x6570;&#x6307;&#x9488; */void Boot_Init(Boot_SendData_Func send_func);/** * @brief boot&#x72B6;&#x6001;&#x673A; */void Boot_ProcessStateMachine(void);/** * @brief &#x9A8C;&#x8BC1;&#x56FA;&#x4EF6;&#x662F;&#x5426;&#x5408;&#x6CD5; * @return 0&#x4E0D;&#x5408;&#x6CD5; 1&#x5408;&#x6CD5; */uint8_t Boot_IsApplicationValid(void);/** * @brief &#x8DF3;&#x8F6C;&#x5230;&#x56FA;&#x4EF6; */void Boot_JumpToApplication(void);/** * @brief &#x8FDB;&#x5165;BootLoader&#x6A21;&#x5F0F;&#xFF0C;&#x89E3;&#x6790;&#x6765;&#x81EA;&#x4E0A;&#x4F4D;&#x673A;&#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x8FDB;&#x884C;&#x56FA;&#x4EF6;&#x5347;&#x7EA7;&#x7B49;&#x64CD;&#x4F5C; * @return BootState_t &#x8FD4;&#x56DE;boot&#x72B6;&#x6001;&#xFF0C;&#x7528;&#x4E8E;&#x8DF3;&#x8F6C;app */BootState_t Boot_EnterBootloaderMode(void);/** * @brief &#x5904;&#x7406;&#x63A5;&#x6536;&#x6570;&#x636E;&#x3002;&#x5728;&#x6570;&#x636E;&#x63A5;&#x6536;&#x56DE;&#x8C03;&#x51FD;&#x6570;&#x4E2D;&#x8C03;&#x7528; * @param received_byte &#x6309;&#x5B57;&#x8282;&#x5904;&#x7406; */void Boot_ReceiveCommand(uint8_t received_byte);/*&#x66B4;&#x9732;&#x63A5;&#x53E3;&#x7528;&#x6765;&#x6D4B;&#x8BD5;*/uint8_t Boot_ProcessUploadCommand(command_frame_t *frame);#ifdef __cplusplus}#endif#endif\n\n&#x76F8;&#x8F83;&#x4E8E;&#x4E0A;&#x4E00;&#x7BC7;&#x6587;&#x7AE0;&#x6709;&#x51FD;&#x6570;&#x540D;&#x4E0A;&#x7684;&#x4FEE;&#x6539;\n//boot.c#include &quot;boot.h&quot;#include &quot;boot_cmd.h&quot;#include &quot;key_driver.h&quot;#include &quot;led_driver.h&quot;#include &lt;string.h&gt;extern KEY_Device_t K1;extern LED_Device_t LED;static BootState_t current_boot_state = BOOT_STATE_WAIT;static parse_result_t command_parse_result;static command_frame_t current_frame;static volatile bool is_recived = false;static volatile BootErrorCode_t bootErrorCode = ERROR_CODE_NO_ERROR;static volatile bool is_run_app = false;// &#x53D1;&#x9001;&#x51FD;&#x6570;&#x6307;&#x9488;static Boot_SendData_Func boot_send_func = NULL;// Boot&#x521D;&#x59CB;&#x5316;&#x72B6;&#x6001;static bool boot_initialized = false;// &#x9519;&#x8BEF;&#x4FE1;&#x606F;const char *ErrorMessage[ERROR_CODE_NUMS] = {    &quot;No error&quot;,              // 0x00    &quot;Command parse failed&quot;,  // 0x01    &quot;Unknown command&quot;,       // 0x02    &quot;Invalid data format&quot;,   // 0x03    &quot;Flash operation error&quot;, // 0x04    &quot;Verification failed&quot;    // 0x05};// &#x9759;&#x6001;&#x51FD;&#x6570;&#x58F0;&#x660E;static void Boot_ProcessReceivedCommand(void);static bool Boot_SendFrame(command_type_t cmd, uint8_t *data,                           uint16_t data_len);static void Boot_SendAckResponse(void);static void Boot_SendErrorResponse(BootErrorCode_t errorCode);const char *GetErrorMessage(BootErrorCode_t errorCode) {    if (errorCode &gt;= ERROR_CODE_NUMS) {        return &quot;Unknown error code&quot;;    }    return ErrorMessage[errorCode];}void Boot_Init(Boot_SendData_Func send_func) {    if (boot_initialized) {        return; // &#x907F;&#x514D;&#x91CD;&#x590D;&#x521D;&#x59CB;&#x5316;    }    // &#x521D;&#x59CB;&#x5316;&#x547D;&#x4EE4;&#x89E3;&#x6790;&#x5668;    command_parser_init();    // &#x8BBE;&#x7F6E;&#x53D1;&#x9001;&#x51FD;&#x6570;    boot_send_func = send_func;    // &#x521D;&#x59CB;&#x5316;&#x72B6;&#x6001;&#x673A;    current_boot_state = BOOT_STATE_WAIT;    is_recived = false;    bootErrorCode = ERROR_CODE_NO_ERROR;    is_run_app = false;    boot_initialized = true;}// boot&#x72B6;&#x6001;&#x673A;&#x53CA;&#x4E0D;&#x540C;&#x72B6;&#x6001;&#x7684;&#x5904;&#x7406;&#x51FD;&#x6570;void Boot_ProcessStateMachine(void) {    if (!boot_initialized) {        return;    }    switch (current_boot_state) {    case BOOT_STATE_WAIT:        if (HAL_GetTick() &gt; BOOT_WAIT_TIME_MS) {            current_boot_state = BOOT_STATE_APPLICATION_JUMP;        } else if (KEY_GetState(&amp;K1) == KEY_State_DOWN) {            current_boot_state = BOOT_STATE_BOOTLOADER;            const char enter_boot_str[] = &quot;Enter BootLoader Mode\\n&quot;;            boot_send_func((uint8_t *)enter_boot_str, strlen(enter_boot_str));        }        break;    case BOOT_STATE_BOOTLOADER:        BootState_t bootloader_result = Boot_EnterBootloaderMode();        if (bootloader_result == BOOT_STATE_APPLICATION_JUMP) {            const char jump_to_app_str[] = &quot;Jump To APP\\n&quot;;            boot_send_func((uint8_t *)jump_to_app_str, strlen(jump_to_app_str));            current_boot_state = BOOT_STATE_APPLICATION_JUMP;        }        break;    case BOOT_STATE_APPLICATION_JUMP:        if (Boot_IsApplicationValid()) {            Boot_JumpToApplication();        } else {            current_boot_state = BOOT_STATE_BOOTLOADER;            const char enter_boot_str[] = &quot;Enter BootLoader Mode\\n&quot;;            boot_send_func((uint8_t *)enter_boot_str, strlen(enter_boot_str));        }        break;    default:        current_boot_state = BOOT_STATE_BOOTLOADER;        break;    }}uint8_t Boot_IsApplicationValid(void) {    const VectorTableType *app_vector_table =        (VectorTableType *)APPLICATION_START_ADDRESS;    // &#x68C0;&#x67E5;&#x6808;&#x6307;&#x9488;&#x662F;&#x5426;&#x5728;&#x6709;&#x6548;&#x5730;&#x5740;&#x8303;&#x56F4;&#x5185;    if ((app_vector_table-&gt;stack_pointer &lt; 0x20000000) ||        (app_vector_table-&gt;stack_pointer &gt; 0x20020000)) {        return 0;    }    // &#x68C0;&#x67E5;&#x590D;&#x4F4D;&#x5904;&#x7406;&#x51FD;&#x6570;&#x6307;&#x9488;&#x662F;&#x5426;&#x5728;&#x6709;&#x6548;&#x5730;&#x5740;&#x8303;&#x56F4;&#x5185;    uint32_t reset_handler_address = (uint32_t)app_vector_table-&gt;reset_handler;    if (reset_handler_address &lt; APPLICATION_START_ADDRESS ||        reset_handler_address &gt; FLASH_END_ADDRESS) {        return 0;    }    // &#x68C0;&#x67E5;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x662F;&#x5426;&#x5305;&#x542B;&#x6709;&#x6548;&#x6570;&#x636E;    uint32_t *app_start_address = (uint32_t *)APPLICATION_START_ADDRESS;    for (int i = 0; i &lt; 16; i++) {        if (app_start_address[i] != 0xFFFFFFFF &amp;&amp;            app_start_address[i] != 0x00000000) {            return 1;        }    }    return 0;}void Boot_JumpToApplication(void) {    const VectorTableType *app_vector_table =        (VectorTableType *)APPLICATION_START_ADDRESS;    // &#x7981;&#x7528;irq&#x4E2D;&#x65AD;&#xFF0C;&#x4EC5;&#x5173;&#x95ED;IRQ&#xFF08;&#x666E;&#x901A;&#x4E2D;&#x65AD;&#xFF09;&#xFF0C;&#x4F46;&#x4E0D;&#x5173;&#x95ED;FIQ&#xFF08;&#x5FEB;&#x901F;&#x4E2D;&#x65AD;&#xFF09;    __disable_irq();    // &#x7981;&#x7528;&#x5168;&#x90E8;&#x4E2D;&#x65AD;    __set_PRIMASK(1);    // &#x590D;&#x4F4D;&#x6240;&#x6709;&#x65F6;&#x949F;&#x5230;&#x9ED8;&#x8BA4;    HAL_RCC_DeInit();    KEY_DeInitDev(&amp;K1);    LED_DeInitDev(&amp;LED);    // &#x5173;&#x95ED;systick&#xFF0C;&#x590D;&#x4F4D;&#x5230;&#x9ED8;&#x8BA4;&#x503C;    SysTick-&gt;CTRL = 0;    SysTick-&gt;LOAD = 0;    SysTick-&gt;VAL = 0;    // &#x5173;&#x95ED;&#x6240;&#x6709;&#x4E2D;&#x65AD;&#xFF0C;&#x6E05;&#x9664;&#x6240;&#x6709;&#x4E2D;&#x65AD;&#x6302;&#x8D77;&#x6807;&#x5FD7;    for (uint32_t i = 0; i &lt; 8; i++) {        NVIC-&gt;ICER[i] = 0xFFFFFFFF;        NVIC-&gt;ICPR[i] = 0xFFFFFFFF;    }    // &#x8BBE;&#x7F6E;&#x4E2D;&#x65AD;&#x5411;&#x91CF;&#x8868;&#x504F;&#x79FB;    SCB-&gt;VTOR = APPLICATION_START_ADDRESS;    // &#x8BBE;&#x7F6E;&#x4E3B;&#x6808;&#x6307;&#x9488;    __set_MSP(app_vector_table-&gt;stack_pointer);    // &#x4F7F;&#x7528;RTOS&#x65F6;&#xFF0C;&#x8FD9;&#x53E5;&#x5F88;&#x91CD;&#x8981;&#xFF0C;&#x8BBE;&#x7F6E;&#x4E3A;&#x7279;&#x6743;&#x7EA7;&#x6A21;&#x5F0F;&#xFF0C;&#x4F7F;&#x7528;MSP&#x6307;&#x9488;    __set_CONTROL(0);    // &#x5728;&#x8DF3;&#x8F6C;&#x524D;&#x5F00;&#x542F;&#x5168;&#x5C40;&#x4E2D;&#x65AD;&#xFF0C;&#x8BA9;APP&#x53EF;&#x4EE5;&#x54CD;&#x5E94;&#x4E2D;&#x65AD;    __set_PRIMASK(0);    __enable_irq();    // &#x8DF3;&#x8F6C;&#x5230;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x590D;&#x4F4D;&#x5904;&#x7406;&#x51FD;&#x6570;    app_vector_table-&gt;reset_handler();    // &#x5982;&#x679C;&#x8DF3;&#x8F6C;&#x6210;&#x529F;&#xFF0C;&#x7A0B;&#x5E8F;&#x4E0D;&#x4F1A;&#x8FD0;&#x884C;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x7528;&#x6237;&#x53EF;&#x4EE5;&#x5728;&#x8FD9;&#x91CC;&#x6DFB;&#x52A0;&#x5904;&#x7406;&#x4EE3;&#x7801;    while (1)        ;}BootState_t Boot_EnterBootloaderMode(void) {    // Bootloader&#x6A21;&#x5F0F;&#x5B9E;&#x73B0;    LED_Blink(&amp;LED, 1000);    if (is_recived &amp;&amp; bootErrorCode == ERROR_CODE_NO_ERROR) {        // &#x547D;&#x4EE4;&#x5904;&#x7406;&#x72B6;&#x6001;&#x673A;        is_recived = false; // &#x7ACB;&#x5373;&#x91CD;&#x7F6E;        Boot_ProcessReceivedCommand();        if (is_run_app) {            is_run_app = false;            return BOOT_STATE_APPLICATION_JUMP;        }    } else if (bootErrorCode != ERROR_CODE_NO_ERROR) {        // &#x7ED9;&#x4E0A;&#x4F4D;&#x673A;&#x53D1;&#x9001;&#x9519;&#x8BEF;&#x6D88;&#x606F;&#xFF0C;&#x5229;&#x7528;command_build_frame&#x6253;&#x5305;&#xFF0C;        // &#x547D;&#x4EE4;&#x5B57;&#x4E3A;CMD_ERROR_RESPONSE &#x6570;&#x636E;&#x4E3A;&#x9519;&#x8BEF;&#x4FE1;&#x606F;&#x8868;        // &#x5199;&#x4E00;&#x4E2A;&#x9519;&#x8BEF;&#x4FE1;&#x606F;&#x8868;&#x7528;&#x6765;&#x6839;&#x636E;&#x9519;&#x8BEF;&#x53F7;&#x7ED9;&#x4E0A;&#x4F4D;&#x673A;&#x53CD;&#x9988;&#x9519;&#x8BEF;&#x4FE1;&#x606F;        Boot_SendErrorResponse(bootErrorCode);        bootErrorCode = ERROR_CODE_NO_ERROR; // &#x91CD;&#x7F6E;&#x9519;&#x8BEF;&#x7801;    }    if (KEY_GetState(&amp;K1) == KEY_State_DOWN) {        return BOOT_STATE_APPLICATION_JUMP;    }    return BOOT_STATE_BOOTLOADER;}/** * @brief &#x5904;&#x7406;&#x63A5;&#x6536;&#x5230;&#x7684;&#x547D;&#x4EE4; */static void Boot_ProcessReceivedCommand(void) {    switch (current_frame.command) {    case CMD_ENTER_BOOT:        // &#x5DF2;&#x7ECF;&#x8FDB;&#x5165;Bootloader&#xFF0C;&#x53D1;&#x9001;&#x786E;&#x8BA4;        Boot_SendAckResponse();        break;    case CMD_UPLOAD:        // &#x5904;&#x7406;&#x56FA;&#x4EF6;&#x4E0A;&#x4F20;        Boot_ProcessUploadCommand(&amp;current_frame);        Boot_SendAckResponse(); // &#x6682;&#x65F6;&#x53EA;&#x56DE;&#x590D;ACK        break;    case CMD_VERIFY:        // &#x5904;&#x7406;&#x9A8C;&#x8BC1;&#x547D;&#x4EE4;        // Boot_ProcessVerifyCommand(&amp;current_frame);        Boot_SendAckResponse(); // &#x6682;&#x65F6;&#x53EA;&#x56DE;&#x590D;ACK        break;    case CMD_RUN_APP:        // &#x6536;&#x5230;&#x8DF3;&#x8F6C;APP&#x547D;&#x4EE4;        Boot_SendAckResponse();        // &#x8BBE;&#x7F6E;&#x6807;&#x5FD7;&#xFF0C;&#x8BA9;&#x72B6;&#x6001;&#x673A;&#x5728;&#x4E0B;&#x4E2A;&#x5FAA;&#x73AF;&#x8DF3;&#x8F6C;        is_run_app = true;        break;    case CMD_ACK:        // &#x6536;&#x5230;ACK&#x6D4B;&#x8BD5;&#x547D;&#x4EE4;        Boot_SendAckResponse();        break;    default:        Boot_SendErrorResponse(ERROR_CODE_UNKNOWN_CMD);        break;    }}/** * @brief &#x5904;&#x7406;&#x56FA;&#x4EF6;&#x5347;&#x7EA7;&#x6307;&#x4EE4; * @param frame &#x547D;&#x4EE4;&#x5E27; * @return 1&#x6210;&#x529F;&#xFF0C;0&#x5931;&#x8D25; */uint8_t Boot_ProcessUploadCommand(command_frame_t *frame) {    uint8_t *firmware;    static uint8_t total_packet;    static uint8_t num_packet;}/** * @brief &#x53D1;&#x9001;&#x547D;&#x4EE4;&#x5E27; */static bool Boot_SendFrame(command_type_t cmd, uint8_t *data,                           uint16_t data_len) {    uint8_t tx_buffer[FRAME_SIZE];    uint16_t frame_len = command_build_frame(cmd, data, data_len, tx_buffer);    return boot_send_func(tx_buffer, frame_len);}/** * @brief &#x53D1;&#x9001;ACK&#x54CD;&#x5E94; */static void Boot_SendAckResponse(void) { Boot_SendFrame(CMD_ACK, NULL, 0); }/** * @brief &#x53D1;&#x9001;&#x9519;&#x8BEF;&#x54CD;&#x5E94; */static void Boot_SendErrorResponse(BootErrorCode_t errorCode) {    const char *error_msg = GetErrorMessage(errorCode);    uint16_t error_msg_len = strlen(error_msg);    Boot_SendFrame(CMD_ERROR_RESPONSE, (uint8_t *)error_msg, error_msg_len);}void Boot_ReceiveCommand(uint8_t received_byte) {    // &#x547D;&#x4EE4;&#x63A5;&#x6536;&#x5904;&#x7406;&#x5B9E;&#x73B0;    command_parse_result = command_process_byte(received_byte);    switch (command_parse_result) {    case PARSE_SUCCESS:        if (command_get_frame(&amp;current_frame)) {            is_recived = true;            bootErrorCode = ERROR_CODE_NO_ERROR;        }        break;    case PARSE_ERROR_HEADER:        bootErrorCode = ERROR_CODE_PARSE_FAILED;        is_recived = false;        break;    case PARSE_ERROR_INVALID_CMD:        bootErrorCode = ERROR_CODE_UNKNOWN_CMD;        is_recived = false;        break;    case PARSE_ERROR_LENGTH:        bootErrorCode = ERROR_CODE_PARSE_FAILED;        is_recived = false;        break;    case PARSE_ERROR_CHECKSUM:        bootErrorCode = ERROR_CODE_PARSE_FAILED;        is_recived = false;        break;    case PARSE_INCOMPLETE:        // &#x6B63;&#x5E38;&#x72B6;&#x6001;&#xFF0C;&#x4E0D;&#x505A;&#x5904;&#x7406;        break;    default:        bootErrorCode = ERROR_CODE_NO_ERROR;        is_recived = false;        break;    }}\n\nboot_cmd&#x5C42;&#x57FA;&#x672C;&#x90FD;&#x5728;boot&#x547D;&#x4EE4;&#x5E27;&#x89E3;&#x6790;&#x4EE5;&#x4E0B;&#x662F;&#x6E90;&#x7801;&#xFF1A;\n//boot_cmd.h#ifndef _BOOT_CMD_H_#define _BOOT_CMD_H_#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#ifdef __cplusplusextern &quot;C&quot; {#endif// &#x547D;&#x4EE4;&#x7C7B;&#x578B;&#x5B9A;&#x4E49;typedef enum {    CMD_VALID_START,    CMD_ENTER_BOOT = 0x01,    CMD_UPLOAD = 0x02,    CMD_VERIFY = 0x03,    CMD_RUN_APP = 0x04,    CMD_ACK = 0x05,    CMD_NACK = 0x06,    CMD_ERROR_RESPONSE = 0x07,    CMD_VALID_END} command_type_t;// &#x5E27;&#x5934;&#x5B9A;&#x4E49;#define FRAME_HEADER1 0xAA#define FRAME_HEADER2 0x55// &#x547D;&#x4EE4;&#x5E27;&#x6570;&#x636E;&#x957F;&#x5EA6;&#x5927;&#x5C0F;#define FRAME_DATA_SIZE 2048#define FRAME_SIZE (FRAME_DATA_SIZE + 128)// &#x547D;&#x4EE4;&#x5E27;&#x7ED3;&#x6784;typedef struct {    command_type_t command;    // &#x4E0A;&#x4F4D;&#x673A;&#x4F20;&#x6765;&#x7684;&#x957F;&#x5EA6;&#x4E3A;&#x5C0F;&#x7AEF;&#x5E8F;&#x7EC4;&#x6210;&#x7684;&#x4E24;&#x5B57;&#x8282;&#x6570;&#x636E;&#xFF0C;&#x6240;&#x4EE5;&#x5148;&#x6536;&#x5230;&#x4F4E;&#x5B57;&#x8282;&#xFF0C;&#x518D;&#x6536;&#x9AD8;&#x5B57;&#x8282;    uint16_t data_length;    uint8_t data[FRAME_DATA_SIZE];    uint8_t checksum;} command_frame_t;// &#x89E3;&#x6790;&#x7ED3;&#x679C;typedef enum {    PARSE_SUCCESS,    PARSE_ERROR_HEADER,    PARSE_ERROR_INVALID_CMD,    PARSE_ERROR_LENGTH,    PARSE_ERROR_CHECKSUM,    PARSE_INCOMPLETE} parse_result_t;// &#x63A5;&#x6536;&#x72B6;&#x6001;&#x673A;typedef enum {    RX_STATE_IDLE,    RX_STATE_HEADER1,    RX_STATE_HEADER2,    RX_STATE_CMD,    RX_STATE_LEN_LOW,    RX_STATE_LEN_HIGH,    RX_STATE_DATA,    RX_STATE_CHECKSUM} rx_state_t;/** * @brief &#x521D;&#x59CB;&#x5316;&#x89E3;&#x6790;&#x5668; */void command_parser_init(void);/** * @brief &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x63A5;&#x6536;&#x72B6;&#x6001;&#x7684;&#x63A5;&#x53E3; * @return &#x8FD4;&#x56DE;&#x5F53;&#x524D;&#x63A5;&#x6536;&#x72B6;&#x6001; */rx_state_t get_rx_state();/** * @brief &#x6309;&#x5B57;&#x8282;&#x63A5;&#x6536;&#x5E76;&#x89E3;&#x6790;&#x547D;&#x4EE4;&#x5E27; * @param byte &#x5B57;&#x8282;&#x6570;&#x636E; * @return parse_result_t &#x89E3;&#x6790;&#x7ED3;&#x679C; */parse_result_t command_process_byte(uint8_t byte);/** * @brief &#x83B7;&#x53D6;&#x5F53;&#x524D;&#x547D;&#x4EE4;&#x5E27; * @param frame &#x7A7A;&#x547D;&#x4EE4;&#x5E27;&#x7C7B;&#x578B; * @return true &#x83B7;&#x53D6;&#x6210;&#x529F;&#xFF0C;&#x547D;&#x4EE4;&#x5E27;&#x8FD8;&#x6CA1;&#x6709;&#x51C6;&#x5907;&#x597D; * @return false &#x83B7;&#x53D6;&#x5931;&#x8D25; */bool command_get_frame(command_frame_t *frame);/** * @brief &#x6784;&#x5EFA;&#x547D;&#x4EE4;&#x5E27; * @param cmd &#x547D;&#x4EE4;&#x5B57; * @param data &#x6570;&#x636E; * @param data_len &#x6570;&#x636E;&#x957F;&#x5EA6; * @param output_buffer &#x8F93;&#x51FA;&#x7F13;&#x51B2; * @return uint16_t &#x547D;&#x4EE4;&#x5E27;&#x957F;&#x5EA6;&#xFF0C;&#x5E27;&#x5934;+&#x547D;&#x4EE4;&#x5B57;+&#x6570;&#x636E;&#x4F4D;+&#x6570;&#x636E;+&#x6821;&#x9A8C; */uint16_t command_build_frame(command_type_t cmd, uint8_t *data,                             uint16_t data_len, uint8_t *output_buffer);#ifdef __cplusplus}#endif#endif\n\n//boot_cmd.c#include &quot;boot_cmd.h&quot;#include &quot;string.h&quot;static rx_state_t rx_state = RX_STATE_HEADER1;static command_frame_t current_frame;static uint16_t data_recived_size = 0;static bool frame_ready = false;static void clear_command_frame(command_frame_t *frame) {    memset(frame, 0, sizeof(command_frame_t));}/** * @brief &#x8BA1;&#x7B97;&#x6821;&#x9A8C;&#x548C; * @param data &#x4ECE;&#x547D;&#x4EE4;&#x5B57;&#x5230;&#x6570;&#x636E;&#x5168;&#x90E8;&#x7684;&#x6570;&#x636E; * @param length &#x957F;&#x5EA6;&#x4E3A;&#x547D;&#x4EE4;(1byte)+&#x6570;&#x636E;&#x957F;&#x5EA6;&#x4FE1;&#x606F;(2byte)+&#x5B9E;&#x9645;&#x6570;&#x636E;&#x957F;&#x5EA6; * @return */static uint8_t calculate_checksum(uint8_t *data, uint16_t length) {    uint8_t sum = 0;    for (uint16_t i = 0; i &lt; length; i++) {        sum += data[i];    }    return (uint8_t)~sum;}/** * @brief &#x9A8C;&#x8BC1;&#x547D;&#x4EE4;&#x662F;&#x5426;&#x5408;&#x6CD5; * @param cmd &#x547D;&#x4EE4;&#x5B57; * @return */static bool is_valid_command(command_type_t cmd) {    return ((cmd &gt; CMD_VALID_START) &amp;&amp; (cmd &lt; CMD_VALID_END));}void command_parser_init(void) {    rx_state = RX_STATE_HEADER1;    clear_command_frame(&amp;current_frame);    data_recived_size = 0;    frame_ready = false;}rx_state_t get_rx_state(void) { return rx_state; }parse_result_t command_process_byte(uint8_t byte) {    parse_result_t ret;    switch (rx_state) {    case RX_STATE_HEADER1:        if (byte == FRAME_HEADER1) {            rx_state = RX_STATE_HEADER2;        } else {            rx_state = RX_STATE_HEADER1;        }        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_HEADER2:        if (byte == FRAME_HEADER2) {            rx_state = RX_STATE_CMD;        } else {            rx_state = RX_STATE_HEADER1;            return PARSE_ERROR_HEADER;        }        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_CMD:        if (is_valid_command((command_type_t)byte)) {            current_frame.command = (command_type_t)byte;            rx_state = RX_STATE_LEN_LOW;            ret = PARSE_INCOMPLETE;        } else {            rx_state = RX_STATE_HEADER1;            ret = PARSE_ERROR_INVALID_CMD;        }        break;    case RX_STATE_LEN_LOW:        current_frame.data_length = byte;        rx_state = RX_STATE_LEN_HIGH;        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_LEN_HIGH:        data_recived_size = 0;        current_frame.data_length |= (byte &lt;&lt; 8);        if (current_frame.data_length == 0) {            rx_state = RX_STATE_CHECKSUM;            ret = PARSE_INCOMPLETE;        } else if (current_frame.data_length &lt; FRAME_SIZE) {            rx_state = RX_STATE_DATA;            ret = PARSE_INCOMPLETE;        } else {            rx_state = RX_STATE_HEADER1;            ret = PARSE_ERROR_LENGTH;        }        break;    case RX_STATE_DATA:        current_frame.data[data_recived_size++] = byte;        if (data_recived_size == current_frame.data_length) {            rx_state = RX_STATE_CHECKSUM;        }        ret = PARSE_INCOMPLETE;        break;    case RX_STATE_CHECKSUM:        current_frame.checksum = byte;        uint8_t checksum;        uint16_t header_size =            sizeof(current_frame.command) + sizeof(current_frame.data_length);        checksum = calculate_checksum((uint8_t *)&amp;current_frame.command,                                      header_size + current_frame.data_length);        if (checksum == current_frame.checksum) {            frame_ready = true;            ret = PARSE_SUCCESS;        } else {            ret = PARSE_ERROR_CHECKSUM;        }        rx_state = RX_STATE_HEADER1;        break;    default:        rx_state = RX_STATE_HEADER1;        ret = PARSE_INCOMPLETE;        break;    }    return ret;}bool command_get_frame(command_frame_t *frame) {    if (frame_ready) {        memcpy(frame, &amp;current_frame, sizeof(command_frame_t));        frame_ready = false;        clear_command_frame(&amp;current_frame);        return true;    }    return false;}uint16_t command_build_frame(command_type_t cmd, uint8_t *data,                             uint16_t data_len, uint8_t *output_buffer) {    uint16_t index = 0;    // &#x5E27;&#x5934;    output_buffer[index++] = FRAME_HEADER1;    output_buffer[index++] = FRAME_HEADER2;    // &#x547D;&#x4EE4;&#x5B57;    output_buffer[index++] = (uint8_t)cmd;    // &#x6570;&#x636E;&#x957F;&#x5EA6;&#xFF08;&#x5C0F;&#x7AEF;&#x5E8F;&#xFF09;    output_buffer[index++] = (uint8_t)(data_len &amp; 0xff);        // &#x4F4E;&#x516B;&#x4F4D;    output_buffer[index++] = (uint8_t)((data_len &gt;&gt; 8) &amp; 0xff); // &#x9AD8;&#x516B;&#x4F4D;    // &#x6570;&#x636E;    if (data != NULL &amp;&amp; data_len &gt; 0) {        memcpy(&amp;output_buffer[index], data, data_len);        index += data_len;    }    // &#x6821;&#x9A8C;&#x548C;    uint8_t checksum = calculate_checksum(&amp;output_buffer[2], index - 2);    output_buffer[index++] = checksum;    return index;}\n\n&#x603B;&#x7ED3;\n&#x4E3B;&#x8981;&#x8BE6;&#x7EC6;&#x5206;&#x6790;&#x4E86;&#x547D;&#x4EE4;&#x5E27;&#x89E3;&#x6790;&#xFF0C;&#x547D;&#x4EE4;&#x5E27;&#x6784;&#x5EFA;&#x6BD4;&#x8F83;&#x7B80;&#x5355;\nbootloader&#x6A21;&#x5F0F;&#x4E2D;&#x4E0D;&#x518D;&#x53EA;&#x662F;led&#x95EA;&#x70C1;&#xFF0C;&#x800C;&#x662F;&#x547D;&#x4EE4;&#x89E3;&#x6790;&#x5668;\n&#x4E0B;&#x4F4D;&#x673A;&#x56DE;&#x5E94;&#x4E0A;&#x4F4D;&#x673A;&#x4F7F;&#x7528;&#x7684;&#x662F;&#x51FD;&#x6570;&#x6307;&#x9488;&#xFF0C;&#x521D;&#x59CB;&#x5316;&#x65F6;&#x4F20;&#x5165;&#x51FD;&#x6570;&#x5C31;&#x884C;\n&#x4EE5;&#x4E0A;&#x53EA;&#x662F;&#x901A;&#x4FE1;&#x534F;&#x8BAE;&#x5B9E;&#x73B0;&#xFF0C;&#x5BF9;&#x4E8E;&#x52A0;&#x8F7D;&#x56FA;&#x4EF6;&#x548C;CRC32&#x6821;&#x9A8C;&#x8FD8;&#x6CA1;&#x6709;&#x5B9E;&#x73B0;\n\n","categories":["Bootloader"],"tags":["STM32","BootLoader"]}]